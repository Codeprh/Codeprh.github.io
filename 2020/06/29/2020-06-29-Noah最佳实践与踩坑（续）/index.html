<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Noah最佳实践与踩坑（续） | Noah</title><meta name="description" content="Noah最佳实践与踩坑（续）"><meta name="keywords" content="Noah最佳实践与踩坑"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Noah最佳实践与踩坑（续）"><meta name="twitter:description" content="Noah最佳实践与踩坑（续）"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzunylo84j31fy0pkapz.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Noah最佳实践与踩坑（续）"><meta property="og:url" content="http://yoursite.com/2020/06/29/2020-06-29-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91%EF%BC%88%E7%BB%AD%EF%BC%89/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="Noah最佳实践与踩坑（续）"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzunylo84j31fy0pkapz.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2020/06/29/2020-06-29-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91%EF%BC%88%E7%BB%AD%EF%BC%89/"><link rel="next" title="SpringFramework5.2.0源码阅读" href="http://yoursite.com/2020/06/27/2020-06-27-Spring%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Noah最佳实践与踩坑（续）"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Noah最佳实践与踩坑（续）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#代码重复-搞定代码重复的三个绝招"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">代码重复:搞定代码重复的三个绝招</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#利用工厂模式-模板方法模式，消除-if…else-和重复代码"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">利用工厂模式 + 模板方法模式，消除 if…else 和重复代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#利用注解-反射消除重复代码"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">利用注解 + 反射消除重复代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#利用属性拷贝工具消除重复代码"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">利用属性拷贝工具消除重复代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题讨论"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">问题讨论</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO：使用了并发工具类库，线程安全就高枕无忧了吗？"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">TODO：使用了并发工具类库，线程安全就高枕无忧了吗？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO-代码加锁：不要让“锁”事成为烦心事"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">TODO:代码加锁：不要让“锁”事成为烦心事</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO：线程池：业务代码最常用也最容易犯错的组件"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">TODO：线程池：业务代码最常用也最容易犯错的组件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO：用好Java8的日期时间类，少踩一些“老三样”的坑"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">TODO：用好Java8的日期时间类，少踩一些“老三样”的坑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO：别以为“自动挡”就不可能出现OOM"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">TODO：别以为“自动挡”就不可能出现OOM</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO：接口设计：系统间对话的语言，一定要统一"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">TODO：接口设计：系统间对话的语言，一定要统一</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#缓存设计：缓存可以锦上添花也可以落井下石"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">缓存设计：缓存可以锦上添花也可以落井下石</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#不要把-Redis-当作数据库"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">不要把 Redis 当作数据库</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意缓存雪崩问题"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">注意缓存雪崩问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意缓存击穿问题"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">注意缓存击穿问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意缓存穿透问题"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">注意缓存穿透问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意缓存数据同步策略"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">注意缓存数据同步策略</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题讨论-1"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">问题讨论</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-1"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO：业务代码写完，就意味着生产就绪了"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">TODO：业务代码写完，就意味着生产就绪了?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#准备工作-配置-Spring-Boot-Actuator"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">准备工作:配置 Spring Boot Actuator</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#消息队列-最佳实践"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">消息队列-最佳实践</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#异步处理需要消息补偿闭环"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">异步处理需要消息补偿闭环</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意消息模式是广播还是工作队列"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">注意消息模式是广播还是工作队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#别让死信堵塞了消息队列"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">别让死信堵塞了消息队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题讨论-2"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">问题讨论</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#回顾总结"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">回顾总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据源头-任何客户端的东西都不可信任"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">数据源头:任何客户端的东西都不可信任</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#客户端的计算不可信"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">客户端的计算不可信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#客户端提交的参数需要校验"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">客户端提交的参数需要校验</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#不能信任请求头里的任何内容"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">不能信任请求头里的任何内容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#用户标识不能从客户端获取"><span class="toc_mobile_items-number">8.4.</span> <span class="toc_mobile_items-text">用户标识不能从客户端获取</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#回顾总结-1"><span class="toc_mobile_items-number">8.5.</span> <span class="toc_mobile_items-text">回顾总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#如何正确保存和传输敏感数据"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">如何正确保存和传输敏感数据?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应该怎样保存用户密码"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">应该怎样保存用户密码?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应该怎么保存姓名和身份证"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">应该怎么保存姓名和身份证?</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Noah最佳实践与踩坑（续）"><span class="toc-number">1.</span> <span class="toc-text">Noah最佳实践与踩坑（续）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码重复-搞定代码重复的三个绝招"><span class="toc-number">2.</span> <span class="toc-text">代码重复:搞定代码重复的三个绝招</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#利用工厂模式-模板方法模式，消除-if…else-和重复代码"><span class="toc-number">2.1.</span> <span class="toc-text">利用工厂模式 + 模板方法模式，消除 if…else 和重复代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用注解-反射消除重复代码"><span class="toc-number">2.2.</span> <span class="toc-text">利用注解 + 反射消除重复代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用属性拷贝工具消除重复代码"><span class="toc-number">2.3.</span> <span class="toc-text">利用属性拷贝工具消除重复代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题讨论"><span class="toc-number">2.4.</span> <span class="toc-text">问题讨论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾"><span class="toc-number">2.5.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO：使用了并发工具类库，线程安全就高枕无忧了吗？"><span class="toc-number">3.</span> <span class="toc-text">TODO：使用了并发工具类库，线程安全就高枕无忧了吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO-代码加锁：不要让“锁”事成为烦心事"><span class="toc-number">3.1.</span> <span class="toc-text">TODO:代码加锁：不要让“锁”事成为烦心事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO：线程池：业务代码最常用也最容易犯错的组件"><span class="toc-number">3.2.</span> <span class="toc-text">TODO：线程池：业务代码最常用也最容易犯错的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO：用好Java8的日期时间类，少踩一些“老三样”的坑"><span class="toc-number">3.3.</span> <span class="toc-text">TODO：用好Java8的日期时间类，少踩一些“老三样”的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO：别以为“自动挡”就不可能出现OOM"><span class="toc-number">3.4.</span> <span class="toc-text">TODO：别以为“自动挡”就不可能出现OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO：接口设计：系统间对话的语言，一定要统一"><span class="toc-number">3.5.</span> <span class="toc-text">TODO：接口设计：系统间对话的语言，一定要统一</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存设计：缓存可以锦上添花也可以落井下石"><span class="toc-number">4.</span> <span class="toc-text">缓存设计：缓存可以锦上添花也可以落井下石</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不要把-Redis-当作数据库"><span class="toc-number">4.1.</span> <span class="toc-text">不要把 Redis 当作数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意缓存雪崩问题"><span class="toc-number">4.2.</span> <span class="toc-text">注意缓存雪崩问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意缓存击穿问题"><span class="toc-number">4.3.</span> <span class="toc-text">注意缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意缓存穿透问题"><span class="toc-number">4.4.</span> <span class="toc-text">注意缓存穿透问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意缓存数据同步策略"><span class="toc-number">4.5.</span> <span class="toc-text">注意缓存数据同步策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题讨论-1"><span class="toc-number">4.6.</span> <span class="toc-text">问题讨论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-1"><span class="toc-number">4.7.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO：业务代码写完，就意味着生产就绪了"><span class="toc-number">5.</span> <span class="toc-text">TODO：业务代码写完，就意味着生产就绪了?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-配置-Spring-Boot-Actuator"><span class="toc-number">5.1.</span> <span class="toc-text">准备工作:配置 Spring Boot Actuator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息队列-最佳实践"><span class="toc-number">6.</span> <span class="toc-text">消息队列-最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异步处理需要消息补偿闭环"><span class="toc-number">6.1.</span> <span class="toc-text">异步处理需要消息补偿闭环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意消息模式是广播还是工作队列"><span class="toc-number">6.2.</span> <span class="toc-text">注意消息模式是广播还是工作队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#别让死信堵塞了消息队列"><span class="toc-number">6.3.</span> <span class="toc-text">别让死信堵塞了消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题讨论-2"><span class="toc-number">6.4.</span> <span class="toc-text">问题讨论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾总结"><span class="toc-number">6.5.</span> <span class="toc-text">回顾总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？"><span class="toc-number">7.</span> <span class="toc-text">TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据源头-任何客户端的东西都不可信任"><span class="toc-number">8.</span> <span class="toc-text">数据源头:任何客户端的东西都不可信任</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端的计算不可信"><span class="toc-number">8.1.</span> <span class="toc-text">客户端的计算不可信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端提交的参数需要校验"><span class="toc-number">8.2.</span> <span class="toc-text">客户端提交的参数需要校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不能信任请求头里的任何内容"><span class="toc-number">8.3.</span> <span class="toc-text">不能信任请求头里的任何内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户标识不能从客户端获取"><span class="toc-number">8.4.</span> <span class="toc-text">用户标识不能从客户端获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾总结-1"><span class="toc-number">8.5.</span> <span class="toc-text">回顾总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何正确保存和传输敏感数据"><span class="toc-number">9.</span> <span class="toc-text">如何正确保存和传输敏感数据?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#应该怎样保存用户密码"><span class="toc-number">9.1.</span> <span class="toc-text">应该怎样保存用户密码?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应该怎么保存姓名和身份证"><span class="toc-number">9.2.</span> <span class="toc-text">应该怎么保存姓名和身份证?</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Noah最佳实践与踩坑（续）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-29<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-22</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/">Noah最佳实践与踩坑</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">17.9k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 61 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="Noah最佳实践与踩坑（续）"><a href="#Noah最佳实践与踩坑（续）" class="headerlink" title="Noah最佳实践与踩坑（续）"></a>Noah最佳实践与踩坑（续）</h1><h1 id="代码重复-搞定代码重复的三个绝招"><a href="#代码重复-搞定代码重复的三个绝招" class="headerlink" title="代码重复:搞定代码重复的三个绝招"></a><strong>代码重复:搞定代码重复的三个绝招</strong></h1><ul>
<li>可维护性是大型项目成熟度的一个重要指标，而提升可维护性非常重要的一个手 段就是减少代码重复。那为什么这样说呢?<ol>
<li>如果多处重复代码实现完全相同的功能，很容易修改一处忘记修改另一处，造成 Bug;</li>
<li>有一些代码并不是完全重复，而是相似度很高，修改这些类似的代码容易改(复制粘 贴)错，把原本有区别的地方改为了一样。</li>
</ol>
</li>
<li>如何使用 Java 中的一些高级特 性、设计模式，以及一些工具消除重复代码，才能既优雅又高端。</li>
</ul>
<h2 id="利用工厂模式-模板方法模式，消除-if…else-和重复代码"><a href="#利用工厂模式-模板方法模式，消除-if…else-和重复代码" class="headerlink" title="利用工厂模式 + 模板方法模式，消除 if…else 和重复代码"></a><strong>利用工厂模式</strong> <strong>+</strong> <strong>模板方法模式，消除</strong> <strong>if…else</strong> <strong>和重复代码</strong></h2><ul>
<li><p>需求背景：假设要开发一个购物车下单的功能，针对不同用户进行不同处理:</p>
<ol>
<li>普通用户需要收取运费，运费是商品价格的 10%，无商品折扣;</li>
<li>VIP 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开 始享受一定折扣</li>
<li>内部用户可以免运费，无商品折扣。</li>
</ol>
</li>
<li><p>代码最佳实践：理论分析</p>
<ol>
<li>设计模式：模板方法+工厂方法</li>
<li>如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定 义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢?</li>
<li>通过spring的IOC容器能力，通过Bean的名称直接获取到AbstractCat，调用其process方法即可实现</li>
<li><strong>这样一来，我们就利用工厂模式 + 模板方法模式，不仅消除了重复代码，还避免了修改既 有代码的风险</strong>。这就是设计模式中的开闭原则:对修改关闭，对扩展开放。</li>
</ol>
</li>
<li><p>代码最佳实践：源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购物车实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span> </span>&#123;</span><br><span class="line">    <span class="comment">//商品清单</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//总优惠</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalDiscount;</span><br><span class="line">    <span class="comment">//商品总价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalItemPrice;</span><br><span class="line">    <span class="comment">//总运费</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalDeliveryPrice;</span><br><span class="line">    <span class="comment">//应付总价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal payPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="comment">//商品Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//商品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="comment">//商品单价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="comment">//商品优惠</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal couponPrice;</span><br><span class="line">    <span class="comment">//商品运费</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal deliveryPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计模式：模板方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 我们在父类中实现了购物车处理的流程模板，然后把需 要特殊处理的地方留空白也就是留抽象方法定义，让子类去实现其中的逻辑。</span></span><br><span class="line"><span class="comment"> * 由于父类的逻 辑不完整无法单独工作，因此需要定义为抽象类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cart <span class="title">process</span><span class="params">(<span class="keyword">long</span> userId, Map&lt;Long, Integer&gt; items)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Cart cart = <span class="keyword">new</span> Cart();</span><br><span class="line"></span><br><span class="line">        List&lt;Item&gt; itemList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        items.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">            Item item = <span class="keyword">new</span> Item();</span><br><span class="line">            item.setId(entry.getKey());</span><br><span class="line">            item.setPrice(Db.getItemPrice(entry.getKey()));</span><br><span class="line">            item.setQuantity(entry.getValue());</span><br><span class="line">            itemList.add(item);</span><br><span class="line">        &#125;);</span><br><span class="line">        cart.setItems(itemList);</span><br><span class="line"></span><br><span class="line">        itemList.stream().forEach(item -&gt; &#123;</span><br><span class="line">            processCouponPrice(userId, item);</span><br><span class="line">            processDeliveryPrice(userId, item);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cart.setTotalItemPrice(cart.getItems().stream().map(item -&gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))).reduce(BigDecimal.ZERO, BigDecimal::add));</span><br><span class="line">        cart.setTotalDeliveryPrice(cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));</span><br><span class="line">        cart.setTotalDiscount(cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));</span><br><span class="line">        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));</span><br><span class="line">        <span class="keyword">return</span> cart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法：计算优惠券</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processCouponPrice</span><span class="params">(<span class="keyword">long</span> userId, Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法：计算邮费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processDeliveryPrice</span><span class="params">(<span class="keyword">long</span> userId, Item item)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通用户购物车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(value = <span class="string">"NormalUserCart"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalUserCart</span> <span class="keyword">extends</span> <span class="title">AbstractCart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCouponPrice</span><span class="params">(<span class="keyword">long</span> userId, Item item)</span> </span>&#123;</span><br><span class="line">        item.setCouponPrice(BigDecimal.ZERO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processDeliveryPrice</span><span class="params">(<span class="keyword">long</span> userId, Item item)</span> </span>&#123;</span><br><span class="line">        item.setDeliveryPrice(item.getPrice()</span><br><span class="line">                .multiply(BigDecimal.valueOf(item.getQuantity()))</span><br><span class="line">                .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP 用户的购物车 VipUserCart，直接继承了 NormalUserCart，只需要修改多买优惠策 略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(value = <span class="string">"VipUserCart"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipUserCart</span> <span class="keyword">extends</span> <span class="title">NormalUserCart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCouponPrice</span><span class="params">(<span class="keyword">long</span> userId, Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.getQuantity() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            item.setCouponPrice(item.getPrice()</span><br><span class="line">                    .multiply(BigDecimal.valueOf(<span class="number">100</span> - Db.getUserCouponPercent(userId)).divide(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)))</span><br><span class="line">                    .multiply(BigDecimal.valueOf(item.getQuantity() - <span class="number">2</span>)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            item.setCouponPrice(BigDecimal.ZERO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板方法：优雅实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Cart <span class="title">right</span><span class="params">(@RequestParam(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId) </span>&#123;</span><br><span class="line">    String userCategory = Db.getUserCategory(userId);</span><br><span class="line">    AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + <span class="string">"UserCart"</span>);</span><br><span class="line">    <span class="keyword">return</span> cart.process(userId, items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图解设计模式-模板方法<img alt="设计模式-模板方法（购物车用户）" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggg4ea5ztlj30l30nx0uw.jpg" class="lazyload"></p>
</li>
</ul>
<h2 id="利用注解-反射消除重复代码"><a href="#利用注解-反射消除重复代码" class="headerlink" title="利用注解 + 反射消除重复代码"></a><strong>利用注解</strong> <strong>+</strong> 反射消除重复代码</h2><ul>
<li><p>需求背景：假设银行提供了一些 API 接口，对参数的序列化有点特殊，不使用 JSON，而是需要我们 把参数依次拼在一起构成一个大字符串。</p>
</li>
<li><p>按照银行提供的 API 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整 个字符串。</p>
<ul>
<li>因为每一种参数都有固定长度，未达到长度时需要做填充处理:<ul>
<li>字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左;</li>
<li>数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右;</li>
<li>货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行左填充。</li>
</ul>
</li>
<li>对所有参数做 MD5 操作作为签名(为了方便理解，Demo 中不涉及加盐处理)。</li>
</ul>
</li>
<li><p>普通实现代码问题：</p>
<ol>
<li>三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 Bug;</li>
<li>处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复;</li>
<li>实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错;</li>
<li>代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。</li>
</ol>
</li>
<li><p>图解-第三方请求参数Api：<img alt="image-20200706063613966" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggguwk8njij30j50kyq8o.jpg" class="lazyload"></p>
</li>
<li><p>代码最佳实践：理论分析</p>
<ol>
<li>就是要用注解和反射!</li>
<li><strong>所有处理参数排序、填充、加签、请求调用的核心逻辑，都汇聚在了 remoteCall 方法中</strong></li>
<li><strong>许多涉及类结构性的通用处理，都可以按照这个模式来减少重复代码</strong><ul>
<li>反射给予了我 们在不知晓类结构的时候，按照固定的逻辑处理类的成员;</li>
<li>而注解给了我们为这些成员补充 元数据的能力，使得我们利用反射实现通用逻辑的时候，可以从外部获得更多我们关心的数 据</li>
</ul>
</li>
</ol>
</li>
<li><p>代码最佳实践：源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们就能通过自定义注解为接口和所有参数增加一些元数据.</span></span><br><span class="line"><span class="comment"> * 我们定义一个接口 API 的注解 BankAPI，包含接口 URL 地址和接口说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BankAPI &#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于描述接口的每一个字段规范，包 含参数的次序、类型和长度三个属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BankAPIField &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要实现接口逻辑和逻辑实现的剥离，首先需要以 POJO 类(只有属性没有任何业务逻辑的 数据类)的方式定义所有的接口参数</span></span><br><span class="line"><span class="comment"> * 创建用户API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BankAPI</span>(url = <span class="string">"/bank/createUser"</span>, desc = <span class="string">"创建用户接口"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateUserAPI</span> <span class="keyword">extends</span> <span class="title">AbstractAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">1</span>, type = <span class="string">"S"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">2</span>, type = <span class="string">"S"</span>, length = <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">private</span> String identity;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">4</span>, type = <span class="string">"S"</span>, length = <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">3</span>, type = <span class="string">"N"</span>, length = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractAPI 类是一个空实现，因为这个案例中的接口并没有公共数据可 以抽象放到基类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射配合注解，动态获取接口参数类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterBankService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用户api接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mobile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUser</span><span class="params">(String name, String identity, String mobile, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        CreateUserAPI createUserAPI = <span class="keyword">new</span> CreateUserAPI();</span><br><span class="line">        <span class="comment">//封装参数</span></span><br><span class="line">        createUserAPI.setName(name);</span><br><span class="line">        createUserAPI.setIdentity(identity);</span><br><span class="line">        createUserAPI.setAge(age);</span><br><span class="line">        createUserAPI.setMobile(mobile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remoteCall(createUserAPI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pay</span><span class="params">(<span class="keyword">long</span> userId, BigDecimal amount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        PayAPI payAPI = <span class="keyword">new</span> PayAPI();</span><br><span class="line">        <span class="comment">//封装参数</span></span><br><span class="line">        payAPI.setUserId(userId);</span><br><span class="line">        payAPI.setAmount(amount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remoteCall(payAPI);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//所有处理参数排序、填充、加签、请求调用的核心逻辑，都汇聚在了 remoteCall 方法中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">remoteCall</span><span class="params">(AbstractAPI api)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//从BankAPI注解获取请求地址</span></span><br><span class="line">        BankAPI bankAPI = api.getClass().getAnnotation(BankAPI<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bankAPI.url();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(api.getClass().getDeclaredFields()) <span class="comment">//获得所有字段</span></span><br><span class="line">                .filter(field -&gt; field.isAnnotationPresent(BankAPIField<span class="class">.<span class="keyword">class</span>)) //查找标记了注解的字段</span></span><br><span class="line"><span class="class">                .<span class="title">sorted</span>(<span class="title">Comparator</span>.<span class="title">comparingInt</span>(<span class="title">a</span> -&gt; <span class="title">a</span>.<span class="title">getAnnotation</span>(<span class="title">BankAPIField</span>.<span class="title">class</span>).<span class="title">order</span>())) //根据注解中的<span class="title">order</span>对字段排序</span></span><br><span class="line"><span class="class">                .<span class="title">peek</span>(<span class="title">field</span> -&gt; <span class="title">field</span>.<span class="title">setAccessible</span>(<span class="title">true</span>)) //设置可以访问私有字段</span></span><br><span class="line"><span class="class">                .<span class="title">forEach</span>(<span class="title">field</span> -&gt; </span>&#123;</span><br><span class="line">                    <span class="comment">//获得注解</span></span><br><span class="line">                    BankAPIField bankAPIField = field.getAnnotation(BankAPIField<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    Object value = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//反射获取字段值</span></span><br><span class="line">                        value = field.get(api);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//根据字段类型以正确的填充方式格式化字符串</span></span><br><span class="line">                    <span class="keyword">switch</span> (bankAPIField.type()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"S"</span>: &#123;</span><br><span class="line">                            stringBuilder.append(String.format(<span class="string">"%-"</span> + bankAPIField.length() + <span class="string">"s"</span>, value.toString()).replace(<span class="string">' '</span>, <span class="string">'_'</span>));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"N"</span>: &#123;</span><br><span class="line">                            stringBuilder.append(String.format(<span class="string">"%"</span> + bankAPIField.length() + <span class="string">"s"</span>, value.toString()).replace(<span class="string">' '</span>, <span class="string">'0'</span>));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"M"</span>: &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> BigDecimal))</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"&#123;&#125; 的 &#123;&#125; 必须是BigDecimal"</span>, api, field));</span><br><span class="line">                            stringBuilder.append(String.format(<span class="string">"%0"</span> + bankAPIField.length() + <span class="string">"d"</span>, ((BigDecimal) value).setScale(<span class="number">2</span>, RoundingMode.DOWN).multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue()));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//签名逻辑</span></span><br><span class="line">        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));</span><br><span class="line">        String param = stringBuilder.toString();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//发请求</span></span><br><span class="line">        String result = Request.Post(<span class="string">"http://localhost:45678/reflection"</span> + bankAPI.url())</span><br><span class="line">                .bodyString(param, ContentType.APPLICATION_JSON)</span><br><span class="line">                .execute().returnContent().asString();</span><br><span class="line">        log.info(<span class="string">"调用银行API &#123;&#125; url:&#123;&#125; 参数:&#123;&#125; 耗时:&#123;&#125;ms"</span>, bankAPI.desc(), bankAPI.url(), param, System.currentTimeMillis() - begin);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="利用属性拷贝工具消除重复代码"><a href="#利用属性拷贝工具消除重复代码" class="headerlink" title="利用属性拷贝工具消除重复代码"></a>利用属性拷贝工具消除重复代码</h2><p>使用类似BeanUtils这种Mapping工具来做Bean的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.copyProperties(orderDTO, orderDO, <span class="string">"id"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题讨论"><a href="#问题讨论" class="headerlink" title="问题讨论"></a>问题讨论</h2><ol>
<li>除了模板方法设计模式是减少重复代码的一把好手，观察者模式也常用于减少代码重复 (并且是松耦合方式)。Spring 也提供了类似工具，你能想到有哪 些应用场景吗?<ul>
<li>有名的当属guava的EventBus了</li>
</ul>
</li>
<li>关于 Bean 属性复制工具，除了最简单的 Spring 的 BeanUtils 工具类的使用，你还知道 哪些对象映射类库吗?它们又有什么功能呢?</li>
</ol>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一种代码重复是，有多个并行的类实现相似的代码逻辑。我们可以考虑提取相同逻辑在父 类中实现，差异逻辑通过抽象方法留给子类实现。使用类似的模板方法把相同的流程和逻辑 固定成模板，保留差异的同时尽可能避免代码重复。同时，可以使用 Spring 的 IoC 特性注 入相应的子类，来避免实例化子类时的大量 if…else 代码</li>
<li>第二种代码重复是，使用硬编码的方式重复实现相同的数据处理算法。我们可以考虑把规则 转换为自定义注解，作为元数据对类或对字段、方法进行描述，然后通过反射动态读取这些 元数据、字段或调用方法，实现规则参数和规则定义的分离。也就是说，把变化的部分也就 是规则的参数放入注解，规则的定义统一处理</li>
<li>第三种代码重复是，业务代码中常见的 DO、DTO、VO 转换时大量字段的手动赋值，遇到 有上百个属性的复杂类型，非常非常容易出错。我的建议是，不要手动进行赋值，考虑使用 Bean 映射工具进行。此外，还可以考虑采用单元测试对所有字段进行赋值正确性校验</li>
</ol>
<h1 id="TODO：使用了并发工具类库，线程安全就高枕无忧了吗？"><a href="#TODO：使用了并发工具类库，线程安全就高枕无忧了吗？" class="headerlink" title="TODO：使用了并发工具类库，线程安全就高枕无忧了吗？"></a>TODO：使用了并发工具类库，线程安全就高枕无忧了吗？</h1><h2 id="TODO-代码加锁：不要让“锁”事成为烦心事"><a href="#TODO-代码加锁：不要让“锁”事成为烦心事" class="headerlink" title="TODO:代码加锁：不要让“锁”事成为烦心事"></a>TODO:代码加锁：不要让“锁”事成为烦心事</h2><h2 id="TODO：线程池：业务代码最常用也最容易犯错的组件"><a href="#TODO：线程池：业务代码最常用也最容易犯错的组件" class="headerlink" title="TODO：线程池：业务代码最常用也最容易犯错的组件"></a>TODO：线程池：业务代码最常用也最容易犯错的组件</h2><h2 id="TODO：用好Java8的日期时间类，少踩一些“老三样”的坑"><a href="#TODO：用好Java8的日期时间类，少踩一些“老三样”的坑" class="headerlink" title="TODO：用好Java8的日期时间类，少踩一些“老三样”的坑"></a>TODO：用好Java8的日期时间类，少踩一些“老三样”的坑</h2><h2 id="TODO：别以为“自动挡”就不可能出现OOM"><a href="#TODO：别以为“自动挡”就不可能出现OOM" class="headerlink" title="TODO：别以为“自动挡”就不可能出现OOM"></a>TODO：别以为“自动挡”就不可能出现OOM</h2><h2 id="TODO：接口设计：系统间对话的语言，一定要统一"><a href="#TODO：接口设计：系统间对话的语言，一定要统一" class="headerlink" title="TODO：接口设计：系统间对话的语言，一定要统一"></a>TODO：接口设计：系统间对话的语言，一定要统一</h2><h1 id="缓存设计：缓存可以锦上添花也可以落井下石"><a href="#缓存设计：缓存可以锦上添花也可以落井下石" class="headerlink" title="缓存设计：缓存可以锦上添花也可以落井下石"></a>缓存设计：缓存可以锦上添花也可以落井下石</h1><ul>
<li>通常我们会使用更快的介质(比如内存)作为缓存，来解决较慢介质(比如磁盘)读取数据 慢的问题，缓存是用空间换时间，来解决性能问题的一种架构设计模式。更重要的是，磁盘 上存储的往往是原始数据，而缓存中保存的可以是面向呈现的数据。这样一来，缓存不仅仅 是加快了 IO，还可以减少原始数据的计算工作。</li>
<li>缓存系统一般设计简单，功能相对单一，所以诸如 Redis 这种缓存系统的整体吞吐 量，能达到关系型数据库的几倍甚至几十倍，因此缓存特别适用于互联网应用的高并发场 景。</li>
<li>使用 Redis 做缓存虽然简单好用，但使用和设计缓存并不是 set 一下这么简单，需要<strong>注意 缓存的同步、雪崩、并发、穿透等问题</strong>。今天，我们就来详细聊聊。</li>
</ul>
<h2 id="不要把-Redis-当作数据库"><a href="#不要把-Redis-当作数据库" class="headerlink" title="不要把 Redis 当作数据库"></a><strong>不要把</strong> <strong>Redis</strong> <strong>当作数据库</strong></h2><ul>
<li>通常，我们会使用 Redis 等分布式缓存数据库来缓存数据，但是<strong>千万别把 Redis 当做数据 库来使用。</strong>因为 Redis 中数据消失导致业务逻辑错误，并且因为没有 保留原始数据，业务都无法恢复。<ol>
<li>Redis 的确具有数据持久化功能，可以实现服务重启后数据不丢失。这一点，很容易让我们 误认为 Redis 可以作为高性能的 KV 数据库</li>
<li>从本质上来看，Redis(免费版)是一个内存数据库，所有数据保存在内存中，并且 直接从内存读写数据响应操作，只不过具有数据持久化能力。所以，Redis 的特点是，处理 请求很快，但无法保存超过内存大小的数据。</li>
<li>VM 模式虽然可以保存超过内存大小的数据，但是因为性能原因从 2.6 开始已经 被废弃。此外，Redis 企业版提供了 Redis on Flash 可以实现 Key+ 字典 + 热数据保存 在内存中，冷数据保存在 SSD 中</li>
</ol>
</li>
<li>把 Redis 用作缓存，我们需要注意两点。<ol>
<li>从客户端的角度来说，缓存数据的特点一定是有原始数据来源，且允许丢失，即使设 置的缓存时间是 1 分钟，在 30 秒时缓存数据因为某种原因消失了，我们也要能接受。当数 据丢失后，我们需要从原始数据重新加载数据，不能认为缓存系统是绝对可靠的，更不能认 为缓存系统不会删除没有过期的数据。</li>
<li>从 Redis 服务端的角度来说，缓存系统可以保存的数据量一定是小于原始数据的。 首先，我们应该限制 Redis 对内存的使用量，<strong>也就是设置 maxmemory 参数</strong>;其次，我们 应该根据数据特点，明确 Redis 应该以怎样的算法来驱逐数据。<strong>常用的数据淘汰策略有</strong><ul>
<li>allkeys-lru，针对所有 Key，优先删除最近最少使用的 Key;</li>
<li>volatile-lru，针对带有过期时间的 Key，优先删除最近最少使用的 Key;</li>
<li>volatile-ttl，针对带有过期时间的 Key，优先删除即将过期的 Key(根据 TTL 的值);</li>
<li>allkeys-lfu(Redis 4.0 以上)，针对所有 Key，优先删除最少使用的 Key;</li>
<li>volatile-lfu(Redis 4.0 以上)，针对带有过期时间的 Key，优先删除最少使用的 Key。</li>
</ul>
</li>
</ol>
</li>
<li>其实，这些算法是 Key 范围 +Key 选择算法的搭配组合，其中范围有 allkeys 和 volatile 两种，算法有 LRU、TTL 和 LFU 三种。接下来，我就从 Key 范围和算法角度，和你说说如 何选择合适的驱逐算法。<ul>
<li>首先，从算法角度来说，Redis 4.0 以后推出的 LFU 比 LRU 更“实用”。试想一下，如果 一个 Key 访问频率是 1 天一次，但正好在 1 秒前刚访问过，那么 LRU 可能不会选择优先 淘汰这个 Key，反而可能会淘汰一个 5 秒访问一次但最近 2 秒没有访问过的 Key，而 LFU 算法不会有这个问题。而 TTL 会比较“头脑简单”一点，优先删除即将过期的 Key，但有 可能这个 Key 正在被大量访问。</li>
<li>然后，从 Key 范围角度来说，allkeys 可以确保即使 Key 没有 TTL 也能回收，如果使用的 时候客户端总是“忘记”设置缓存的过期时间，那么可以考虑使用这个系列的算法。而 volatile 会更稳妥一些，万一客户端把 Redis 当做了长效缓存使用，只是启动时候初始化一 次缓存，那么一旦删除了此类没有 TTL 的数据，可能就会导致客户端出错。</li>
<li>所以，不管是使用者还是管理者都要考虑 Redis 的使用方式，使用者需要考虑应该以缓存 的姿势来使用 Redis，管理者应该为 Redis 设置内存限制和合适的驱逐策略，避免出现 OOM。</li>
</ul>
</li>
</ul>
<h2 id="注意缓存雪崩问题"><a href="#注意缓存雪崩问题" class="headerlink" title="注意缓存雪崩问题"></a>注意缓存雪崩问题</h2><ul>
<li><p>由于缓存系统的 IOPS 比数据库高很多，因此要特别小心短时间内大量缓存失效的情况。这 种情况一旦发生，可能就会在瞬间有大量的数据需要回源到数据库查询，对数据库造成极大 的压力，极限情况下甚至导致后端数据库直接崩溃。<strong>这就是我们常说的缓存失效，也叫作缓 存雪崩</strong>。</p>
</li>
<li><p>从广义上说，产生缓存雪崩的原因有两种:</p>
<ol>
<li>第一种是，缓存系统本身不可用，导致大量请求直接回源到数据库;</li>
<li>第二种是，应用设计层面大量的 Key 在同一时间过期，导致大量的数据回源。</li>
<li>第一种原因，主要涉及缓存系统本身高可用的配置，不属于缓存设计层面的问题，所以今天 我主要和你说说如何确保大量 Key 不在同一时间被动过期。</li>
</ol>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生缓存雪崩：大量的key在同一时间过期，请求流量到db去了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrongInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).forEach(i -&gt; stringRedisTemplate.opsForValue().set(<span class="string">"city"</span> + i, getCityFromDb(i), <span class="number">30</span>, TimeUnit.SECONDS));</span><br><span class="line">    log.info(<span class="string">"Cache init finished"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//每秒一次，输出数据库访问的QPS</span></span><br><span class="line">    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"DB QPS : &#123;&#125;"</span>, atomicInteger.getAndSet(<span class="number">0</span>));</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存雪崩解决方案1：ThreadLocalRandom.current().nextInt(10)，增加随机休眠时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightInit1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).forEach(i -&gt; stringRedisTemplate.opsForValue().set(<span class="string">"city"</span> + i, getCityFromDb(i), <span class="number">30</span> + ThreadLocalRandom.current().nextInt(<span class="number">10</span>), TimeUnit.SECONDS));</span><br><span class="line">  </span><br><span class="line">    log.info(<span class="string">"Cache init finished"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//每秒一次，输出数据库访问的QPS</span></span><br><span class="line">    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"DB QPS : &#123;&#125;"</span>, atomicInteger.getAndSet(<span class="number">0</span>));</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让缓存不主动过期。初始化缓存数据的时候设置缓存永不过期，然后启动一个后台 线程 30 秒一次定时把所有数据更新到缓存，而且通过适当的休眠.</span></span><br><span class="line"><span class="comment"> * DB QPS : 37</span></span><br><span class="line"><span class="comment"> * DB QPS : 37</span></span><br><span class="line"><span class="comment"> * DB QPS : 35</span></span><br><span class="line"><span class="comment"> * DB QPS : 36</span></span><br><span class="line"><span class="comment"> * DB QPS : 38</span></span><br><span class="line"><span class="comment"> * DB QPS : 40</span></span><br><span class="line"><span class="comment"> * DB QPS : 40</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightInit2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//模拟每30s，更新数据库</span></span><br><span class="line">    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).forEach(i -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">            String data = getCityFromDb(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(data)) &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">"city"</span> + i, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"Cache update finished"</span>);</span><br><span class="line">        <span class="comment">//启动程序的时候需要等待首次更新缓存完成</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//每秒一次，输出数据库访问的QPS</span></span><br><span class="line">    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"DB QPS : &#123;&#125;"</span>, atomicInteger.getAndSet(<span class="number">0</span>));</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  </span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决缓存 Key 同时大规模失效需要回源，导致数据库压力激增问题的方式有两种。</p>
<ol>
<li>差异化缓存过期时间，不要让大量的 Key 在同一时间过期。比如，在初始化缓存 的时候，设置缓存的过期时间是 30 秒 +10 秒以内的随机延迟(扰动值)。这样，这些 Key 不会集中在 30 秒这个时刻过期，而是会分散在 30~40 秒之间过期</li>
<li>方案二，让缓存不主动过期。初始化缓存数据的时候设置缓存永不过期，然后启动一个后台 线程 30 秒一次定时把所有数据更新到缓存，而且通过适当的休眠，控制从数据库更新数据 的频率，降低数据库压力。并且数据库的压力会比较稳定</li>
<li>关于这两种解决方案，<strong>我们需要特别注意以下三点</strong>：<ul>
<li>方案一和方案二是截然不同的两种缓存方式，如果无法全量缓存所有数据，那么只能使用方案一;</li>
<li>即使使用了方案二，缓存永不过期，同样需要在查询的时候，确保有回源的逻辑。正如 之前所说，我们无法确保缓存系统中的数据永不丢失</li>
<li>不管是方案一还是方案二，在把数据从数据库加入缓存的时候，都需要判断来自数据库 的数据是否合法，比如进行最基本的判空检查。把数据加入缓存之前一 定要校验数据。</li>
</ul>
</li>
</ol>
</li>
<li><p>说到这里，我们再仔细看一下回源 QPS 超过 700 的截图，可以看到在并发情况下，总共 1000 条数据回源达到了 1002 次，说明有一些条目出现了并发回源。这，就是我后面要讲 到的缓存并发问题</p>
</li>
</ul>
<h2 id="注意缓存击穿问题"><a href="#注意缓存击穿问题" class="headerlink" title="注意缓存击穿问题"></a><strong>注意缓存击穿问题</strong></h2><ul>
<li><p>在某些 Key 属于极端热点数据，且并发量很大的情况下，如果这个 Key 过期，可能会在某 个瞬间出现大量的并发请求同时回源，相当于大量的并发请求直接打到了数据库。<strong>这种情 况，就是我们常说的缓存击穿或缓存并发问题</strong>。</p>
</li>
<li><p>缓存击穿问题，理论分析：</p>
<ol>
<li>如果回源操作特别昂贵，那么这种并发就不能忽略不计。这时，我们可以考虑使用锁机制来 限制回源的并发。</li>
<li>在真实的业务场景下，<strong>不一定</strong>要这么严格地使用双重检查分布式锁进行全局的并发限制，因 为这样虽然可以把数据库回源并发降到最低，但也限制了缓存失效时的并发。可以考虑的方式是下面两种</li>
<li>解决方案一：使用进程内的锁进行限制，这样每一个节点都可以以一个并发回源数据库;</li>
<li>解决方案二：不使用锁进行限制，而是使用类似 Semaphore 的工具限制并发数，比如限制 为 10，这样既限制了回源并发数不至于太大，又能使得一定量的线程可以同时回源。</li>
</ol>
</li>
<li><p>缓存击穿问题，源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * qps能达到20，产生了回源并发问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    String data = stringRedisTemplate.opsForValue().get(<span class="string">"hotsopt"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">  </span><br><span class="line">        data = getExpensiveData();</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"hotsopt"</span>, data, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存击穿（缓存并发问题，）</span></span><br><span class="line"><span class="comment"> * 分布式锁：解决回源并发问题，如果回源的成本很高，这是不能忽略的问题。</span></span><br><span class="line"><span class="comment"> * 方案1：分布式锁+双重检查限制了全局的并发只有一个。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在真实的业务场景下，不一定要这么严格地使用双重检查分布式锁进行全局的并发限制，因 为这样虽然可以把数据库回源并发降到最低，但也限制了缓存失效时的并发。可以考虑的方 式是:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1、使用进程内的锁进行限制，这样每一个节点都可以以一个并发回源数据库;</span></span><br><span class="line"><span class="comment"> * 2、不使用锁进行限制，而是使用类似 Semaphore 的工具限制并发数，比如限制 为 10，这样既限制了回源并发数不至于太大，又能使得一定量的线程可以同时回源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    String data = stringRedisTemplate.opsForValue().get(<span class="string">"hotsopt"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">  </span><br><span class="line">        RLock locker = redissonClient.getLock(<span class="string">"locker"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (locker.tryLock()) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//双重检查，因为可能已经有一个B线程过了第一次判断，在等锁，然后A线程已经把结果返回了</span></span><br><span class="line">                data = stringRedisTemplate.opsForValue().get(<span class="string">"hotsopt"</span>);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">                    data = getExpensiveData();</span><br><span class="line">                    stringRedisTemplate.opsForValue().set(<span class="string">"hotsopt"</span>, data, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                locker.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="注意缓存穿透问题"><a href="#注意缓存穿透问题" class="headerlink" title="注意缓存穿透问题"></a>注意缓存穿透问题</h2><ul>
<li>在之前的例子中，缓存回源的逻辑都是当缓存中查不到需要的数据时，回源到数据库查询。 这里容易出现的一个漏洞是，缓存中没有数据不一定代表数据没有缓存，还有一种可能是原 始数据压根就不存在。</li>
<li>缓存穿透和缓存击穿的区别<ol>
<li>缓存穿透是指，缓存没有起到压力缓冲的作用;</li>
<li>而缓存击穿是指，缓存失效时瞬时的并发打到数据库。</li>
</ol>
</li>
<li>缓存穿透问题的解决方案：<ol>
<li>对于不存在的数据，同样设置一个特殊的 Value 到缓存中，比如当数据库中查出 的用户信息为空的时候，设置 NODATA 这样具有特殊含义的字符串到缓存中。这样下次请 求缓存的时候还是可以命中缓存，即直接从缓存返回结果，不查询数据库</li>
<li>布隆过滤器做前置过滤。<ul>
<li>布隆过滤器是一种概率型数据库结构，由一个很长的二进制向量和一系列随机映射函数组 成。它的原理是，当一个元素被加入集合时，通过 k 个散列函数将这个元素映射成一个 m 位 bit 数组中的 k 个点，并置为 1</li>
<li>检索时，我们只要看看这些点是不是都是 1 就(大概)知道集合中有没有它了。<strong>如果这些 点有任何一个 0，则被检元素一定不在</strong>;如果都是 1，则被检元素很可能在。</li>
<li>布隆过滤器不保存原始值，空间效率很高，平均每一个元素占用 2.4 字节就可以达到万分 之一的误判率。这里的误判率是指，过滤器判断值存在而实际并不存在的概率。我们可以设 置布隆过滤器使用更大的存储空间，来得到更小的误判率。</li>
</ul>
</li>
</ol>
</li>
<li>对于方案二，我们需要同步所有可能存在的值并加入布隆过滤器，这是比较麻烦的地方。如 果业务规则明确的话，你也可以考虑直接根据业务规则判断值是否存在。</li>
<li>其实，方案二可以和方案一同时使用，即将布隆过滤器前置，对于误判的情况再保存特殊值 到缓存，双重保险避免无效数据查询请求打到数据库。</li>
</ul>
<h2 id="注意缓存数据同步策略"><a href="#注意缓存数据同步策略" class="headerlink" title="注意缓存数据同步策略"></a>注意缓存数据同步策略</h2><ul>
<li>前面提到的 3 个案例，其实都属于缓存数据过期后的被动删除。在实际情况下，修改了原 始数据后，考虑到缓存数据更新的及时性，我们可能会采用主动更新缓存的策略。这些策略 可能是:<ol>
<li>先更新缓存，再更新数据库;</li>
<li>先更新数据库，再更新缓存;</li>
<li>先删除缓存，再更新数据库，访问的时候按需加载数据到缓存。</li>
<li><strong>先更新数据库，再删除缓存，访问的时候按需加载数据到缓存。（最佳实践）</strong></li>
</ol>
</li>
<li>“先更新缓存再更新数据库”策略不可行。数据库设计复杂，压力集中，数据库因为超时等 原因更新操作失败的可能性较大，此外还会涉及事务，很可能因为数据库更新失败，导致缓 存和数据库的数据不一致。</li>
<li>“先更新数据库再更新缓存”策略不可行。一是，如果线程 A 和 B 先后完成数据库更新， 但更新缓存时却是 B 和 A 的顺序，那很可能会把旧数据更新到缓存中引起数据不一致;二 是，我们不确定缓存中的数据是否会被访问，不一定要把所有数据都更新到缓存中去。</li>
<li>“先删除缓存再更新数据库，访问的时候按需加载数据到缓存”策略也不可行。在并发的情 况下，很可能删除缓存后还没来得及更新数据库，就有另一个线程先读取了旧值到缓存中， 如果并发量很大的话这个概率也会很大。</li>
<li><strong>“先更新数据库再删除缓存，访问的时候按需加载数据到缓存”策略是最好的</strong>。虽然在极端 情况下，这种策略也可能出现数据不一致的问题，但概率非常低，基本可以忽略。举一 个“极端情况”的例子，比如更新数据的时间节点恰好是缓存失效的瞬间，这时 A 先读取 到了旧值，随后在 B 操作数据库完成更新并且删除了缓存之后，A 再把旧值加入缓存。</li>
<li>需要注意的是，更新数据库后删除缓存的操作可能失败，如果失败则考虑把任务加入延迟队 列进行延迟重试，确保数据可以删除，缓存可以及时更新。因为删除操作是幂等的，所以即 使重复删问题也不是太大，这又是删除比更新好的一个原因。<ul>
<li>因此，针对缓存更新更推荐的方式是，缓存中的数据不由数据更新操作主动触发，统一在需 要使用的时候按需加载，数据更新后及时删除缓存中的数据即可。</li>
</ul>
</li>
</ul>
<h2 id="问题讨论-1"><a href="#问题讨论-1" class="headerlink" title="问题讨论"></a>问题讨论</h2><ol>
<li>在聊到缓存并发问题时，我们说到热点 Key 回源会对数据库产生的压力问题，如果 Key 特别热的话，可能缓存系统也无法承受，毕竟所有的访问都集中打到了一台缓存服务 器。如果我们使用 Redis 来做缓存，那可以把一个热点 Key 的缓存查询压力，分散到多 个 Redis 节点上吗?<ul>
<li>加随机前缀后缀是一个办法</li>
<li>热key：<a href="https://www.infoq.cn/article/3L3zAQ4H8xpNoM2glSyi" target="_blank" rel="noopener">https://www.infoq.cn/article/3L3zAQ4H8xpNoM2glSyi</a></li>
</ul>
</li>
<li>大 Key 也是数据缓存容易出现的一个问题。如果一个 Key 的 Value 特别大，那么可能 会对 Redis 产生巨大的性能影响，因为 Redis 是单线程模型，对大 Key 进行查询或删除 等操作，可能会引起 Redis 阻塞甚至是高可用切换。你知道怎么查询 Redis 中的大 Key，以及如何在设计上实现大 Key 的拆分吗?</li>
<li>布隆过滤器数据量大的问题<ul>
<li><a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">https://krisives.github.io/bloom-calculator/</a> 10亿的数据量，期望千分之一的错误率，推荐10个Hash函数，占用内存空间不到1.8GB</li>
<li></li>
</ul>
</li>
</ol>
<h2 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一，我们不能把诸如 Redis 的缓存数据库完全当作数据库来使用。我们不能假设缓存始 终可靠，也不能假设没有过期的数据必然可以被读取到，需要处理好缓存的回源逻辑;而且 要显式设置 Redis 的最大内存使用和数据淘汰策略，避免出现 OOM 的问题。</li>
<li>第二，缓存的性能比数据库好很多，我们需要考虑大量请求绕过缓存直击数据库造成数据库 瘫痪的各种情况。对于缓存瞬时大面积失效的缓存雪崩问题，可以通过差异化缓存过期时间 解决;对于高并发的缓存 Key 回源问题，可以使用锁来限制回源并发数;对于不存在的数 据穿透缓存的问题，可以通过布隆过滤器进行数据存在性的预判，或在缓存中也设置一个值 来解决。</li>
<li>第三，当数据库中的数据有更新的时候，需要考虑如何确保缓存中数据的一致性。我们看 到，“先更新数据库再删除缓存，访问的时候按需加载数据到缓存”的策略是最为妥当的， 并且要尽量设置合适的缓存过期时间，这样即便真的发生不一致，也可以在缓存过期后数据 得到及时同步。</li>
</ol>
<h1 id="TODO：业务代码写完，就意味着生产就绪了"><a href="#TODO：业务代码写完，就意味着生产就绪了" class="headerlink" title="TODO：业务代码写完，就意味着生产就绪了?"></a><strong>TODO：业务代码写完，就意味着生产就绪了?</strong></h1><ul>
<li>生产就绪需要做哪些工作呢?我认为，以下三方面的工作最重要。<ol>
<li>第一，<strong>提供健康检测接口</strong>。传统采用 ping 的方式对应用进行探活检测并不准确。有的时 候，应用的关键内部或外部依赖已经离线，导致其根本无法正常工作，但其对外的 Web 端 口或管理端口是可以 ping 通的。我们应该提供一个专有的监控检测接口，并尽可能触达一 些内部组件</li>
<li>第二，<strong>暴露应用内部信息</strong>。应用内部诸如线程池、内存队列等组件，往往在应用内部扮演了 重要的角色，如果应用或应用框架可以对外暴露这些重要信息，并加以监控，那么就有可能 在诸如 OOM 等重大问题暴露之前发现蛛丝马迹，避免出现更大的问题。</li>
<li>第三，<strong>建立应用指标 Metrics 监控</strong>。Metrics 可以翻译为度量或者指标，指的是对于一些 关键信息以可聚合的、数值的形式做定期统计，并绘制出各种趋势图表。这里的指标监控， 包括两个方面:一是，应用内部重要组件的指标监控，比如 JVM 的一些指标、接口的 QPS 等;二是，应用的业务数据的监控，比如电商订单量、游戏在线人数等</li>
</ol>
</li>
</ul>
<h2 id="准备工作-配置-Spring-Boot-Actuator"><a href="#准备工作-配置-Spring-Boot-Actuator" class="headerlink" title="准备工作:配置 Spring Boot Actuator"></a><strong>准备工作:配置</strong> <strong>Spring Boot Actuator</strong></h2><h1 id="消息队列-最佳实践"><a href="#消息队列-最佳实践" class="headerlink" title="消息队列-最佳实践"></a>消息队列-最佳实践</h1><ul>
<li>异步处理是互联网应用不可或缺的一种架构模式，大多数业务项目都是由同步处理、异步处 理和定时任务处理三种模式相辅相成实现的。</li>
<li>区别于同步处理，异步处理无需同步等待流程处理完毕，因此适用场景主要包括:<ol>
<li><strong>服务于主流程的分支流程。</strong></li>
<li><strong>用户不需要实时看到结果的流程。</strong></li>
</ol>
</li>
<li>同时，异步处理因为可以有 MQ 中间件的介入用于任务的缓冲的分发，所以相比于同步处 理，在应对流量洪峰、实现模块解耦和消息广播方面有功能优势。MQ中间件虽然好用，但在实现的时候却有三个最容易犯的错，分别是<strong>异步处理流程的 可靠性问题、消息发送模式的区分问题，以及大量死信消息堵塞队列</strong>的问题。使用 Spring AMQP 来操作 RabbitMQ</li>
</ul>
<h2 id="异步处理需要消息补偿闭环"><a href="#异步处理需要消息补偿闭环" class="headerlink" title="异步处理需要消息补偿闭环"></a>异步处理需要消息补偿闭环</h2><ul>
<li><p>使用类似 RabbitMQ、RocketMQ 等 MQ 系统来做消息队列实现异步处理，虽然说消息可 以落地到磁盘保存，即使 MQ 出现问题消息数据也不会丢失，但是异步流程在消息发送、 传输、处理等环节，都可能发生消息丢失。此外，任何 MQ 中间件都无法确保 100% 可 用，需要考虑不可用时异步流程如何继续进行。</p>
<ul>
<li>因此，<strong>对于异步处理流程，必须考虑补偿或者说建立主备双活流程</strong>。</li>
</ul>
</li>
<li><p>栗子场景：用户注册后异步发送欢迎消息的场景。用户注册落数据库的流程为同步流程， 会员服务收到消息后发送欢迎消息的流程为异步流程<img alt="MQ补偿闭环" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggip7vscxtj30ud0fvwgd.jpg" class="lazyload"></p>
<ul>
<li>蓝色的线，使用 MQ 进行的异步处理，我们称作主线，可能存在消息丢失的情况(虚线 代表异步调用);</li>
<li>绿色的线，使用补偿 Job 定期进行消息补偿，我们称作备线，用来补偿主线丢失的消 息;</li>
<li>考虑到极端的 MQ 中间件失效的情况，我们要求备线的处理吞吐能力达到主线的能力水 平。</li>
</ul>
</li>
<li><p>栗子理论分析：</p>
<ul>
<li>消费MQ信息一定要实现幂等，处理逻辑务必考虑去重。<ul>
<li>MQ 消息可能会因为中间件本身配置错误、稳定性等原因出现重复。</li>
<li>自动补偿重复。比如本例，同一条消息可能既走 MQ 也走补偿，肯定会出现重复，而且 考虑到高内聚，补偿 Job 本身不会做去重处理。</li>
<li>人工补偿重复。出现消息堆积时，异步处理流程必然会延迟。如果我们提供了通过后台 进行补偿的功能，那么在处理遇到延迟的时候，很可能会先进行人工补偿，过了一段时 间后处理程序又收到消息了，重复处理。我之前就遇到过一次由 MQ 故障引发的事故， MQ 中堆积了几十万条发放资金的消息，导致业务无法及时处理，运营以为程序出错了 就先通过后台进行了人工处理，结果 MQ 系统恢复后消息又被重复处理了一次，造成大 量资金重复发放。</li>
</ul>
</li>
<li>定义补偿Job，备线操作。为了实现高内聚，主线和备线处理消息，最好使用同一个方法。生产级别补偿job需要完善如下：<ul>
<li>考虑配置补偿的频次、每次处理数量，以及补偿线程池大小等参数为合适的值，以满足 补偿的吞吐量。</li>
<li>考虑备线补偿数据进行适当延迟。比如，对注册时间在 30 秒之前的用户再进行补偿，以 方便和主线 MQ 实时流程错开，避免冲突。</li>
<li>诸如当前补偿到哪个用户的 offset 数据，需要落地数据库。</li>
<li>补偿 Job 本身需要高可用，可以使用类似 XXLJob 或 ElasticJob 等任务系统。</li>
</ul>
</li>
</ul>
</li>
<li><p>栗子源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户注册接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户注册，一次注册10个用户，50%发送MQ失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"register"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            User user = userService.register();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ThreadLocalRandom.current().nextInt(<span class="number">10</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                rabbitTemplate.convertAndSend(RabbitConfiguration.EXCHANGE, RabbitConfiguration.ROUTING_KEY, user);</span><br><span class="line">                log.info(<span class="string">"sent mq user &#123;&#125;"</span>, user.getId());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会员服务：监听（消费）MQ信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Boolean&gt; welcomeStatus = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听MQ信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = RabbitConfiguration.QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive mq user &#123;&#125;"</span>, user.getId());</span><br><span class="line">        welcome(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会员服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不存在的用户，才执行方法里面的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (welcomeStatus.putIfAbsent(user.getId(), <span class="keyword">true</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"memberService: welcome new user &#123;&#125;"</span>, user.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ConcurrentHashMap&#125;不允许key和value为Null</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * putIfAbsent，key存在的话，返回获取到的value值。</span></span><br><span class="line"><span class="comment">     * putIfAbsent，key不存在的话，返回null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPutIfAbsent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Long, Boolean&gt; welcomeStatus = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        welcomeStatus.put(<span class="number">1L</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (welcomeStatus.putIfAbsent(<span class="number">2L</span>, <span class="keyword">true</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"id=2被执行了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (welcomeStatus.putIfAbsent(<span class="number">1L</span>, <span class="keyword">true</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"id=1被执行了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(welcomeStatus.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全量补偿补偿Job</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 生产级别的todo：</span></span><br><span class="line"><span class="comment"> * 1、考虑配置补偿的频次、每次处理数量，以及补偿线程池大小等参数为合适的值，以满足 补偿的吞吐量。</span></span><br><span class="line"><span class="comment"> * 2、考虑备线补偿数据进行适当延迟。比如，对注册时间在 30 秒之前的用户再进行补偿，以 方便和主线 MQ 实时流程错开，避免冲突。</span></span><br><span class="line"><span class="comment"> * 3、诸如当前补偿到哪个用户的 offset 数据，需要落地数据库。</span></span><br><span class="line"><span class="comment"> * 4、补偿 Job 本身需要高可用，可以使用类似 XXLJob 或 ElasticJob 等任务系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensationJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 补偿job异步线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor compensationThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">1</span>, TimeUnit.HOURS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"compensation-threadpool-%d"</span>).get());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目前补偿到哪个用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统启动后10s补偿，每隔5s补偿一次，每次补偿5个用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay = <span class="number">10_000</span>, fixedRate = <span class="number">5_000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compensationJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"开始从用户ID &#123;&#125; 补偿"</span>, offset);</span><br><span class="line"></span><br><span class="line">        userService.getUsersAfterIdWithLimit(offset, <span class="number">5</span>).forEach(user -&gt; &#123;</span><br><span class="line">            compensationThreadPool.execute(() -&gt; memberService.welcome(user));</span><br><span class="line">            offset = user.getId();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="注意消息模式是广播还是工作队列"><a href="#注意消息模式是广播还是工作队列" class="headerlink" title="注意消息模式是广播还是工作队列"></a>注意消息模式是广播还是工作队列</h2><ul>
<li><p>谈谈MQ消息模式两者的区别：广播和队列模式</p>
<ul>
<li>消息广播，和我们平时说的“广播”意思差不多，就是希望同一条消息，不同消费者都能分 别消费;而队列模式，就是不同消费者共享消费同一个队列的数据，相同消息只能被某一个 消费者消费一次。</li>
<li>比如，同一个用户的注册消息，会员服务需要监听以发送欢迎短信，营销服务同样需要监听 以发送新用户小礼物。但是，会员服务、营销服务都可能有多个实例，我们期望的是同一个 用户的消息，可以同时广播给不同的服务(广播模式)，但对于同一个服务的不同实例(比 如会员服务 1 和会员服务 2)，不管哪个实例来处理，处理一次即可(工作队列模式):<img alt="MQ广播和队列模式" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj846pbqhj30wv0hswg3.jpg" class="lazyload"></li>
</ul>
</li>
<li><p>对于类似 Kafka/RocketMQ 这样的 MQ 来说，实现类似功能比较简单直白:如果消费者属于一 个组，那么消息只会由同一个组的一个消费者来消费;如果消费者属于不同组，那么每个组 都能消费一遍消息。</p>
<ul>
<li>而对于 RabbitMQ 来说，消息路由的模式采用的是队列 + 交换器，队列是消息的载体，交 换器决定了消息路由到队列的方式，配置比较复杂，容易出错。所以，接下来我重点和你讲 讲 RabbitMQ 的相关代码实现。<strong>使用RabbitMq实现广播模式和工作队列模式，上图的栗子。</strong></li>
</ul>
</li>
<li><p><strong>第一步，实现会员服务监听用户服务发出的新用户注册消息的那部分逻辑。</strong></p>
<ul>
<li><p>如果我们启动两个会员服务，那么同一个用户的注册消息应该只能被其中一个实例消费。</p>
</li>
<li><p>图解Mq工作队列模式：<img alt="MQ工作队列模式" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglr6i22lpj30ip05gwes.jpg" class="lazyload"></p>
</li>
<li><p>一个服务多个实例，mq工作队列模式代码最佳实践：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rabbitmq实现工作队列模式，一个服务，多个实例，只有一个实例消费MQ信息。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1、为了代码简洁直观，我们把消息发布者、消费者、以及MQ的配置代码都放在了一起.</span></span><br><span class="line"><span class="comment"> * 2、同一个会员服务两个实例都收到了消息：出现这个问题的原因是，我们没有理清楚 RabbitMQ 直接交换器和队列的绑定关系。</span></span><br><span class="line"><span class="comment"> * 3、轮训方式负载均衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"workqueueright"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueueRight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">"newuserExchange"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"newuserQueue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(EXCHANGE, <span class="string">"test"</span>, UUID.randomUUID().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义相同队列名称的队列，两个实例绑定同一个队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明DirectExchange交换器，绑定队列到交换器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Declarables <span class="title">declarables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DirectExchange exchange = <span class="keyword">new</span> DirectExchange(EXCHANGE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Declarables(queue(), exchange,</span><br><span class="line">                BindingBuilder.bind(queue()).to(exchange).with(<span class="string">"test"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mq消息，消费者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"#&#123;queue.name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">memberService</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"memberService: welcome message sent to new user &#123;&#125;"</span>, userName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>第二步，进一步完整实现用户服务需要广播消息给会员服务和营销服务的逻辑。</strong></p>
<ul>
<li><p>我们希望会员服务和营销服务都可以收到广播消息，但会员服务或营销服务中的每个实例只 需要收到一次消息。</p>
</li>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广播模式：代码最佳实践</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"fanoutright"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutQueueRight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MEMBER_QUEUE = <span class="string">"newusermember"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROMOTION_QUEUE = <span class="string">"newuserpromotion"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">"newuser"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(EXCHANGE, <span class="string">""</span>, UUID.randomUUID().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明两个队列绑定到交换器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Declarables <span class="title">declarables</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Queue memberQueue = <span class="keyword">new</span> Queue(MEMBER_QUEUE);</span><br><span class="line">        Queue promotionQueue = <span class="keyword">new</span> Queue(PROMOTION_QUEUE);</span><br><span class="line"></span><br><span class="line">        FanoutExchange exchange = <span class="keyword">new</span> FanoutExchange(EXCHANGE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Declarables(memberQueue, promotionQueue, exchange,</span><br><span class="line">                BindingBuilder.bind(memberQueue).to(exchange),</span><br><span class="line">                BindingBuilder.bind(promotionQueue).to(exchange));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MEMBER_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">memberService1</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"memberService1: welcome message sent to new user &#123;&#125;"</span>, userName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MEMBER_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">memberService2</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"memberService2: welcome message sent to new user &#123;&#125;"</span>, userName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = PROMOTION_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">promotionService1</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"promotionService1: gift sent to new user &#123;&#125;"</span>, userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = PROMOTION_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">promotionService2</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"promotionService2: gift sent to new user &#123;&#125;"</span>, userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="别让死信堵塞了消息队列"><a href="#别让死信堵塞了消息队列" class="headerlink" title="别让死信堵塞了消息队列"></a>别让死信堵塞了消息队列</h2><ul>
<li><p>在定义线程池的时候，如果线程池的任务队列没有上限，那么最终可能会导致 OOM。使用消息队列处理异步流程的时候，我们也同样要注意消息队列的任务堆积问题。 对于突发流量引起的消息队列堆积，问题并不大，适当调整消费者的消费能力应该就可以解 决。<strong>但在很多时候，消息队列的堆积堵塞，是因为有大量始终无法处理的消息</strong>。</p>
</li>
<li><p>比如，用户服务在用户注册后发出一条消息，会员服务监听到消息后给用户派发优惠券，但 因为用户并没有保存成功，会员服务处理消息始终失败，消息重新进入队列，然后还是处理 失败。<strong>这种在 MQ 中像幽灵一样回荡的同一条消息，就是死信</strong>。</p>
<ul>
<li>随着 MQ 被越来越多的死信填满，消费者需要花费大量时间反复处理死信，导致正常消息 的消费受阻，<strong>最终 MQ 可能因为数据量过大而崩溃</strong>。</li>
</ul>
</li>
<li><p>如何解决死信问题，理论分析：</p>
<ul>
<li>解决死信无限重复进入队列最简单的方式是，在程序处理出错的时候，直接抛出 {@link AmqpRejectAndDontRequeueException}异常</li>
<li>对于同一条消息，能够先进行几次重试，解决因为网络问题导致 的偶发消息处理失败，如果还是不行的话，再把消息投递到专门的一个死信队列。对于来自 死信队列的数据，我们可能只是记录日志发送报警，即使出现异常也不会再重复投递。<img alt="MQ处理死信消息" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggj9ma4zqsj30yx0go40f.jpg" class="lazyload"></li>
<li>针对这个问题，Spring AMQP 提供了非常方便的解决方案：<ul>
<li>首先，定义死信交换器和死信队列。其实，这些都是普通的交换器和队列，只不过被我 们专门用于处理死信消息。</li>
<li>然后，通过 RetryInterceptorBuilder 构建一个 RetryOperationsInterceptor，用于处 理失败时候的重试。这里的策略是，最多尝试 5 次(重试 4 次);并且采取指数退避重 试，首次重试延迟 1 秒，第二次 2 秒，以此类推，最大延迟是 10 秒;如果第 4 次重试 还是失败，则使用 RepublishMessageRecoverer 把消息重新投入一个“死信交换 器”中。</li>
<li>最后，定义死信队列的处理程序。这个案例中，我们只是简单记录日志。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何解决死信问题，源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 死信MQ定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@Slf</span>4j</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 快速声明一组对象，包含队列、交换器，以及队列到交换器的绑定</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Declarables <span class="title">declarables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Queue queue = <span class="keyword">new</span> Queue(Consts.QUEUE);</span><br><span class="line">         DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(Consts.EXCHANGE);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Declarables(queue, directExchange,</span><br><span class="line">                 BindingBuilder.bind(queue).to(directExchange).with(Consts.ROUTING_KEY));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 定义死信交换器和队列，并且进行绑定</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Declarables <span class="title">declarablesForDead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Queue queue = <span class="keyword">new</span> Queue(Consts.DEAD_QUEUE);</span><br><span class="line">         DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(Consts.DEAD_EXCHANGE);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Declarables(queue, directExchange,</span><br><span class="line">                 BindingBuilder.bind(queue).to(directExchange).with(Consts.DEAD_ROUTING_KEY));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 定义重试操作拦截器，对于同一条消息，能够先进行几次重试，解决因为网络问题导致 的偶发消息处理失败，如果还是不行的话，再把消息投递到专门的一个死信队列。</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> RetryOperationsInterceptor <span class="title">interceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> RetryInterceptorBuilder.stateless()</span><br><span class="line">                 .maxAttempts(<span class="number">5</span>)</span><br><span class="line">                 .backOffOptions(<span class="number">1000</span>, <span class="number">2.0</span>, <span class="number">10000</span>)</span><br><span class="line">                 .recoverer(<span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate, Consts.DEAD_EXCHANGE, Consts.DEAD_ROUTING_KEY))</span><br><span class="line">                 .build();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 通过定义SimpleRabbitListenerContainerFactory，设置其adviceChain属性为之前定义的RetryOperationsInterceptor</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * 默认情况下 SimpleMessageListenerContainer 只有一个消费线程。只有等msg1消费完成之后，msg2才开始消费</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">         SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">         factory.setConnectionFactory(connectionFactory);</span><br><span class="line">         factory.setAdviceChain(interceptor());</span><br><span class="line">         factory.setConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">         <span class="keyword">return</span> factory;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * MQ消息消费者</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Component</span></span><br><span class="line"> <span class="meta">@Slf</span>4j</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 模拟MQ消费信息出现异常的情况：</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * 解决方案1：解决死信无限重复进入队列最简单的方式是，在程序处理出错的时候，直接抛出 &#123;<span class="doctag">@link</span> AmqpRejectAndDontRequeueException&#125;异常</span></span><br><span class="line"><span class="comment">      * 解决方案2：对于同一条消息，能够先进行几次重试，解决因为网络问题导致 的偶发消息处理失败，如果还是不行的话，再把消息投递到专门的一个死信队列。</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@RabbitListener</span>(queues = Consts.QUEUE)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//http://localhost:15672/#/</span></span><br><span class="line">         log.info(<span class="string">"got message &#123;&#125;"</span>, data);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"error"</span>);</span><br><span class="line">         <span class="comment">//throw new AmqpRejectAndDontRequeueException("error");</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 死信队列处理程序</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@RabbitListener</span>(queues = Consts.DEAD_QUEUE)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deadHandler</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">         log.error(<span class="string">"got dead message &#123;&#125;"</span>, data);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="问题讨论-2"><a href="#问题讨论-2" class="headerlink" title="问题讨论"></a>问题讨论</h2><ol>
<li>在用户注册后发送消息到 MQ，然后会员服务监听消息进行异步处理的场景下，有些时 候我们会发现，虽然用户服务先保存数据再发送 MQ，但会员服务收到消息后去查询数 据库，却发现数据库中还没有新用户的信息。你觉得，这可能是什么问题呢，又该如何 解决呢?<ul>
<li>思考题一是我真实遇到的问题，当时倒不是因为主从的问题，而是因为业务代码把保存数据和发 MQ消息放在了一个事务中，有概率收到消息的时候事务还没有提交完成，当时开发同学的处理方 式是收MQ消息的时候sleep 1秒，或许应该是先提交事务，完成后再发MQ消息，但是这又出来 一个问题MQ消息发送失败怎么办?所以后来演化为建立本地消息表来确保MQ消息可补偿，把业 务处理和保存MQ消息到本地消息表操作在相同事务内处理，然后异步发送和补偿发送消息表中的 消息到MQ</li>
</ul>
</li>
<li>除了使用 Spring AMQP 实现死信消息的重投递外，RabbitMQ 2.8.0 后支持的死信交 换器 DLX 也可以实现类似功能。你能尝试用 DLX 实现吗，并比较下这两种处理机制?</li>
</ol>
<h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><ol>
<li>第一，要考虑异步流程丢消息或处理中断的情况，异步流程需要有备线进行补偿。比如，我 们今天介绍的全量补偿方式，即便异步流程彻底失效，通过补偿也能让业务继续进行。</li>
<li>第二，异步处理的时候需要考虑消息重复的可能性，处理逻辑需要实现幂等，防止重复处 理。</li>
<li>第三，微服务场景下不同服务多个实例监听消息的情况，一般不同服务需要同时收到相同的 消息，而相同服务的多个实例只需要轮询接收消息。我们需要确认 MQ 的消息路由配置是 否满足需求，以避免消息重复或漏发问题。</li>
<li>第四，要注意始终无法处理的死信消息，可能会引发堵塞 MQ 的问题。一般在遇到消息处 理失败的时候，我们可以设置一定的重试策略。如果重试还是不行，那可以把这个消息扔到 专有的死信队列特别处理，不要让死信影响到正常消息的处理。</li>
</ol>
<h1 id="TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？"><a href="#TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？" class="headerlink" title="TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？"></a>TODO：数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</h1><h1 id="数据源头-任何客户端的东西都不可信任"><a href="#数据源头-任何客户端的东西都不可信任" class="headerlink" title="数据源头:任何客户端的东西都不可信任"></a><strong>数据源头:任何客户端的东西都不可信任</strong></h1><ul>
<li>对于 HTTP 请求，我们要在脑子里有一个根深蒂固的概念，那就是<strong>任何客户端传过来的数 据都是不能直接信任的</strong>。客户端传给服务端的数据只是信息收集，数据需要经过有效性验 证、权限验证等后才能使用，并且这些数据只能认为是用户操作的意图，不能直接代表数据 当前的状态。</li>
</ul>
<h2 id="客户端的计算不可信"><a href="#客户端的计算不可信" class="headerlink" title="客户端的计算不可信"></a>客户端的计算不可信</h2><ul>
<li><p>栗子场景：客户端下单，可能会暴露这么一个 /order 的 POST 接口给客户端，让客户端直接把组装 后的订单信息 Order 传给服务端。订单信息 Order 可能包括商品 ID、商品价格、数量、商品总价</p>
</li>
<li><p>虽然用户下单时客户端肯定有商品的价格等信息，也会计算出订单的总价给用户确认，但是 这些信息只能用于呈现和核对。即使客户端传给服务端的 POJO 中包含了这些信息，服务 端也一定要重新从数据库来初始化商品的价格，重新计算最终的订单价格。<strong>如果不这么做的 话，很可能会被黑客利用，商品总价被恶意修改为比较低的价格。</strong></p>
</li>
<li><p>因此，我们真正直接使用的、可信赖的只是客户端传过来的商品 ID 和数量，服务端会根据 这些信息重新计算最终的总价。如果服务端计算出来的商品价格和客户端传过来的价格不匹 配的话，可以给客户端友好提示，让用户重新下单。</p>
</li>
<li><p>还有一种可行的做法是，让客户端仅传入需要的数据给服务端，像这样重新定义一个 POJO CreateOrderRequest 作为接口入参，比直接使用领域模型 Order 更合理。在设计接口 时，我们会思考哪些数据需要客户端提供，而不是把一个大而全的对象作为参数提供给服务 端，以避免因为忘记在服务端重置客户端数据而导致的安全问题。</p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 错误实现：完全使用客户端的传递过来数据（不安全）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">(@RequestBody Order order)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.createOrder(order);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 正确实现：服务器校验客户端传递过来的参数，服务器计算价格</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/orderRight"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(@RequestBody Order order)</span> </span>&#123;</span><br><span class="line">       Item item = Db.getItem(order.getItemId());</span><br><span class="line">       <span class="keyword">if</span> (!order.getItemPrice().equals(item.getItemPrice())) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您选购的商品价格有变化，请重新下单"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       order.setItemPrice(item.getItemPrice());</span><br><span class="line">       BigDecimal totalPrice = item.getItemPrice().multiply(BigDecimal.valueOf(order.getQuantity()));</span><br><span class="line">       <span class="keyword">if</span> (order.getItemTotalPrice().compareTo(totalPrice) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您选购的商品总价有变化，请重新下单"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       order.setItemTotalPrice(totalPrice);</span><br><span class="line">       createOrder(order);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 正确实现：客户端只传递需要的参数，而不是传入一个大而全的参数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> createOrderRequest</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"orderRight2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Order <span class="title">right2</span><span class="params">(@RequestBody CreateOrderRequest createOrderRequest)</span> </span>&#123;</span><br><span class="line">       Item item = Db.getItem(createOrderRequest.getItemId());</span><br><span class="line">       Order order = <span class="keyword">new</span> Order();</span><br><span class="line">       order.setItemPrice(item.getItemPrice());</span><br><span class="line">       order.setItemTotalPrice(item.getItemPrice().multiply(BigDecimal.valueOf(order.getQuantity())));</span><br><span class="line">       createOrder(order);</span><br><span class="line">       <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过这个案例我们可以看到，在处理客户端提交过来的数据时，服务端需要明确区分，哪些 数据是需要客户端提供的，哪些数据是客户端从服务端获取后在客户端计算的。其中，前者 可以信任;而后者不可信任，服务端需要重新计算，如果客户端和服务端计算结果不一致的 话，可以给予友好提示。</p>
</li>
</ul>
<h2 id="客户端提交的参数需要校验"><a href="#客户端提交的参数需要校验" class="headerlink" title="客户端提交的参数需要校验"></a><strong>客户端提交的参数需要校验</strong></h2><ul>
<li><p>对于客户端的数据，我们还容易忽略的一点是，<strong>误以为客户端的数据来源是服务端，客户端就不可能提交异常数据。</strong></p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下发给客户端的数据</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> modelMap</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">      List&lt;Country&gt; countries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      countries.addAll(allCountries.values().stream().filter(country -&gt; country.getId() &lt; <span class="number">4</span>).collect(Collectors.toList()));</span><br><span class="line">      modelMap.addAttribute(<span class="string">"countries"</span>, countries);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 错误的接口定义，不对客户端传递过来的数据校验</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> countryId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/wrong"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">wrong</span><span class="params">(@RequestParam(<span class="string">"countryId"</span>)</span> <span class="keyword">int</span> countryId) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> allCountries.get(countryId).getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 正确实现校验数据</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> countryId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/right"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">right</span><span class="params">(@RequestParam(<span class="string">"countryId"</span>)</span> <span class="keyword">int</span> countryId) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (countryId &lt; <span class="number">1</span> || countryId &gt; <span class="number">3</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非法参数"</span>);</span><br><span class="line">      <span class="keyword">return</span> allCountries.get(countryId).getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用spring来做参数校验</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> countryId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/better"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">better</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          @RequestParam(<span class="string">"countryId"</span>)</span></span></span><br><span class="line"><span class="function">          @<span class="title">Min</span><span class="params">(value = <span class="number">1</span>, message = <span class="string">"非法参数"</span>)</span></span></span><br><span class="line"><span class="function">          @<span class="title">Max</span><span class="params">(value = <span class="number">3</span>, message = <span class="string">"非法参数"</span>)</span> <span class="keyword">int</span> countryId) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> allCountries.get(countryId).getName();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="不能信任请求头里的任何内容"><a href="#不能信任请求头里的任何内容" class="headerlink" title="不能信任请求头里的任何内容"></a>不能信任请求头里的任何内容</h2><ul>
<li><p>栗子场景：一个比较常见的需求是，为了防刷，我们需要判断用户的唯一性。比如，针对未注册的新用 户发送一些小奖品，我们不希望相同用户多次获得奖品。考虑到未注册的用户因为没有登录 过所以没有用户标识，我们可能会想到根据请求的 IP 地址，来判断用户是否已经领过奖 品。</p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; activityLimit = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 错误实现</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      String ip = getClientIp(request);</span><br><span class="line">      <span class="keyword">if</span> (activityLimit.contains(ip)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"您已经领取过奖品"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          activityLimit.add(ip);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"奖品领取成功"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * IP 地址的获取方式是:优先通过 X-Forwarded- For 请求头来获取，如果没有的话再通过 HttpServletRequest 的 getRemoteAddr 方法来 获取。</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * 之所以这么做是因为，通常我们的应用之前都部署了反向代理或负载均衡器，remoteAddr 获得的只能是代理的 IP 地址，</span></span><br><span class="line"><span class="comment">   * 而不是访问用户实际的 IP。这不符合我们的需求，因为反向 代理在转发请求时，通常会把用户真实 IP 放入 X-Forwarded-For 这个请求头中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getClientIp</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      String xff = request.getHeader(<span class="string">"X-Forwarded-For"</span>);</span><br><span class="line">      <span class="keyword">if</span> (xff == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> request.getRemoteAddr();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> xff.contains(<span class="string">","</span>) ? xff.split(<span class="string">","</span>)[<span class="number">0</span>] : xff;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>这种过于依赖 X-Forwarded-For 请求头来判断用户唯一性的实现方式，是有问题的</strong>：</p>
<ol>
<li>通过curl模拟请求来设置头部信息</li>
<li>网吧、学校等机构的出口 IP 往往是同一个，在这个场景下，可能只有最先打开这个页面 的用户才能领取到奖品，而其他用户会被阻拦。</li>
</ol>
</li>
<li><p>因此，IP 地址或者说请求头里的任何信息，包括 Cookie 中的信息、Referer，只能用作参 考，不能用作重要逻辑判断的依据。而对于类似这个案例唯一性的判断需求，更好的做法 是，让用户进行登录或三方授权登录(比如微信)，拿到用户标识来做唯一性判断。</p>
</li>
</ul>
<h2 id="用户标识不能从客户端获取"><a href="#用户标识不能从客户端获取" class="headerlink" title="用户标识不能从客户端获取"></a>用户标识不能从客户端获取</h2><ul>
<li><p>常见出错场景：</p>
<ol>
<li>开发同学没有正确认识接口或服务面向的用户。如果接口面向内部服务，由服务调用方 传入用户 ID 没什么不合理，但是这样的接口不能直接开放给客户端或 H5 使用。</li>
<li>在测试阶段为了方便测试调试，我们通常会实现一些无需登录即可使用的接口，直接使 用客户端传过来的用户标识，却在上线之前忘记删除类似的超级接口。</li>
<li>一个大型网站前端可能由不同的模块构成，不一定是一个系统，而用户登录状态可能也 没有打通。有些时候，我们图简单可能会在 URL 中直接传用户 ID，以实现通过前端传 值来打通用户登录状态。</li>
</ol>
</li>
<li><p>如果你的接口直面用户(比如给客户端或 H5 页面调用)，那么一定需要用户先登录才能使 用。登录后用户标识保存在服务端，接口需要从服务端(比如 Session 中)获取。这里有 段代码演示了一个最简单的登录操作，登录后在 Session 中设置了当前用户的标识。</p>
</li>
<li><p>分享一个spring web要登录了才能访问的权限：注解+HandlerMethodArgumentResolver接口+WebMvcConfigurer接口。</p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标识接口，需要登录了才能访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> codingprh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">    <span class="function">String <span class="title">sessionKey</span><span class="params">()</span> <span class="keyword">default</span> "currentUser"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HandlerMethodArgumentResolver,请求参数解析接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequiredArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析哪些参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匹配参数上具有@LoginRequired注解的参数</span></span><br><span class="line">        <span class="keyword">return</span> methodParameter.hasParameterAnnotation(LoginRequired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndViewContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nativeWebRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webDataBinderFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从参数上获得注解</span></span><br><span class="line">        LoginRequired loginRequired = methodParameter.getParameterAnnotation(LoginRequired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据注解中的Session Key，从Session中查询用户信息</span></span><br><span class="line">        Object object = nativeWebRequest.getAttribute(loginRequired.sessionKey(), NativeWebRequest.SCOPE_SESSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"接口 &#123;&#125; 非法调用！"</span>, methodParameter.getMethod().toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先登录！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoahApplication</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往webmvc中增加自定义处理参数解析器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resolvers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> LoginRequiredArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">right</span><span class="params">(@LoginRequired Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"当前用户Id："</span> + userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password, HttpSession session) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (username.equals(<span class="string">"admin"</span>) &amp;&amp; password.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">        session.setAttribute(<span class="string">"currentUser"</span>, <span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="回顾总结-1"><a href="#回顾总结-1" class="headerlink" title="回顾总结"></a>回顾总结</h2><ol>
<li>客户端的计算不可信。虽然目前很多项目的前端都是富前端，会做大量的逻辑计算， 无需访问服务端接口就可以顺畅完成各种功能，但来自客户端的计算结果不能直接信任。最 终在进行业务操作时，客户端只能扮演信息收集的角色，虽然可以将诸如价格等信息传给服 务端，但只能用于校对比较，最终要以服务端的计算结果为准。</li>
<li>所有来自客户端的参数都需要校验判断合法性。即使我们知道用户是在一个下拉列表 选择数据，即使我们知道用户通过网页正常操作不可能提交不合法的值，服务端也应该进行 参数校验，防止非法用户绕过浏览器 UI 页面通过工具直接向服务端提交参数。</li>
<li>除了请求 Body 中的信息，请求头里的任何信息同样不能信任。我们要知道，来自 请求头的 IP、Referer 和 Cookie 都有被篡改的可能性，相关数据只能用来参考和记录，不 能用作重要业务逻辑。</li>
<li>如果接口面向外部用户，那么一定不能出现用户标识这样的参数，当前用户的标识一 定来自服务端，只有经过身份认证后的用户才会在服务端留下标识。如果你的接口现在面向 内部其他服务，那么也要千万小心这样的接口只能内部使用，还可能需要进一步考虑服务端 调用方的授权问题。</li>
</ol>
<h1 id="如何正确保存和传输敏感数据"><a href="#如何正确保存和传输敏感数据" class="headerlink" title="如何正确保存和传输敏感数据?"></a><strong>如何正确保存和传输敏感数据?</strong></h1><ul>
<li>今天，我们从安全角度来聊聊用户名、密码、身份证等敏感信息，应该怎么保存和传输。同 时，你还可以进一步复习加密算法中的散列、对称加密和非对称加密算法，以及 HTTPS 等 相关知识。</li>
</ul>
<h2 id="应该怎样保存用户密码"><a href="#应该怎样保存用户密码" class="headerlink" title="应该怎样保存用户密码?"></a><strong>应该怎样保存用户密码?</strong></h2><ul>
<li><p>最敏感的数据恐怕就是用户的密码了。黑客一旦窃取了用户密码，或许就可以登录进用户的 账号，消耗其资产、发布不良信息等;更可怕的是，有些用户至始至终都是使用一套密码， 密码一旦泄露，就可以被黑客用来登录全网。为了防止密码泄露，最重要的原则是不要保存用户密码。你可能会觉得很好笑，不保存用户 密码，之后用户登录的时候怎么验证?其实，我指的是<strong>不保存原始密码，这样即使拖库也不 会泄露用户密码。</strong></p>
</li>
<li><p>我经常会听到大家说，不要明文保存用户密码，应该把密码通过 MD5 加密后保存。这的确 是一个正确的方向，但这个说法并不准确。</p>
<ul>
<li>首先，MD5 其实不是真正的加密算法。<strong>所谓加密算法</strong>，是可以使用密钥把明文加密为密 文，随后还可以使用密钥解密出明文，是双向的。</li>
<li>而 MD5 是散列、哈希算法或者摘要算法。不管多长的数据，使用 MD5 运算后得到的都是 固定长度的摘要信息或指纹信息，无法再解密为原始数据。所以，MD5 是单向的。<strong>最重要 的是，仅仅使用 MD5 对密码进行摘要，并不安全</strong>。</li>
<li>大多数MD5破解网站都是使用<strong>彩虹表</strong>：是一种使用时间空间平衡的技术，即可以使用 更大的空间来降低破解时间，也可以使用更长的破解时间来换取更小的空间。把所有20位内数字和字母组合的密码MD5之后存进去。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>此外，你可能会觉得多次 MD5 比较安全，其实并不是这样</strong>。一样秒破解。所以直接保存 MD5 后的密码是不安全的。一些开发可能会说，还需要加盐。是的，但是加 盐如果不当，还是非常不安全，比较重要的有两点。</p>
<ul>
<li>第一，<strong>不能在代码中写死盐，且盐需要有一定的长度</strong>。</li>
<li>其实，知道盐是什么没什么关系，关键的是我们是在代码里写死了盐，并且盐很短、所有用 户都是这个盐。这么做有三个问题：<ul>
<li>因为盐太短、太简单了，如果用户原始密码也很简单，那么整个拼起来的密码也很短， 这样一般的 MD5 破解网站都可以直接解密这个 MD5，除去盐就知道原始密码了。</li>
<li>相同的盐，意味着使用相同密码的用户 MD5 值是一样的，知道了一个用户的密码就可 能知道了多个。</li>
<li>我们也可以使用这个盐来构建一张彩虹表，虽然会花不少代价，但是一旦构建完成，所 有人的密码都可以被破解。</li>
<li><strong>所以，最好是每一个密码都有独立的盐，并且盐要长一点，比如超过 20 位</strong>。</li>
</ul>
</li>
<li>第二，<strong>虽然说每个人的盐最好不同，但我也不建议将一部分用户数据作为盐。</strong>比如，使用用户名作为盐<ul>
<li><strong>所以，盐最好是随机的值，并且是全球唯一的，意味着全球不可能有现成的彩虹表给你用。</strong></li>
<li>正确的做法是，使用全球唯一的、和用户无关的、足够长的随机值作为盐。比如，可以使用 UUID 作为盐，把盐一起保存到数据库中。</li>
<li>并且每次用户修改密码的时候都重新计算盐，重新保存新的密码。你可能会问，盐保存在数 据库中，那被拖库了不是就可以看到了吗?难道不应该加密保存吗?</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>在我看来，盐没有必要加密保存。盐的作用是，防止通过彩虹表快速实现密码“解密”，如 果用户的盐都是唯一的，那么生成一次彩虹表只可能拿到一个用户的密码，这样黑客的动力 会小很多。</p>
</li>
<li><p>MD5最佳实践源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误实现：无盐的md5加密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserData <span class="title">wrong1</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"noah"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"Abcd1234"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UserData userData = <span class="keyword">new</span> UserData();</span><br><span class="line">    userData.setId(<span class="number">1L</span>);</span><br><span class="line">    userData.setName(name);</span><br><span class="line">    userData.setPassword(DigestUtils.md5Hex(password));</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(userData);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误实现：盐值不够长度和随机</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserData <span class="title">wrong2</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"noah"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"Abcd1234"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UserData userData = <span class="keyword">new</span> UserData();</span><br><span class="line">    userData.setId(<span class="number">1L</span>);</span><br><span class="line">    userData.setName(name);</span><br><span class="line">    userData.setPassword(DigestUtils.md5Hex(<span class="string">"salt"</span> + password));</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(userData);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误实现：盐值跟用户名相关，有专门的彩虹表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserData <span class="title">wrong3</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"noah"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"Abcd1234"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UserData userData = <span class="keyword">new</span> UserData();</span><br><span class="line">    userData.setId(<span class="number">1L</span>);</span><br><span class="line">    userData.setName(name);</span><br><span class="line">    userData.setPassword(DigestUtils.md5Hex(name + password));</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(userData);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误实现：两次的md5加密也秒破解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong4"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserData <span class="title">wrong4</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"noah"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"Abcd1234"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UserData userData = <span class="keyword">new</span> UserData();</span><br><span class="line">    userData.setId(<span class="number">1L</span>);</span><br><span class="line">    userData.setName(name);</span><br><span class="line">    userData.setPassword(DigestUtils.md5Hex(DigestUtils.md5Hex(password)));</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(userData);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最佳实践：盐值要随机、并且长度要超过20位，每个用户单独一个盐值：可明文存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserData <span class="title">right</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"noah"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"Abcd1234"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UserData userData = <span class="keyword">new</span> UserData();</span><br><span class="line">    userData.setId(<span class="number">1L</span>);</span><br><span class="line">    userData.setName(name);</span><br><span class="line">    userData.setSalt(UUID.randomUUID().toString());</span><br><span class="line">    userData.setPassword(DigestUtils.md5Hex(userData.getSalt() + password));</span><br><span class="line">    <span class="keyword">return</span> userRepository.save(userData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更好的做法是，不要使用像 MD5 这样快速的摘要算法，而是使用慢一点的算法</strong>。比如 Spring Security 已经废弃了 MessageDigestPasswordEncoder，推荐使用 BCryptPasswordEncoder，也就是BCrypt来进行密码哈希。BCrypt 是为保存密码设计 的算法，相比 MD5 要慢很多。</p>
<ul>
<li>如果制作 8 位密码长度的 MD5 彩虹表需要 5 个月，那么对于 BCrypt 来说， 可能就需要几十年，大部分黑客应该都没有这个耐心。</li>
<li>我们写一段代码观察下，BCryptPasswordEncoder 生成的密码哈希的三个规律:<ul>
<li>第一，我们调用 encode、matches 方法进行哈希、做密码比对的时候，不需要传入盐。<strong>BCrypt 把盐作为了算法的一部分，强制我们遵循安全保存密码的最佳实践。</strong></li>
<li>第二，生成的盐和哈希后的密码拼在了一起:$是字段分隔符，其中第一个$后的 2a 代表算 法版本，第二个$后的 10 是代价因子(默认是 10，代表 2 的 10 次方次哈希)，第三个 $后的 22 个字符是盐，再后面是摘要。所以说，我们不需要使用单独的数据库字段来保存 盐。（<code>$&lt;ver&gt;$&lt;cost&gt;$&lt;salt&gt;&lt;digest&gt;</code>）</li>
<li>第三，代价因子的值越大，BCrypt 哈希的耗时越久。因此，对于代价因子的值，更建议的 实践是，根据用户的忍耐程度和硬件，设置一个尽可能大的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>最后，我们需要注意的是，虽然黑客已经很难通过彩虹表来破解密码了，但是仍然有可能暴 力破解密码，也就是对于同一个用户名使用常见的密码逐一尝试登录。因此，除了做好密码 哈希保存的工作外，我们还要建设一套完善的安全防御机制，在感知到暴力破解危害的时 候，开启短信验证、图形验证码、账号暂时锁定等防御机制来抵御暴力破解。</p>
</li>
</ul>
<h2 id="应该怎么保存姓名和身份证"><a href="#应该怎么保存姓名和身份证" class="headerlink" title="应该怎么保存姓名和身份证?"></a>应该怎么保存姓名和身份证?</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/29/2020-06-29-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91%EF%BC%88%E7%BB%AD%EF%BC%89/">http://yoursite.com/2020/06/29/2020-06-29-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91%EF%BC%88%E7%BB%AD%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/">Noah最佳实践与踩坑    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzunylo84j31fy0pkapz.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/27/2020-06-27-Spring%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzuejjopyj31ff0q7799.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>SpringFramework5.2.0源码阅读</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/12/2020-04-12-Noah最佳实践与踩坑/" title="Noah最佳实践与踩坑"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzunylo84j31fy0pkapz.jpg"><div class="relatedPosts_title">Noah最佳实践与踩坑</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>