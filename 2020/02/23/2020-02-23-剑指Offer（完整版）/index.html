<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>剑指Offer（完整版） | Noah</title><meta name="description" content="剑指Offer（完整版）"><meta name="keywords" content="offer"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="剑指Offer（完整版）"><meta name="twitter:description" content="剑指Offer（完整版）"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx22jv93j318k0p03zl.jpg"><meta property="og:type" content="article"><meta property="og:title" content="剑指Offer（完整版）"><meta property="og:url" content="http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="剑指Offer（完整版）"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx22jv93j318k0p03zl.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><link rel="prev" title="Noah最佳实践与踩坑" href="http://yoursite.com/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/"><link rel="next" title="《数据结构与算法》-算法篇" href="http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#剑指Offer"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">剑指Offer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#总览"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">总览</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java底层知识：JVM"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Java底层知识：JVM</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题一：谈谈你对Java的理解？"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">问题一：谈谈你对Java的理解？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题二：Compile-One-Run-AnyWhere（平台无关性）如何实现？"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">问题二：Compile One,Run AnyWhere（平台无关性）如何实现？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题三：JVM如何加载-class文件？"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">问题三：JVM如何加载.class文件？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题四：谈谈Java反射"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">问题四：谈谈Java反射</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题五：类从编译到执行的过程"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">问题五：类从编译到执行的过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题六：谈谈ClassLoader"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">问题六：谈谈ClassLoader</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题七：谈谈类加载器的双亲委派机制"><span class="toc_mobile_items-number">3.7.</span> <span class="toc_mobile_items-text">问题七：谈谈类加载器的双亲委派机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题八：谈谈类的加载方式"><span class="toc_mobile_items-number">3.8.</span> <span class="toc_mobile_items-text">问题八：谈谈类的加载方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类的装载过程"><span class="toc_mobile_items-number">3.8.1.</span> <span class="toc_mobile_items-text">类的装载过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LoadClass和forName的区别"><span class="toc_mobile_items-number">3.8.2.</span> <span class="toc_mobile_items-text">LoadClass和forName的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题九：Java内存空间结构模型"><span class="toc_mobile_items-number">3.9.</span> <span class="toc_mobile_items-text">问题九：Java内存空间结构模型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程角度"><span class="toc_mobile_items-number">3.9.1.</span> <span class="toc_mobile_items-text">线程角度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#存储角度"><span class="toc_mobile_items-number">3.9.2.</span> <span class="toc_mobile_items-text">存储角度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#程序计数器（Program-Counter-Register）"><span class="toc_mobile_items-number">3.9.3.</span> <span class="toc_mobile_items-text">程序计数器（Program Counter Register）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java虚拟机栈（Stack）"><span class="toc_mobile_items-number">3.9.4.</span> <span class="toc_mobile_items-text">Java虚拟机栈（Stack）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十五：不同jdk版本之间的intern-方法的区别-JDK6-vs-JDK6"><span class="toc_mobile_items-number">3.10.</span> <span class="toc_mobile_items-text">问题十五：不同jdk版本之间的intern()方法的区别-JDK6 vs JDK6+</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java多线程与并发"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Java多线程与并发</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题一：进程和线程的区别？"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">问题一：进程和线程的区别？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题二：Java进程和线程的关系"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">问题二：Java进程和线程的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题三：Thread中的start和run方法的区别？"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">问题三：Thread中的start和run方法的区别？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题四：Thread和Runnable是什么关系？"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">问题四：Thread和Runnable是什么关系？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题五：如何给run-方法传参？"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">问题五：如何给run()方法传参？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题六：如何实现处理线程的返回值"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">问题六：如何实现处理线程的返回值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题七：线程的状态"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">问题七：线程的状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题八：sleep和wait的区别？"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">问题八：sleep和wait的区别？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题九：notify和notifyAll的区别"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">问题九：notify和notifyAll的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十：谈谈你对java-lang-Thread-yield的理解"><span class="toc_mobile_items-number">4.10.</span> <span class="toc_mobile_items-text">问题十：谈谈你对java.lang.Thread#yield的理解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十一：如何中断线程"><span class="toc_mobile_items-number">4.11.</span> <span class="toc_mobile_items-text">问题十一：如何中断线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十二：线程状态以及线程状态的切换"><span class="toc_mobile_items-number">4.12.</span> <span class="toc_mobile_items-text">问题十二：线程状态以及线程状态的切换</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java多线程与并发-原理"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Java多线程与并发-原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题一：谈谈什么不是线程安全的？"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">问题一：谈谈什么不是线程安全的？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题二：谈谈synchronized底层实现原理"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">问题二：谈谈synchronized底层实现原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是重入？"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">什么是重入？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#谈谈synchronized优化？"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">谈谈synchronized优化？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题三：自旋锁和自适应自旋锁"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">问题三：自旋锁和自适应自旋锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题四：锁消除和锁粗化"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">问题四：锁消除和锁粗化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题五：synchronized的四种状态"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">问题五：synchronized的四种状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题六：synchronized和ReentrantLock的区别？"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">问题六：synchronized和ReentrantLock的区别？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题七：sun-misc-Unsafe的理解"><span class="toc_mobile_items-number">5.7.</span> <span class="toc_mobile_items-text">问题七：sun.misc.Unsafe的理解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题八：什么是Java内存模型中的happens-before"><span class="toc_mobile_items-number">5.8.</span> <span class="toc_mobile_items-text">问题八：什么是Java内存模型中的happens-before</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题九：JMM如何解决可见性问题"><span class="toc_mobile_items-number">5.9.</span> <span class="toc_mobile_items-text">问题九：JMM如何解决可见性问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#利用happens-before规则判方法是否是线程安全的？"><span class="toc_mobile_items-number">5.9.1.</span> <span class="toc_mobile_items-text">利用happens-before规则判方法是否是线程安全的？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十：谈谈Volatile的认识"><span class="toc_mobile_items-number">5.10.</span> <span class="toc_mobile_items-text">问题十：谈谈Volatile的认识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单例双重锁检测实现"><span class="toc_mobile_items-number">5.10.1.</span> <span class="toc_mobile_items-text">单例双重锁检测实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十一：volatile和synchronized的区别"><span class="toc_mobile_items-number">5.11.</span> <span class="toc_mobile_items-text">问题十一：volatile和synchronized的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十二：谈谈CAS"><span class="toc_mobile_items-number">5.12.</span> <span class="toc_mobile_items-text">问题十二：谈谈CAS</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#i-操作的字节码"><span class="toc_mobile_items-number">5.12.1.</span> <span class="toc_mobile_items-text">i++操作的字节码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题十三：谈谈线程池"><span class="toc_mobile_items-number">5.13.</span> <span class="toc_mobile_items-text">问题十三：谈谈线程池</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程池新任务提交execute执行后的流程"><span class="toc_mobile_items-number">5.13.1.</span> <span class="toc_mobile_items-text">线程池新任务提交execute执行后的流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程池的状态"><span class="toc_mobile_items-number">5.13.2.</span> <span class="toc_mobile_items-text">线程池的状态</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java常用类库与技巧"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Java常用类库与技巧</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">TODO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题一：Java异常处理机制"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">问题一：Java异常处理机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java异常的处理原则"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">Java异常的处理原则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java异常处理消耗性能的地方"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">Java异常处理消耗性能的地方</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题二：Error和Exception的区别"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">问题二：Error和Exception的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题三：设计高效主流的异常处理框架"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">问题三：设计高效主流的异常处理框架</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题四：数据结构和算法"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">问题四：数据结构和算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据结构常见考点："><span class="toc_mobile_items-number">6.5.1.</span> <span class="toc_mobile_items-text">数据结构常见考点：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#算法常见考点"><span class="toc_mobile_items-number">6.5.2.</span> <span class="toc_mobile_items-text">算法常见考点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题五：Java集合框架"><span class="toc_mobile_items-number">6.6.</span> <span class="toc_mobile_items-text">问题五：Java集合框架</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题六：Map讲解"><span class="toc_mobile_items-number">6.7.</span> <span class="toc_mobile_items-text">问题六：Map讲解</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#剑指Offer"><span class="toc-number">1.</span> <span class="toc-text">剑指Offer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总览"><span class="toc-number">2.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java底层知识：JVM"><span class="toc-number">3.</span> <span class="toc-text">Java底层知识：JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题一：谈谈你对Java的理解？"><span class="toc-number">3.1.</span> <span class="toc-text">问题一：谈谈你对Java的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题二：Compile-One-Run-AnyWhere（平台无关性）如何实现？"><span class="toc-number">3.2.</span> <span class="toc-text">问题二：Compile One,Run AnyWhere（平台无关性）如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题三：JVM如何加载-class文件？"><span class="toc-number">3.3.</span> <span class="toc-text">问题三：JVM如何加载.class文件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题四：谈谈Java反射"><span class="toc-number">3.4.</span> <span class="toc-text">问题四：谈谈Java反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题五：类从编译到执行的过程"><span class="toc-number">3.5.</span> <span class="toc-text">问题五：类从编译到执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题六：谈谈ClassLoader"><span class="toc-number">3.6.</span> <span class="toc-text">问题六：谈谈ClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题七：谈谈类加载器的双亲委派机制"><span class="toc-number">3.7.</span> <span class="toc-text">问题七：谈谈类加载器的双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题八：谈谈类的加载方式"><span class="toc-number">3.8.</span> <span class="toc-text">问题八：谈谈类的加载方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的装载过程"><span class="toc-number">3.8.1.</span> <span class="toc-text">类的装载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadClass和forName的区别"><span class="toc-number">3.8.2.</span> <span class="toc-text">LoadClass和forName的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题九：Java内存空间结构模型"><span class="toc-number">3.9.</span> <span class="toc-text">问题九：Java内存空间结构模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程角度"><span class="toc-number">3.9.1.</span> <span class="toc-text">线程角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储角度"><span class="toc-number">3.9.2.</span> <span class="toc-text">存储角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序计数器（Program-Counter-Register）"><span class="toc-number">3.9.3.</span> <span class="toc-text">程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java虚拟机栈（Stack）"><span class="toc-number">3.9.4.</span> <span class="toc-text">Java虚拟机栈（Stack）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十五：不同jdk版本之间的intern-方法的区别-JDK6-vs-JDK6"><span class="toc-number">3.10.</span> <span class="toc-text">问题十五：不同jdk版本之间的intern()方法的区别-JDK6 vs JDK6+</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java多线程与并发"><span class="toc-number">4.</span> <span class="toc-text">Java多线程与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题一：进程和线程的区别？"><span class="toc-number">4.1.</span> <span class="toc-text">问题一：进程和线程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题二：Java进程和线程的关系"><span class="toc-number">4.2.</span> <span class="toc-text">问题二：Java进程和线程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题三：Thread中的start和run方法的区别？"><span class="toc-number">4.3.</span> <span class="toc-text">问题三：Thread中的start和run方法的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题四：Thread和Runnable是什么关系？"><span class="toc-number">4.4.</span> <span class="toc-text">问题四：Thread和Runnable是什么关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题五：如何给run-方法传参？"><span class="toc-number">4.5.</span> <span class="toc-text">问题五：如何给run()方法传参？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题六：如何实现处理线程的返回值"><span class="toc-number">4.6.</span> <span class="toc-text">问题六：如何实现处理线程的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题七：线程的状态"><span class="toc-number">4.7.</span> <span class="toc-text">问题七：线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题八：sleep和wait的区别？"><span class="toc-number">4.8.</span> <span class="toc-text">问题八：sleep和wait的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题九：notify和notifyAll的区别"><span class="toc-number">4.9.</span> <span class="toc-text">问题九：notify和notifyAll的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十：谈谈你对java-lang-Thread-yield的理解"><span class="toc-number">4.10.</span> <span class="toc-text">问题十：谈谈你对java.lang.Thread#yield的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十一：如何中断线程"><span class="toc-number">4.11.</span> <span class="toc-text">问题十一：如何中断线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十二：线程状态以及线程状态的切换"><span class="toc-number">4.12.</span> <span class="toc-text">问题十二：线程状态以及线程状态的切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java多线程与并发-原理"><span class="toc-number">5.</span> <span class="toc-text">Java多线程与并发-原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题一：谈谈什么不是线程安全的？"><span class="toc-number">5.1.</span> <span class="toc-text">问题一：谈谈什么不是线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题二：谈谈synchronized底层实现原理"><span class="toc-number">5.2.</span> <span class="toc-text">问题二：谈谈synchronized底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是重入？"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是重入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈synchronized优化？"><span class="toc-number">5.2.2.</span> <span class="toc-text">谈谈synchronized优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题三：自旋锁和自适应自旋锁"><span class="toc-number">5.3.</span> <span class="toc-text">问题三：自旋锁和自适应自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题四：锁消除和锁粗化"><span class="toc-number">5.4.</span> <span class="toc-text">问题四：锁消除和锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题五：synchronized的四种状态"><span class="toc-number">5.5.</span> <span class="toc-text">问题五：synchronized的四种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题六：synchronized和ReentrantLock的区别？"><span class="toc-number">5.6.</span> <span class="toc-text">问题六：synchronized和ReentrantLock的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题七：sun-misc-Unsafe的理解"><span class="toc-number">5.7.</span> <span class="toc-text">问题七：sun.misc.Unsafe的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题八：什么是Java内存模型中的happens-before"><span class="toc-number">5.8.</span> <span class="toc-text">问题八：什么是Java内存模型中的happens-before</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题九：JMM如何解决可见性问题"><span class="toc-number">5.9.</span> <span class="toc-text">问题九：JMM如何解决可见性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用happens-before规则判方法是否是线程安全的？"><span class="toc-number">5.9.1.</span> <span class="toc-text">利用happens-before规则判方法是否是线程安全的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十：谈谈Volatile的认识"><span class="toc-number">5.10.</span> <span class="toc-text">问题十：谈谈Volatile的认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例双重锁检测实现"><span class="toc-number">5.10.1.</span> <span class="toc-text">单例双重锁检测实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十一：volatile和synchronized的区别"><span class="toc-number">5.11.</span> <span class="toc-text">问题十一：volatile和synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十二：谈谈CAS"><span class="toc-number">5.12.</span> <span class="toc-text">问题十二：谈谈CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i-操作的字节码"><span class="toc-number">5.12.1.</span> <span class="toc-text">i++操作的字节码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题十三：谈谈线程池"><span class="toc-number">5.13.</span> <span class="toc-text">问题十三：谈谈线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池新任务提交execute执行后的流程"><span class="toc-number">5.13.1.</span> <span class="toc-text">线程池新任务提交execute执行后的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的状态"><span class="toc-number">5.13.2.</span> <span class="toc-text">线程池的状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java常用类库与技巧"><span class="toc-number">6.</span> <span class="toc-text">Java常用类库与技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-number">6.1.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题一：Java异常处理机制"><span class="toc-number">6.2.</span> <span class="toc-text">问题一：Java异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java异常的处理原则"><span class="toc-number">6.2.1.</span> <span class="toc-text">Java异常的处理原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java异常处理消耗性能的地方"><span class="toc-number">6.2.2.</span> <span class="toc-text">Java异常处理消耗性能的地方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题二：Error和Exception的区别"><span class="toc-number">6.3.</span> <span class="toc-text">问题二：Error和Exception的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题三：设计高效主流的异常处理框架"><span class="toc-number">6.4.</span> <span class="toc-text">问题三：设计高效主流的异常处理框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题四：数据结构和算法"><span class="toc-number">6.5.</span> <span class="toc-text">问题四：数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构常见考点："><span class="toc-number">6.5.1.</span> <span class="toc-text">数据结构常见考点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法常见考点"><span class="toc-number">6.5.2.</span> <span class="toc-text">算法常见考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题五：Java集合框架"><span class="toc-number">6.6.</span> <span class="toc-text">问题五：Java集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题六：Map讲解"><span class="toc-number">6.7.</span> <span class="toc-text">问题六：Map讲解</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指Offer（完整版）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-23<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-22</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/">剑指Offer（完整版）</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">9.9k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 35 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><blockquote>
<ol>
<li>Java底层知识：JVM</li>
<li>Java底层知识：GC相关</li>
<li>Java多线程与并发</li>
<li>Java多线程与并发-原理</li>
<li>Java常用类库与技巧</li>
<li>Java框架-Spring</li>
<li>计算机网络</li>
<li>数据库MySQL</li>
<li>缓存Redis</li>
<li>服务器Linux</li>
</ol>
</blockquote>
<h1 id="Java底层知识：JVM"><a href="#Java底层知识：JVM" class="headerlink" title="Java底层知识：JVM"></a>Java底层知识：JVM</h1><h2 id="问题一：谈谈你对Java的理解？"><a href="#问题一：谈谈你对Java的理解？" class="headerlink" title="问题一：谈谈你对Java的理解？"></a>问题一：谈谈你对Java的理解？</h2><ul>
<li>平台无关性：一次编译，到处运行</li>
<li>GC：不用像C++那样手动释放堆内存</li>
<li>语言特性：泛型、发射、Lamble表达式</li>
<li>面向对象：封装、继承、多态</li>
<li>类库：JUC并发库、网络库、I/O库</li>
<li>异常处理机制</li>
</ul>
<h2 id="问题二：Compile-One-Run-AnyWhere（平台无关性）如何实现？"><a href="#问题二：Compile-One-Run-AnyWhere（平台无关性）如何实现？" class="headerlink" title="问题二：Compile One,Run AnyWhere（平台无关性）如何实现？"></a>问题二：Compile One,Run AnyWhere（平台无关性）如何实现？</h2><ul>
<li>编译时<ol>
<li>javac指令：将.java源码，编译为字节码</li>
<li><code>javap -c</code>：对代码（.class）进行反汇编</li>
</ol>
</li>
<li>运行时<ol>
<li>jvm解释：转换为特定平台的执行指令</li>
</ol>
</li>
</ul>
<blockquote>
<p>标准答案：Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java 语言在不同的平台上<br>运行时不需要进行重新编译，Java虛拟机在执行字节码的时候，把字节码转换成具体平台上<br>的机器指令。</p>
</blockquote>
<h2 id="问题三：JVM如何加载-class文件？"><a href="#问题三：JVM如何加载-class文件？" class="headerlink" title="问题三：JVM如何加载.class文件？"></a>问题三：JVM如何加载.class文件？</h2><ul>
<li>Java虚拟机：屏蔽底层操作系统的不同，并且减少基于原生语言开发的复杂性。JVM是内存虚拟机，所有信息都存储在内存中。两大特性：JVM内存模型，GC。</li>
</ul>
<p><img alt="image-20200223084810674" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gc61ojxhgfj316y0k8gwk.jpg" class="lazyload"></p>
<ul>
<li><p>Class Loader：依据特定格式，加载class文件到内存。</p>
</li>
<li><p>Execution Engine：对命令进行解释</p>
</li>
<li><p>Native Interface：融合不同开发语言的原生库为Java所用。</p>
<ul>
<li><blockquote>
<p>在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（Thread类）。（当然也可能是为了执行效率而使用Native方法，通常最高效的手段就是平台相关的手段）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Runtime Data Area：JVM内存空间结构模型</p>
</li>
</ul>
<h2 id="问题四：谈谈Java反射"><a href="#问题四：谈谈Java反射" class="headerlink" title="问题四：谈谈Java反射"></a>问题四：谈谈Java反射</h2><blockquote>
<p>标准答案：JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象,<br>都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaOffer._1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * Java反射栗子</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-23 09:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取字节码</span></span><br><span class="line">        Class rc = Class.forName(<span class="string">"javaOffer._1.ReflectRobot"</span>);</span><br><span class="line">        ReflectRobot r = (ReflectRobot) rc.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java.lang.Class.getDeclaredMethod，可以获取本类的所有方法（public、private、static）。但是不能获取继承的方法和实现接口的方法</span></span><br><span class="line">        Method method = rc.getDeclaredMethod(<span class="string">"throwHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = method.invoke(r, <span class="string">"bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"通过反射调用实例私有方法="</span> + o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取和设置私有属性</span></span><br><span class="line">        Field declaredField = rc.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        declaredField.set(r, <span class="string">"noah"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java.lang.Class.getMethod，只能获取本类共有的方法，也可以获取继承或者实现的共有方法</span></span><br><span class="line">        Method sayHi = rc.getMethod(<span class="string">"sayHi"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHi.invoke(r, <span class="string">"welcome"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class name is="</span> + rc.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题五：类从编译到执行的过程"><a href="#问题五：类从编译到执行的过程" class="headerlink" title="问题五：类从编译到执行的过程"></a>问题五：类从编译到执行的过程</h2><ul>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转换为JVM中的Class &lt; Robot&gt;对象</li>
<li>JVM利用Class &lt; Robot&gt;对象实例化为Robot对象</li>
</ul>
<h2 id="问题六：谈谈ClassLoader"><a href="#问题六：谈谈ClassLoader" class="headerlink" title="问题六：谈谈ClassLoader"></a>问题六：谈谈ClassLoader</h2><blockquote>
<p>ClassLoader在Java中有着非常重要的作用, 它主要工作在Class装载的加载阶段,其主要作用是从系统外<br>部获得Class二进制数据流。它是Java的核心组件，所有的Class 都是由ClassLoader 进行加载的,<br>ClassLoader负责通过将Class文件里的二进制数据流装载进系统,然后交给Java虚拟机进行连接、初始<br>化等操作。</p>
</blockquote>
<ul>
<li>BootStrapClassLoader：C++编写，加载核心库java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录</li>
<li>Custom(自定义)ClassLoader：Java编写，定制化加载<ol>
<li>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</li>
<li>java.lang.ClassLoader#findClass</li>
<li>java.lang.ClassLoader#defineClass(byte[], int, int)</li>
</ol>
</li>
</ul>
<h2 id="问题七：谈谈类加载器的双亲委派机制"><a href="#问题七：谈谈类加载器的双亲委派机制" class="headerlink" title="问题七：谈谈类加载器的双亲委派机制"></a>问题七：谈谈类加载器的双亲委派机制</h2><ul>
<li>自底向上检查Class&lt;?&gt;是否已经加载了，自顶向下尝试加载类</li>
<li>委托机制：避免多份同样字节码的加载</li>
</ul>
<h2 id="问题八：谈谈类的加载方式"><a href="#问题八：谈谈类的加载方式" class="headerlink" title="问题八：谈谈类的加载方式"></a>问题八：谈谈类的加载方式</h2><ul>
<li>隐式加载：new</li>
<li>显示加载：loadClass，forName等</li>
</ul>
<h3 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h3><ol>
<li>加载：通过ClassLoader加载class文件字节码，生成class对象</li>
<li>链接：<ol>
<li>校验：检查加载的class的正确性和安全性</li>
<li>准备：为类变量分配存储空间并设置类变量初始值</li>
<li>解析：JVM将常量池内的符号引用转换为直接引用</li>
</ol>
</li>
<li>初始化：执行类变量赋值和静态代码块</li>
</ol>
<h3 id="LoadClass和forName的区别"><a href="#LoadClass和forName的区别" class="headerlink" title="LoadClass和forName的区别"></a>LoadClass和forName的区别</h3><ol>
<li>Class.forName：得到的class是已经初始化完成的</li>
<li>ClassLoader.loadClass：得到的class是还没有链接</li>
<li>二者应用：forName()，加载初始化了静态资源（Mysql的Driver）。loadClass，spring延时加载。</li>
</ol>
<h2 id="问题九：Java内存空间结构模型"><a href="#问题九：Java内存空间结构模型" class="headerlink" title="问题九：Java内存空间结构模型"></a>问题九：Java内存空间结构模型</h2><h3 id="线程角度"><a href="#线程角度" class="headerlink" title="线程角度"></a>线程角度</h3><ul>
<li>线程私有：程序计数器(no OOM)、虚拟机栈(OOM)、本地方法栈(OOM)</li>
<li>线程共享：MetaSpace（类加载信息&amp;&amp;OOM）、堆（数组和类对象OOM。【常量池（字面量和符号引用量）OOM】）</li>
</ul>
<h3 id="存储角度"><a href="#存储角度" class="headerlink" title="存储角度"></a>存储角度</h3><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><ul>
<li>当前线程所执行的字节码行号指示器(逻辑)</li>
<li>改变计数器的值来选取下一 条需要执行的字节码指令</li>
<li>和线程是一对一的关系即“线程私有”</li>
<li>对Java方法计数,如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄露</li>
</ul>
<h3 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h3><ul>
<li><p>Java方法执行的内存模型</p>
</li>
<li><p>包含多个栈帧（局部变量表、操作栈、动态链接、返回地址）</p>
<ol>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈、出栈、复制、交换、超声消费变量</li>
</ol>
</li>
<li><pre><code class="java">Classfile /Users/codingprh/IdeaProjects/TeslaV2/src/javaOffer/_1/ByteCodeSample<span class="class">.<span class="keyword">class</span></span>
<span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-2-23</span>; size <span class="number">283</span> bytes
  MD5 checksum b490af96007ad2ac153fdd3c0ca00cc1
  Compiled from <span class="string">"ByteCodeSample.java"</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javaOffer</span>.<span class="title">_1</span>.<span class="title">ByteCodeSample</span></span>
  minor version: 0
  major version: <span class="number">52</span>
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#12         // java/lang/Object."&lt;init&gt;":()V
   #2 = Class              #13            // javaOffer/_1/ByteCodeSample
   #3 = Class              #14            // java/lang/Object
   #4 = Utf8               &lt;init&gt;
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               add
   #9 = Utf8               (II)I
  #10 = Utf8               SourceFile
  #11 = Utf8               ByteCodeSample.java
  #12 = NameAndType        #4:#5          // "&lt;init&gt;":()V
  #13 = Utf8               javaOffer/_1/ByteCodeSample
  #14 = Utf8               java/lang/Object
{
  <span class="keyword">public</span> javaOffer._1.ByteCodeSample();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>
         <span class="number">0</span>: aload_0
         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
         <span class="number">4</span>: <span class="keyword">return</span>
      LineNumberTable:
        line <span class="number">10</span>: <span class="number">0</span>

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;
    descriptor: (II)I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">2</span>
         <span class="number">0</span>: iconst_0    (c=<span class="number">0</span>，压入操作数栈)
         <span class="number">1</span>: istore_2    (c=<span class="number">0</span>,操作数出栈，存储到局部变量表)
         <span class="number">2</span>: iload_0        (局部变量第一个元素入操作数栈)
         <span class="number">3</span>: iload_1        (局部变量第二个元素入操作数栈)
         <span class="number">4</span>: iadd            (操作数栈顶两个元素相加)
         <span class="number">5</span>: istore_2        (操作数出栈，存储到局部变量表<span class="number">2</span>位置)
         <span class="number">6</span>: iload_2            (局部变量第二个位置的元素压入操作数栈)
         <span class="number">7</span>: ireturn
      LineNumberTable:
        line <span class="number">13</span>: <span class="number">0</span>
        line <span class="number">14</span>: <span class="number">2</span>
        line <span class="number">15</span>: <span class="number">6</span>
}
SourceFile: <span class="string">"ByteCodeSample.java"</span>

<span class="comment">/**</span>
<span class="comment">*    这是java源码，通过javap -v 反汇编的代码</span>
<span class="comment">*/</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{
  <span class="keyword">int</span> c = <span class="number">0</span>;
  c = a + b;
  <span class="keyword">return</span> c;
}

&lt;!--￼<span class="number">1</span>--&gt;</code></pre>
</li>
<li><p>元空间：Class：ModelSample，Method：sayHello/getName/setName/main，Field：name</p>
</li>
<li><p>Java堆：Object：String(“aa”)，Object：ModelSample</p>
</li>
<li><p>线程独占：reference：ms，aa在堆中的引用。pc</p>
</li>
</ul>
<h2 id="问题十五：不同jdk版本之间的intern-方法的区别-JDK6-vs-JDK6"><a href="#问题十五：不同jdk版本之间的intern-方法的区别-JDK6-vs-JDK6" class="headerlink" title="问题十五：不同jdk版本之间的intern()方法的区别-JDK6 vs JDK6+"></a>问题十五：不同jdk版本之间的intern()方法的区别-JDK6 vs JDK6+</h2><blockquote>
<p>String aa=new String(“aa”);</p>
<p>aa.intern();</p>
<p>JDK6 :当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，<br>将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。</p>
<p>JDK6+:当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，<br>如果该字符串对象已经存在于Java堆中,则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用;如果堆中<br>不存在，则在池中创建该字符串并返回其引用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaOffer._1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 字符串的比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-23 16:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用""创建的，都是在字符串常量池创建的</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">        s.intern();</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">        String aa = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">        aa.intern();</span><br><span class="line">        String aa2 = <span class="string">"aa"</span>;</span><br><span class="line">        System.out.println(aa == aa2);</span><br><span class="line">      <span class="comment">//jdk6+：false、true</span></span><br><span class="line">      <span class="comment">//jdk6：false、false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java多线程与并发"><a href="#Java多线程与并发" class="headerlink" title="Java多线程与并发"></a>Java多线程与并发</h1><h2 id="问题一：进程和线程的区别？"><a href="#问题一：进程和线程的区别？" class="headerlink" title="问题一：进程和线程的区别？"></a>问题一：进程和线程的区别？</h2><blockquote>
<p>扩展问题：内核态和用户态的区别，怎么切换？为什么要转换？什么是系统中断？内核态多线程轻量级进程，如何实现的？</p>
<p>进程的由来：</p>
<ol>
<li>串行：初期的计算机智能串行执行任务,并且需要长时间等待用户输入</li>
<li>批处理：预先将用户的指令集中成清单,批量串行处理用户指令, 仍然无法并发执行</li>
<li>进程：进程独占内存空间,保存各自运行状态,相互间不干扰且可以互相切换,为并发处理任务提供了可能</li>
<li>线程：共享进程的内存资源，相互间切换更快速 ,支持更细粒度的任务控制 ,使进程内的子任务得以并发执行</li>
</ol>
</blockquote>
<ul>
<li>进程是资源分配的最小单位，线程是cpu调度的最小单位。</li>
<li>所有与进程相关的资源，都被记录到PCB（进程控制块）中。<ol>
<li>描述信息</li>
<li>控制信息</li>
<li>资源信息（程序段、数据集）</li>
<li>cpu线程</li>
</ol>
</li>
<li>进程是抢占处理机的调度单位；线程属于某个进程，共享其资源</li>
<li>线程只由堆栈寄存器、程序计数器和TCB组成。</li>
<li>总结：<ol>
<li>线程不能看做独立应用，而进程可看做独立应用</li>
<li>进程有独立的地址空间,相互不影响, 线程只是进程的不同执行路径</li>
<li>线程没有独立的地址空间,多进程的程序比多线程程序健壮</li>
<li>进程的切换比线程的切换开销大</li>
</ol>
</li>
</ul>
<h2 id="问题二：Java进程和线程的关系"><a href="#问题二：Java进程和线程的关系" class="headerlink" title="问题二：Java进程和线程的关系"></a>问题二：Java进程和线程的关系</h2><ul>
<li>Java对操作系统提供的功能进行封装, 包括进程和线程</li>
<li>运行一个程序会产生一个进程,进程包含至少一个线程</li>
<li>每个进程对应一个JVM实例,多个线程共享JVM里的堆</li>
<li>Java采用单线程编程模型,程序会自动创建主线程</li>
<li>主线程可以创建子线程,原则上要后于子线程完成执行</li>
</ul>
<h2 id="问题三：Thread中的start和run方法的区别？"><a href="#问题三：Thread中的start和run方法的区别？" class="headerlink" title="问题三：Thread中的start和run方法的区别？"></a>问题三：Thread中的start和run方法的区别？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径：hotspot-29ef249e9953/src/share/vm/prims/jvm.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>答案：java.lang.Thread#start——&gt;JVM_StartThread——&gt;thread_entry——&gt;java.lang.Thread#run</li>
<li>调用start()方法会创建一个新的子线程并启动</li>
<li>run()方法只是Thread的一个普通方法的调用</li>
</ul>
<h2 id="问题四：Thread和Runnable是什么关系？"><a href="#问题四：Thread和Runnable是什么关系？" class="headerlink" title="问题四：Thread和Runnable是什么关系？"></a>问题四：Thread和Runnable是什么关系？</h2><ul>
<li>Thread是实现了Runnable接口的类，使得run支持多线程。</li>
<li>因为类是单一继承原则，推荐多使用Runnable接口</li>
</ul>
<h2 id="问题五：如何给run-方法传参？"><a href="#问题五：如何给run-方法传参？" class="headerlink" title="问题五：如何给run()方法传参？"></a>问题五：如何给run()方法传参？</h2><ul>
<li>构造器传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ul>
<h2 id="问题六：如何实现处理线程的返回值"><a href="#问题六：如何实现处理线程的返回值" class="headerlink" title="问题六：如何实现处理线程的返回值"></a>问题六：如何实现处理线程的返回值</h2><ul>
<li>主线程等待法 </li>
<li>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</li>
<li>通过Callable接口实现：通过FutureTask or 线程池获取</li>
</ul>
<h2 id="问题七：线程的状态"><a href="#问题七：线程的状态" class="headerlink" title="问题七：线程的状态"></a>问题七：线程的状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点：已经运行完的线程，再执行start()方法，异常：java.lang.IllegalThreadStateException</li>
</ul>
<h2 id="问题八：sleep和wait的区别？"><a href="#问题八：sleep和wait的区别？" class="headerlink" title="问题八：sleep和wait的区别？"></a>问题八：sleep和wait的区别？</h2><ul>
<li>sleep是Thread类的方法，wait是Object类的方法，都是native方法</li>
<li>sleep()方法可以在任何地方使用</li>
<li>wait()方法只能在synchronized方法或synchronized块中使用</li>
<li>最本质的区别：<ol>
<li>java.lang.Object#wait()不仅让出cpu，还会释放已经占有的同步资源锁。</li>
<li>java.lang.Thread#sleep(long)只会让出cpu，不会导致锁行为的改变</li>
</ol>
</li>
</ul>
<h2 id="问题九：notify和notifyAll的区别"><a href="#问题九：notify和notifyAll的区别" class="headerlink" title="问题九：notify和notifyAll的区别"></a>问题九：notify和notifyAll的区别</h2><blockquote>
<p>两个概念：锁池(EntryList)和等待池(WaitSet)，java的每个对象都拥有这两个属性。</p>
<p>锁池：假设线程A已经拥有了某个对象(不是类)的锁，而其它线程B、C想要调用这个对象的某个synchronized方法(或者块)，由于B、C线程在进入对象的synchronized方法(或者块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池</p>
<p>等待池：假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。</p>
</blockquote>
<ul>
<li>notifyAll：会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会。</li>
<li>notify：只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。</li>
</ul>
<h2 id="问题十：谈谈你对java-lang-Thread-yield的理解"><a href="#问题十：谈谈你对java-lang-Thread-yield的理解" class="headerlink" title="问题十：谈谈你对java.lang.Thread#yield的理解"></a>问题十：谈谈你对java.lang.Thread#yield的理解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment"> * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment"> * hint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment"> * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment"> * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment"> * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span></span><br><span class="line"><span class="comment"> * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment"> * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment"> * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当调用Thread.yield()函数时,会给线程调度器一个当前线程愿意让出CPU使用的暗示,但是线程调度器可能会忽略这个暗示。</li>
<li>不会影响锁的资源</li>
</ul>
<h2 id="问题十一：如何中断线程"><a href="#问题十一：如何中断线程" class="headerlink" title="问题十一：如何中断线程"></a>问题十一：如何中断线程</h2><ul>
<li>已经被抛弃的方法：<ol>
<li>通过调用stop()方法停止线程</li>
<li>通过调用suspend(挂起)和resume(恢复)方法</li>
</ol>
</li>
<li>目前使用的方法：<ol>
<li>调用java.lang.Thread#interrupt，通知线程应该中断了，需要被调用的线程配合中断。（只是一个hint提醒）<ul>
<li>①如果线程处于被阻塞状态, 那么线程将立即退出被阻塞状态,并<br>抛出一个InterruptedException异常。</li>
<li>②如果线程处于正常活动状态,那么会将该线程的中断标志设置为<br>true。被设置中断标志的线程将继续正常运行,不受影响。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="问题十二：线程状态以及线程状态的切换"><a href="#问题十二：线程状态以及线程状态的切换" class="headerlink" title="问题十二：线程状态以及线程状态的切换"></a>问题十二：线程状态以及线程状态的切换</h2><p><img alt="image-20200225150626098" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gc8nuveheij313w0s2n8r.jpg" class="lazyload"></p>
<h1 id="Java多线程与并发-原理"><a href="#Java多线程与并发-原理" class="headerlink" title="Java多线程与并发-原理"></a>Java多线程与并发-原理</h1><h2 id="问题一：谈谈什么不是线程安全的？"><a href="#问题一：谈谈什么不是线程安全的？" class="headerlink" title="问题一：谈谈什么不是线程安全的？"></a>问题一：谈谈什么不是线程安全的？</h2><ul>
<li>存在共享数据（也称临界资源）</li>
<li>存在多条线程共同操作这些共享数据</li>
<li>解决方案（互斥锁）：同一时刻有且只有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作<ol>
<li>互斥性：即在同一时间只允许一个线程持有某个对象锁 ,通过这种特性来实现多线程的协调机制,这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问。互斥性也称为操作的原子性。</li>
<li>可见性：必须确保在锁被释放之前,对共享变量所做的修改,对于随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值) ,否则另一个线程可能是在本地缓存的某个副本上继续操作,从而引起不一致。</li>
<li>sychronized能够解决原子（互斥）性和可见性。锁的不是代码，锁的都是对象。<ul>
<li>对象锁</li>
<li>类锁</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="问题二：谈谈synchronized底层实现原理"><a href="#问题二：谈谈synchronized底层实现原理" class="headerlink" title="问题二：谈谈synchronized底层实现原理"></a>问题二：谈谈synchronized底层实现原理</h2><ul>
<li><strong>Java对象头</strong>：</li>
<li><strong>Monitor：</strong>每个Java对象天生自带了一把看不见的锁</li>
</ul>
<blockquote>
<p>对象在内存中的布局：对象头、实例数据、对齐填充</p>
<ul>
<li><p>对象头结构</p>
<ol>
<li><p>Mark Word：默认存储对象的hashCode，分代年龄，锁类型，锁标志位等信息</p>
</li>
<li><p>Class Metadata Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据</p>
</li>
</ol>
</li>
</ul>
<p><img alt="image-20200226100326844" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9kpwre87j31r20oo4br.jpg" class="lazyload"></p>
</blockquote>
<blockquote>
<p>Monitor实现：c++源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;</span><br><span class="line">  _count        = <span class="number">0</span>;			<span class="comment">//信号量</span></span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>;</span><br><span class="line">  _object       = <span class="literal">NULL</span>;</span><br><span class="line">  _owner        = <span class="literal">NULL</span>;		<span class="comment">//持有这个锁的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;		<span class="comment">//等待池</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;	<span class="comment">//锁池</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20200226104225364" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gc9lucjg4pj31hu0sy7wh.jpg" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//synchronized字节码</span></span><br><span class="line"><span class="number">4</span>: monitorenter</span><br><span class="line">     5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     8: ldc           #4                  // String hello</span><br><span class="line">    10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    <span class="number">13</span>: aload_1</span><br><span class="line">    <span class="number">14</span>: monitorexit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="什么是重入？"><a href="#什么是重入？" class="headerlink" title="什么是重入？"></a>什么是重入？</h3><p>从互斥锁的设计上来说,当一个线程试图操作一个由其他线程持有的对象锁的临界资源时,将会处于阻塞状态,但当一个线程再次请求自己持有对象锁的临界资源时,这种情况属于重入。</p>
<h3 id="谈谈synchronized优化？"><a href="#谈谈synchronized优化？" class="headerlink" title="谈谈synchronized优化？"></a>谈谈synchronized优化？</h3><ul>
<li>在早期版本synchronized属于重量级锁，依赖于核心态实现。用户态转与核心态的切换开销较大。</li>
<li>自适应自旋（Adaptive Spinning）</li>
<li>锁消除（Lock Eliminate）</li>
<li>锁粗化（Lock Coarsening）</li>
<li>轻量级锁（Lightweight Locking）</li>
<li>偏向锁（Biased Locking）</li>
</ul>
<h2 id="问题三：自旋锁和自适应自旋锁"><a href="#问题三：自旋锁和自适应自旋锁" class="headerlink" title="问题三：自旋锁和自适应自旋锁"></a>问题三：自旋锁和自适应自旋锁</h2><ul>
<li>很多情况下，共享数据的锁定状态持续时间较短，切换线程不值得（挂起和唤醒【用户态切换到内核态】）。<ol>
<li>自旋：在多核时代，让等待的线程，占据cpu使用时间。</li>
<li>缺点：若锁被其他线程长时间占用，会带来很多性能的开销。</li>
<li>JVM调优参数：-XX:PerBlockSpin，默认值为10</li>
</ol>
</li>
<li>自适应自旋锁：<ol>
<li>自旋次数不再固定</li>
<li>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
</ol>
</li>
</ul>
<h2 id="问题四：锁消除和锁粗化"><a href="#问题四：锁消除和锁粗化" class="headerlink" title="问题四：锁消除和锁粗化"></a>问题四：锁消除和锁粗化</h2><ul>
<li>锁消除：JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。</li>
<li>锁粗化：通过扩大加锁的范围，避免反复加锁和解锁</li>
</ul>
<h2 id="问题五：synchronized的四种状态"><a href="#问题五：synchronized的四种状态" class="headerlink" title="问题五：synchronized的四种状态"></a>问题五：synchronized的四种状态</h2><ol>
<li>无锁：</li>
<li>偏向锁：减少同一线程获取锁的代价。<ul>
<li>大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得。</li>
<li>核心思想：如果一个线程获得了锁,那么锁就进入偏向模式,此时Mark Word的结<br>构也变为偏向锁结构,当该线程再次请求锁时,无需再做任何同步操作,<br>即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线<br>程Id等于Mark Word的ThreadID即可,这样就省去了大量有关锁申请的<br>操作。</li>
<li>不适用于锁竞争比较激烈的多线程场合</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li>轻量级锁是由偏向锁升级来的,偏向锁运行在一个线程进入同步块的情<br>况下,当第二个线程加入锁争用的时候,偏向锁就会升级为轻量级锁。</li>
<li>适应的场景:线程交替执行同步块</li>
<li>若存在同一时间，多线程访问同一锁的情况,就会导致轻量级锁膨胀为重量级锁</li>
</ul>
</li>
<li>重量级锁：sychronized</li>
</ol>
<blockquote>
<p>四种状态的转换：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<p><img alt="image-20200227083554628" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gcant2dsh8j30su0dyte8.jpg" class="lazyload"></p>
<p><img alt="image-20200227083711578" data-src="https://tva1.sinaimg.cn/large/0082zybpgy1gcanucpamsj30u70aegpf.jpg" class="lazyload"></p>
<p>轻量级别锁CAS解释：在当前线程的栈帧中建立一个锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。CAS操作尝试将对象的Mark Word更新指向Lock Record的指针，如果更新动作成功了，那么这个线程就拥有了该对象的锁。并且对象Mark Word的锁标志位转变为”00”。</p>
<p>轻量级别锁释放锁：那就用CAS操作把对象当前的Mark Word和线程中的Lock Record替换回来。</p>
<p>锁的内存语义：</p>
<ul>
<li>当线程释放锁时，Java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中;</li>
<li>而当线程获取锁时, Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td align="center">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td align="center">如果线程间存在锁竞争会带来二外的锁撤销的消耗</td>
<td align="center">只有一个线程访问同步块或者同步方法的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td align="center">竞争的线程不会阻塞，提高了响应速度</td>
<td align="center">若线程长时间抢不到锁，自旋会消耗cpu性能</td>
<td align="center">线程交替执行同步块或者同步方法的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td align="center">线程竞争不使用自旋，不会消耗cpu</td>
<td align="center">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td align="center">追求吞吐量，同步块或者同步方法执行时间较长的场景</td>
</tr>
</tbody></table>
<h2 id="问题六：synchronized和ReentrantLock的区别？"><a href="#问题六：synchronized和ReentrantLock的区别？" class="headerlink" title="问题六：synchronized和ReentrantLock的区别？"></a>问题六：synchronized和ReentrantLock的区别？</h2><blockquote>
<p>java.util.concurrent.locks.ReentrantLock介绍</p>
<ul>
<li>位于juc包下</li>
<li>和java.util.concurrent.CountDownLatch、java.util.concurrent.FutureTask、java.util.concurrent.Semaphore一样基于AQS（队列同步器）实现</li>
<li>能够实现比synchronized更细粒度的控制，如公平锁</li>
<li>调用lock()之后，必须调用unlock()释放锁</li>
<li>性能未必比synchronized高，并且也是可重入的。</li>
<li>经典实现：java.util.concurrent.ArrayBlockingQueue（数组实现，有界，线程安全的队列）</li>
</ul>
<p>ReentrantLock将锁对象化</p>
<ul>
<li>判断是否有线程，或者某个特定线程，在排队等待获取锁</li>
<li>带超时的获取锁的尝试</li>
<li>感知有没有成功获取锁</li>
</ul>
<p>java.util.concurrent.locks.Condition将<strong>wait/notify/notifyAl</strong>l对象化</p>
</blockquote>
<ul>
<li>总结：<ol>
<li>synchronized是关键字, ReentrantLock是类</li>
<li>ReentrantL ock可以对获取锁的等待时间进行设置,避免死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantL ock可以灵活地实现多路通知</li>
<li>机制: sync操作Mark Word , lock调用Unsafe类的park()方法</li>
</ol>
</li>
</ul>
<h2 id="问题七：sun-misc-Unsafe的理解"><a href="#问题七：sun-misc-Unsafe的理解" class="headerlink" title="问题七：sun.misc.Unsafe的理解"></a>问题七：sun.misc.Unsafe的理解</h2><ul>
<li>Unsafe是一个后门工具，可以用来在任意内存位置读取数据+CAS操作</li>
</ul>
<h2 id="问题八：什么是Java内存模型中的happens-before"><a href="#问题八：什么是Java内存模型中的happens-before" class="headerlink" title="问题八：什么是Java内存模型中的happens-before"></a>问题八：什么是Java内存模型中的happens-before</h2><blockquote>
<p>Java内存模型JMM</p>
<ul>
<li>Java内存模型(即Java Memory Model ,简称JMM)本身是一种抽象的概念，并不真实存在,它描述的是一组规则或规范,通过这组规范定义了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式。</li>
</ul>
<p>JMM中的主内存：</p>
<ol>
<li>存储Java实例对象</li>
<li>包括成员变量、类信息、常量、静态变量等 </li>
<li>属于数据共享的区域，多线程并发操作时会引发线程安全问题</li>
</ol>
<p>JMM中的工作内存</p>
<ol>
<li>存储当前方法中的所有本地变量信息，本地变量对其他线程不可见。</li>
<li>字节码行号指示器、Native方法信息</li>
<li>属于线程私有数据区域,不存在线程安全问题</li>
</ol>
<p>JMM和Java内存区域划分是不同的概念层次</p>
<ul>
<li>JMM描述的是一组规范，围绕可见性、原子性、有序性展开</li>
<li>相似点：存在共享区域和私有区域</li>
</ul>
<p>指令重排序需要满足的条件</p>
<ol>
<li>在单线程环境下不能改变程序运行的结果</li>
<li>存在数据依赖关系的不允许重排序</li>
<li>总结：无法通过happens-before原则推导出来的，才能进行指令的重排序</li>
</ol>
</blockquote>
<h2 id="问题九：JMM如何解决可见性问题"><a href="#问题九：JMM如何解决可见性问题" class="headerlink" title="问题九：JMM如何解决可见性问题"></a>问题九：JMM如何解决可见性问题</h2><ul>
<li>本质是：内存屏障，Happens-before的八大原则</li>
</ul>
<ol>
<li>程序次序规则: 一个线程内,按照代码顺序,书写在前面的操作先行发生于书<br>写在后面的操作;</li>
<li>锁定规则: 一个unLock操作先行发生于后面对同一个锁的lock操作;</li>
<li>volatile变量规则:对一个变量的写操作先行发生于后面对这个变量的读操<br>作;</li>
<li>传递规则:如果操作A先行发生于操作B ,而操作B又先行发生于操作C ,则可<br>以得出操作A先行发生于操作C ;</li>
<li>线程启动规则: Thread对象的start()方法先行发生于此线程的每一个动作 ;</li>
<li>线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>线程终结规则:线程中所有的操作都先行发生于线程的终止检测,我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行;</li>
<li>对象终结规则:一个对象的初始化完成先行发生于他的finalize()方法的开始;</li>
</ol>
<h3 id="利用happens-before规则判方法是否是线程安全的？"><a href="#利用happens-before规则判方法是否是线程安全的？" class="headerlink" title="利用happens-before规则判方法是否是线程安全的？"></a>利用happens-before规则判方法是否是线程安全的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个方法是否是线程安全的？</p>
<blockquote>
<p>显示的是一组再普通不过的get/set方法，假设存在线程A和B，线程A先(时间上的先后)调用了“setValue(1)”, 然后线程B调用了同一个对象的“getValue()”，那么线程B收到的返回值是什么?</p>
<p>我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用:由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用:由于valuc变量没有被volatile关键字修饰，所以volatile变量规则不适用:后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起.</p>
<p>因此我们可以判定尽管线程A在操作时间上先于线程B,但是无法确定线程B中“getValue0”方法的返回结果，换句话说，这里面的操作不是线程安全的。</p>
<p>那怎么修复这个问题呢?我们至少有两种比较简单的方案可以选择:要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则:要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile 关键字使用<br>场景，这样就可以套用volatile变量规则来实现先行发生关系。</p>
</blockquote>
<h2 id="问题十：谈谈Volatile的认识"><a href="#问题十：谈谈Volatile的认识" class="headerlink" title="问题十：谈谈Volatile的认识"></a>问题十：谈谈Volatile的认识</h2><ul>
<li>JVM提供的轻量级同步机制，不保证原子性</li>
<li>保证被volatile修饰的共享变量对所有线程总是可见的</li>
<li>禁止指令的重排序优化（内存屏障）<ul>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ul>
</li>
</ul>
<h3 id="单例双重锁检测实现"><a href="#单例双重锁检测实现" class="headerlink" title="单例双重锁检测实现"></a>单例双重锁检测实现</h3><p><img alt="image-20200329165546701" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdawgowr37j31xk0u04m9.jpg" class="lazyload"></p>
<h2 id="问题十一：volatile和synchronized的区别"><a href="#问题十一：volatile和synchronized的区别" class="headerlink" title="问题十一：volatile和synchronized的区别"></a>问题十一：volatile和synchronized的区别</h2><ul>
<li>volatile本质是在告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要从主存中读取; synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止</li>
<li>volatile仅能使用在变量级别; synchronized则可以使用在变量、方法和类级别</li>
<li>volatile仅能实现变量的修改可见性,不能保证原子性;而synchronized则可以保证变量修改的可见性和原子性</li>
</ul>
<ol start="4">
<li>volatile不会造成线程的阻塞; synchronized可能会造成线程的阻塞</li>
</ol>
<ul>
<li>volatile标记的变量不会被编译器优化; synchronized标记的变量可以被编译器优化</li>
</ul>
<h2 id="问题十二：谈谈CAS"><a href="#问题十二：谈谈CAS" class="headerlink" title="问题十二：谈谈CAS"></a>问题十二：谈谈CAS</h2><ol>
<li><strong>一种高效实现线程安全性的方法：</strong><ul>
<li>支持原子更新操作,适用于计数器,序列发生器等场景</li>
<li>属于乐观锁机制,号称lock-free。<ul>
<li>而synchronized和reentrantlock，悲观锁机制</li>
</ul>
</li>
<li>CAS操作失败时由开发者决定是继续尝试,还是执行别的操作</li>
</ul>
</li>
<li><strong>CAS思想：</strong><ul>
<li>新值，预期原值，旧值（内存）</li>
</ul>
</li>
<li><strong>CAS多数情况下对开发者来说是透明的：</strong><ul>
<li>J.U.C的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具,是很多线程安全程序的首选</li>
<li>Unsafe类虽提供CAS服务,但因能够操纵任意内存地址读写而有隐患</li>
<li>Java9以后,可以使用Variable Handle API来替代Unsafe</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>若循环时间长，则开销很大</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA问题，解决：AtomicStampedReference，使用互斥锁可能更加高效</li>
</ul>
</li>
</ol>
<h3 id="i-操作的字节码"><a href="#i-操作的字节码" class="headerlink" title="i++操作的字节码"></a>i++操作的字节码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * voltile，i++查看字节码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-29 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IAddSample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I，读取主内存的值</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="问题十三：谈谈线程池"><a href="#问题十三：谈谈线程池" class="headerlink" title="问题十三：谈谈线程池"></a>问题十三：谈谈线程池</h2><ol>
<li><p><strong>利用Executors创建不同的线程池满足不同场景的需求：</strong></p>
<ol>
<li>newFixedThreadPool(int nThreads)指定工作线程数量的线程池</li>
<li>newCachedThreadPool()处理大量短时间工作任务的线程池,<br>(1)试图缓存线程并重用,当无缓存线程可用时,就会创建新的工作线程;<br>(2)如果线程闲置的时间超过阈值,则会被终止并移出缓存;<br>(3)系统长时间闲置的时候,不会消耗什么资源</li>
<li>newSingleThreadExecutor()创建唯一的工作者线程来执行任务,如果线程异常结束,会有另一个线程取代它</li>
<li>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)定时或者周期性的工作调度,两者的区别在于单一工作线程还是多个线程</li>
<li>newWorkStealingPool()内部会构建ForkJoinPool ,利用working-stealing算法, 并行地处理任务,不保证处理顺序</li>
</ol>
</li>
<li><p><strong>Fork/Join框架：</strong></p>
<ul>
<li>把大任务分割成若干个小任务并发执行，最终汇总每个小任务结果后得到任务结果的框架</li>
<li>work-stealing算法：某个线程从其他队列里窃取任务来执行</li>
</ul>
</li>
<li><p><strong>为什么要使用线程池：</strong></p>
<ul>
<li>降低资源消耗</li>
<li>提高线程的可管理型</li>
</ul>
</li>
<li><p><strong>Executor的框架</strong></p>
<ul>
<li><p>架构图：<img alt="image-20200329173906204" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdaxprlphsj31g80s04aa.jpg" class="lazyload"></p>
</li>
<li><p>J.U.C下的三个Executor接口</p>
<ul>
<li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li>
<li>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务机制更完善</li>
<li>ScheduledExecutorService：支持Future和定期执行任务</li>
<li><strong>Executors：静态工厂方法</strong></li>
</ul>
</li>
<li><p>ThreadPoolExecutor：</p>
<ul>
<li><p>架构图<img alt="image-20200329174851761" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdaxzwvb5nj31b80qyqfu.jpg" class="lazyload"></p>
</li>
<li><p><strong>java.util.concurrent.ThreadPoolExecutor.Worker源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment"> * threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment"> * to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment"> * task execution.  This protects against interrupts that are</span></span><br><span class="line"><span class="comment"> * intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment"> * instead interrupting a task being run.  We implement a simple</span></span><br><span class="line"><span class="comment"> * non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment"> * ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment"> * reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment"> * setCorePoolSize.  Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment"> * the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment"> * state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment"> * runWorker).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor的构造函数</p>
<ul>
<li>corePoolSize :核心线程数量</li>
<li>maximumPoolSize :线程不够用时能够创建的最大线程数</li>
<li>workQueue :任务等待队列</li>
<li>keepAliveTime :抢占的顺序不- -定,看运气</li>
<li>threadFactory :创建新线程, Executors.defaultThreadFactory()</li>
<li>Handler：线程池的饱和策略<ul>
<li>AbortPolicy :直接抛出异常,这是默认策略</li>
<li>CallerRunsPolicy :用调用者所在的线程来执行任务</li>
<li>DiscardOldestPolicy :丟弃队列中靠最前的任务,并执行当前任务</li>
<li>DiscardPolicy :直接丢弃任务</li>
<li>实现RejectedExecutionHandler接口的自定义handler</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="线程池新任务提交execute执行后的流程"><a href="#线程池新任务提交execute执行后的流程" class="headerlink" title="线程池新任务提交execute执行后的流程"></a>线程池新任务提交execute执行后的流程</h3><ul>
<li>如果运行的线程少于corePoolSize ,则创建新线程来处理任务,即使线程池中的其他线程是空闲的;</li>
<li>如果线程池中的线程数量大于等于corePoolSize且小于</li>
<li>maximumPoolSize ,则只有当workQueue满时才创建新的线程去处理任务;</li>
<li>如果设置的corePoolSize和maximumPoolSize相同,则创建的线程池的大小是固定的,这时如果有新任务提交,若workQueue未满,则将请求放入workQueue中,等待有空闲的线程去从workQueue中取任务并处理;</li>
<li>如果运行的线程数量大于等于maximumPoolSize ,这时如果workQueue已经满了,则通过handler所指定的策略来处理任务;</li>
</ul>
<p><img alt="image-20200329180248591" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdayefcoidj317q0s810n.jpg" class="lazyload"></p>
<ul>
<li><p>优秀：源码分享：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这是在ThreadPoolExecutor下，管理线程生命周期，采用ctl变量通过位运算来得到当前线程池【线程的状态】和【可用线程的总数】。</p>
</li>
</ul>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><ul>
<li>RUNNING :能接受新提交的任务, 并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN :不再接受新提交的任务,但可以处理存量任务</li>
<li>STOP :不再接受新提交的任务,也不处理存量任务</li>
<li>TIDYING :所有的任务都已终止</li>
<li>TERMINATED : terminated()方法执行完后进入该状态</li>
</ul>
<p><img alt="image-20200329182505345" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdaz1lwdqoj323a0n27fn.jpg" class="lazyload"></p>
<h1 id="Java常用类库与技巧"><a href="#Java常用类库与技巧" class="headerlink" title="Java常用类库与技巧"></a>Java常用类库与技巧</h1><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>todo：学习org.springframework.core.NestedRuntimeException源码</li>
<li>todo：try-catch-finally的字节码，为什么finally比catch先运行</li>
<li>Todo： comparable重写的equal/hashcode/compareTo方法</li>
<li>TreeSet：自然排序（comparable）和客户化排序(Comparator)的优先级，后者更高</li>
</ul>
<h2 id="问题一：Java异常处理机制"><a href="#问题一：Java异常处理机制" class="headerlink" title="问题一：Java异常处理机制"></a>问题一：Java异常处理机制</h2><ul>
<li>What:异常类型回答了什么被抛出</li>
<li>where：异常堆栈跟踪回答了在哪抛出</li>
<li>why：异常信息回答了为什么抛出</li>
</ul>
<h3 id="Java异常的处理原则"><a href="#Java异常的处理原则" class="headerlink" title="Java异常的处理原则"></a>Java异常的处理原则</h3><ul>
<li>具体明确:抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因;</li>
<li>提早抛出:应尽可能早的发现并抛出异常,便于精确定位问题;</li>
<li>延迟捕获:异常的捕获和处理应尽可能延迟,让掌握更多信息的作用域来处理异常。</li>
</ul>
<h3 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h3><ul>
<li>Try-catch块影响jvm的优化。</li>
<li>异常对象实例需要保存栈快照等信息，开销比较达。</li>
</ul>
<h2 id="问题二：Error和Exception的区别"><a href="#问题二：Error和Exception的区别" class="headerlink" title="问题二：Error和Exception的区别"></a>问题二：Error和Exception的区别</h2><ul>
<li>结构图</li>
</ul>
<p><img alt="image-20200330072215022" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdblia9mbhj30vg0fsjup.jpg" class="lazyload"></p>
<ul>
<li>从概念角度解析Java的异常处理机制：<ul>
<li>Error :程序无法处理的系统错误（OOM）,编译器不做检查<ul>
<li>1.NoClassDefFoundError -找不到class定义的异常</li>
<li>2.StackOverflowError -深递归导致栈被耗尽而抛出的异常</li>
<li>3.OutOfMemoryError -内存溢出异常</li>
</ul>
</li>
<li>Exception :程序可以处理的异常,捕获后可能恢复<ul>
<li>RuntimeException（非受检异常）：不可预知的，程序应当自行避免（空指针、数组越界等）<ul>
<li>1.NullPointerException -空指针引用异常</li>
<li>2.ClassCastException -类型强制转换异常</li>
<li>3.IlegalArgumentException -传递非法参数异常</li>
<li>4.IndexOutOfBoundsException -下标越界异常</li>
<li>5.NumberFormatException -数字格式异常</li>
</ul>
</li>
<li>非RuntimeException（受检异常）：可预知的，从编译器校验的异常（IOException、ClassNotFoundException），主动去try-catch。一般业务异常</li>
</ul>
</li>
<li>总结:前者是程序无法处理的错误,后者是可以处理的异常</li>
</ul>
</li>
<li>从责任角度看：<ul>
<li>Error属于JVM需要负担的责任;</li>
<li>RuntimeException是程序应该负担的责任;</li>
<li>Checked Exception可检查异常是Java编译器应该负担的责任。</li>
</ul>
</li>
</ul>
<h2 id="问题三：设计高效主流的异常处理框架"><a href="#问题三：设计高效主流的异常处理框架" class="headerlink" title="问题三：设计高效主流的异常处理框架"></a>问题三：设计高效主流的异常处理框架</h2><ul>
<li><strong>在用户看来，应用系统发生的所有异常都是用用系统内部的异常</strong><ul>
<li>设计一个通用的继承自RuntimeException的异常来统一处理</li>
<li>其余异常都统一转译为上述异常AppException</li>
<li>在catch之后,抛出上述异常的子类,并提供足以定位的信息</li>
<li>由前端接受AppException做统一处理</li>
</ul>
</li>
<li>结构图<img alt="image-20200330075905154" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbmkkatftj312w0tcgx2.jpg" class="lazyload"></li>
</ul>
<h2 id="问题四：数据结构和算法"><a href="#问题四：数据结构和算法" class="headerlink" title="问题四：数据结构和算法"></a>问题四：数据结构和算法</h2><h3 id="数据结构常见考点："><a href="#数据结构常见考点：" class="headerlink" title="数据结构常见考点："></a>数据结构常见考点：</h3><ul>
<li>数组和链表的区别;</li>
<li>链表的操作,如反转,链表环路检测,双向链表,循环链表相关操作;</li>
<li>队列,栈的应用;</li>
<li>二叉树的遍历方式及其递归和非递归的实现; .</li>
<li>红黑树的旋转;</li>
</ul>
<h3 id="算法常见考点"><a href="#算法常见考点" class="headerlink" title="算法常见考点"></a>算法常见考点</h3><ul>
<li>内部排序:如递归排序、交换排序(冒泡、快排)、选择排序、 插入排序;</li>
<li>外部排序:应掌握如何利用有限的内存配合海量的外部存储来处理超大的数据集,写不出来也要有相关的思路。</li>
<li>扩展点：<ul>
<li>哪些排序是不稳定的, 稳定意味着什么</li>
<li>不同数据集,各种排序最好或最差的情况</li>
<li>如何优化算法</li>
</ul>
</li>
</ul>
<h2 id="问题五：Java集合框架"><a href="#问题五：Java集合框架" class="headerlink" title="问题五：Java集合框架"></a>问题五：Java集合框架</h2><ul>
<li>结构图<img alt="image-20200330081022924" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbmwbuw56j31220u0wy7.jpg" class="lazyload"></li>
<li>List和Set讲解<img alt="image-20200330081338924" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbmzpsv8mj31tu0no15s.jpg" class="lazyload"></li>
</ul>
<h2 id="问题六：Map讲解"><a href="#问题六：Map讲解" class="headerlink" title="问题六：Map讲解"></a>问题六：Map讲解</h2><ul>
<li>结构图：<img alt="image-20200330082553121" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdbncgc2bij31ep0u07lk.jpg" class="lazyload"></li>
<li></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/">http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/offer/">offer    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx22jv93j318k0p03zl.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwrhsmsvj312o0ljab7.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Noah最佳实践与踩坑</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>《数据结构与算法》-算法篇</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/12/17/2018-12-17-剑指JavaOffer/" title="剑指JavaOffer"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><div class="relatedPosts_title">剑指JavaOffer</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>