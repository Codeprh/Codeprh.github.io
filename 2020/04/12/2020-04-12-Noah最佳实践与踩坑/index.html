<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Noah最佳实践与踩坑 | Noah</title><meta name="description" content="Noah最佳实践与踩坑"><meta name="keywords" content="Noah最佳实践与踩坑"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Noah最佳实践与踩坑"><meta name="twitter:description" content="Noah最佳实践与踩坑"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwrhsmsvj312o0ljab7.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Noah最佳实践与踩坑"><meta property="og:url" content="http://yoursite.com/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="Noah最佳实践与踩坑"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwrhsmsvj312o0ljab7.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/"><link rel="prev" title="SpringFramework5.2.0源码阅读" href="http://yoursite.com/2020/06/27/2020-06-27-Spring%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/"><link rel="next" title="剑指Offer（完整版）" href="http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Noah-Java最佳实践与踩坑"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Noah-Java最佳实践与踩坑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Spring声明式事务最佳实践和踩坑"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Spring声明式事务最佳实践和踩坑</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小心Spring的事务可能没有生效"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">小心Spring的事务可能没有生效</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#请确认事务传播配置是否符合自己的业务逻辑"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">请确认事务传播配置是否符合自己的业务逻辑</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#HTTP调用-你考虑到超时、重试、并发了吗"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">HTTP调用:你考虑到超时、重试、并发了吗?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#配置连接超时和读取超时参数的学问"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">配置连接超时和读取超时参数的学问</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#连接超时参数和连接超时的误区有这么两个"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">连接超时参数和连接超时的误区有这么两个:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读取超时参数和读取超时则会有更多的误区"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">读取超时参数和读取超时则会有更多的误区</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Feign-和-Ribbon-配合使用，你知道怎么配置超时吗"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">Feign 和 Ribbon 配合使用，你知道怎么配置超时吗?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#配置大全"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">配置大全</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#你是否知道Ribbon会自动重试请求呢？"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">你是否知道Ribbon会自动重试请求呢？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发限制了爬虫的抓取能力"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">并发限制了爬虫的抓取能力</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据库索引-索引并不是万能药"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">数据库索引:索引并不是万能药</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#InnoDB是如何存储数据的"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">InnoDB是如何存储数据的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#聚簇索引和二级索引"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">聚簇索引和二级索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#考虑额外创建二级索引的代价"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">考虑额外创建二级索引的代价</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#索引开销最佳实践"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">索引开销最佳实践</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#不是所有针对索引列的查询都能用上索引"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">不是所有针对索引列的查询都能用上索引</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引失效的情况"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">索引失效的情况</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数据库基于成本决定是否走索引"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">数据库基于成本决定是否走索引</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#判等问题-程序里如何确定你就是你"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">判等问题:程序里如何确定你就是你?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意equals和-区别"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">注意equals和 == 区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#谈谈字符串equals和"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">谈谈字符串equals和 ==</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实现一个equals没有这么简单"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">实现一个equals没有这么简单</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意-compareTo-和-equals-的逻辑一致性"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">注意 compareTo 和 equals 的逻辑一致性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小心-Lombok-生成代码的坑"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">小心 Lombok 生成代码的坑</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数值计算-注意精度、舍入和溢出问题"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">数值计算:注意精度、舍入和溢出问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#危险的Double"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">危险的Double</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#考虑浮点数舍入和格式化的方式"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">考虑浮点数舍入和格式化的方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#用-equals-做判等，就一定是对的吗"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">用 equals 做判等，就一定是对的吗?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小心数值溢出问题"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">小心数值溢出问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#集合类-坑满地的List列表操作"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">集合类:坑满地的List列表操作</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-Arrays-asList-把数据转换为-List-的三个坑"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">使用 Arrays.asList 把数据转换为 List 的三个坑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-List-subList-进行切片操作居然会导致-OOM"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">使用 List.subList 进行切片操作居然会导致 OOM?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一定要让合适的数据结构做合适的事情"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">一定要让合适的数据结构做合适的事情</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-1"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#空值处理-分不清楚的null和恼人的空指针"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">空值处理:分不清楚的null和恼人的空指针</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#修复和定位恼人的空指针问题"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">修复和定位恼人的空指针问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#java线上定位问题：Arthas神器"><span class="toc_mobile_items-number">8.1.1.</span> <span class="toc_mobile_items-text">java线上定位问题：Arthas神器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#处理空指针-正确姿势"><span class="toc_mobile_items-number">8.1.2.</span> <span class="toc_mobile_items-text">处理空指针-正确姿势</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#POJO-中属性的-null-到底代表了什么"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">POJO 中属性的 null 到底代表了什么?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#定义POJO需要注意的五个问题"><span class="toc_mobile_items-number">8.2.1.</span> <span class="toc_mobile_items-text">定义POJO需要注意的五个问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小心-MySQL-中有关-NULL-的三个坑"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">小心 MySQL 中有关 NULL 的三个坑</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#异常处理-别让自己在出问题的时候变为瞎子"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">异常处理:别让自己在出问题的时候变为瞎子</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#捕获和处理异常容易犯的错"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">捕获和处理异常容易犯的错</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小心-finally-中的异常"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">小心 finally 中的异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#千万别把异常定义为静态变量"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">千万别把异常定义为静态变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#提交线程池的任务出了异常会怎么样"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">提交线程池的任务出了异常会怎么样?</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#日志-日志记录真没你想象的那么简单"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">日志:日志记录真没你想象的那么简单</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么我的日志会重复记录？"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">为什么我的日志会重复记录？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用异步日志改善性能的坑"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">使用异步日志改善性能的坑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用日志占位符就不需要进行日志级别判断了"><span class="toc_mobile_items-number">10.3.</span> <span class="toc_mobile_items-text">使用日志占位符就不需要进行日志级别判断了?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-2"><span class="toc_mobile_items-number">10.4.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#文件IO-实现高效正确的文件读写并非易事"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">文件IO:实现高效正确的文件读写并非易事</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件读写需要确保字符编码一致"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">文件读写需要确保字符编码一致</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-Files-类静态方法进行文件操作注意释放文件句柄"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">使用 Files 类静态方法进行文件操作注意释放文件句柄</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#try-with-resources语法糖"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">try-with-resources语法糖</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意读写文件要考虑设置缓冲区"><span class="toc_mobile_items-number">11.4.</span> <span class="toc_mobile_items-text">注意读写文件要考虑设置缓冲区</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-3"><span class="toc_mobile_items-number">11.5.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java8科普篇一"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">Java8科普篇一</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Lambda-表达式"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">Lambda 表达式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用Java8简化代码"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">使用Java8简化代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Optional方法图解"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">Optional方法图解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java-8-类对于函数式-API-增强"><span class="toc_mobile_items-number">12.4.</span> <span class="toc_mobile_items-text">Java 8 类对于函数式 API 增强</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行流和Java多线程实现"><span class="toc_mobile_items-number">12.5.</span> <span class="toc_mobile_items-text">并行流和Java多线程实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java8科普篇二"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">Java8科普篇二</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Stream操作详解"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text">Stream操作详解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#场景栗子"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text">场景栗子</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建流"><span class="toc_mobile_items-number">13.2.1.</span> <span class="toc_mobile_items-text">创建流</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#filter"><span class="toc_mobile_items-number">13.2.2.</span> <span class="toc_mobile_items-text">filter</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#map"><span class="toc_mobile_items-number">13.2.3.</span> <span class="toc_mobile_items-text">map</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#flatMap"><span class="toc_mobile_items-number">13.2.4.</span> <span class="toc_mobile_items-text">flatMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sorted"><span class="toc_mobile_items-number">13.2.5.</span> <span class="toc_mobile_items-text">sorted</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#distinct"><span class="toc_mobile_items-number">13.2.6.</span> <span class="toc_mobile_items-text">distinct</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#skip-amp-limit"><span class="toc_mobile_items-number">13.2.7.</span> <span class="toc_mobile_items-text">skip &amp; limit</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#collect"><span class="toc_mobile_items-number">13.2.8.</span> <span class="toc_mobile_items-text">collect</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#groupBy"><span class="toc_mobile_items-number">13.2.9.</span> <span class="toc_mobile_items-text">groupBy</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#partitioningBy"><span class="toc_mobile_items-number">13.2.10.</span> <span class="toc_mobile_items-text">partitioningBy</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#连接池-别让连接池帮了倒忙"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">连接池:别让连接池帮了倒忙</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意鉴别客户端-SDK-是否基于连接池"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text">注意鉴别客户端 SDK 是否基于连接池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用连接池务必确保复用"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text">使用连接池务必确保复用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Wireshark分析Http连接池"><span class="toc_mobile_items-number">14.2.1.</span> <span class="toc_mobile_items-text">Wireshark分析Http连接池</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#连接池的配置不是一成不变的"><span class="toc_mobile_items-number">14.3.</span> <span class="toc_mobile_items-text">连接池的配置不是一成不变的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-4"><span class="toc_mobile_items-number">14.4.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#序列化-一来一回你还是原来的你吗"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">序列化:一来一回你还是原来的你吗?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#序列化和反序列化需要确保算法一致"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">序列化和反序列化需要确保算法一致</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text">TODO</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#分析定位Java问题，一定要用好这些工具（一）"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">分析定位Java问题，一定要用好这些工具（一）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-JDK-自带工具查看-JVM-情况"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text">使用 JDK 自带工具查看 JVM 情况</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-Wireshark-分析-SQL-批量插入慢的问题"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text">使用 Wireshark 分析 SQL 批量插入慢的问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#分析定位Java问题，一定要用好这些工具-二"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">分析定位Java问题，一定要用好这些工具(二)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用MAT分析OOM问题"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text">使用MAT分析OOM问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用-Arthas-分析高-CPU-问题"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text">使用 Arthas 分析高 CPU 问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题TODO"><span class="toc_mobile_items-number">17.3.</span> <span class="toc_mobile_items-text">问题TODO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-5"><span class="toc_mobile_items-number">17.4.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#当反射、注解和泛型遇到OOP时，会有哪些坑"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">当反射、注解和泛型遇到OOP时，会有哪些坑?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#反射调用方法不是以传参决定重载"><span class="toc_mobile_items-number">18.1.</span> <span class="toc_mobile_items-text">反射调用方法不是以传参决定重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TODO：泛型经过类型擦除多出桥接方法的坑"><span class="toc_mobile_items-number">18.2.</span> <span class="toc_mobile_items-text">TODO：泛型经过类型擦除多出桥接方法的坑</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注解可以继承吗？"><span class="toc_mobile_items-number">18.3.</span> <span class="toc_mobile_items-text">注解可以继承吗？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点回顾-6"><span class="toc_mobile_items-number">18.4.</span> <span class="toc_mobile_items-text">重点回顾</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Spring框架-IoC和AOP是扩展的核心"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">Spring框架:IoC和AOP是扩展的核心</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单例的Bean如何注入Prototype的Bean？"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text">单例的Bean如何注入Prototype的Bean？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#监控切面因为顺序问题导致-Spring-事务失效"><span class="toc_mobile_items-number">19.2.</span> <span class="toc_mobile_items-text">监控切面因为顺序问题导致 Spring 事务失效</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重点总结"><span class="toc_mobile_items-number">19.3.</span> <span class="toc_mobile_items-text">重点总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Spring框架-框架帮我们做了很多工作也带来了复杂度"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">Spring框架:框架帮我们做了很多工作也带来了复杂度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Feign-AOP-切不到的诡异案例"><span class="toc_mobile_items-number">20.1.</span> <span class="toc_mobile_items-text">Feign AOP 切不到的诡异案例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring程序配置的优先级问题"><span class="toc_mobile_items-number">20.2.</span> <span class="toc_mobile_items-text">Spring程序配置的优先级问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#思考和讨论"><span class="toc_mobile_items-number">20.3.</span> <span class="toc_mobile_items-text">思考和讨论</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Noah-Java最佳实践与踩坑"><span class="toc-number">1.</span> <span class="toc-text">Noah-Java最佳实践与踩坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring声明式事务最佳实践和踩坑"><span class="toc-number">2.</span> <span class="toc-text">Spring声明式事务最佳实践和踩坑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#小心Spring的事务可能没有生效"><span class="toc-number">2.1.</span> <span class="toc-text">小心Spring的事务可能没有生效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请确认事务传播配置是否符合自己的业务逻辑"><span class="toc-number">2.2.</span> <span class="toc-text">请确认事务传播配置是否符合自己的业务逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP调用-你考虑到超时、重试、并发了吗"><span class="toc-number">3.</span> <span class="toc-text">HTTP调用:你考虑到超时、重试、并发了吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置连接超时和读取超时参数的学问"><span class="toc-number">3.1.</span> <span class="toc-text">配置连接超时和读取超时参数的学问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连接超时参数和连接超时的误区有这么两个"><span class="toc-number">3.1.1.</span> <span class="toc-text">连接超时参数和连接超时的误区有这么两个:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取超时参数和读取超时则会有更多的误区"><span class="toc-number">3.1.2.</span> <span class="toc-text">读取超时参数和读取超时则会有更多的误区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign-和-Ribbon-配合使用，你知道怎么配置超时吗"><span class="toc-number">3.2.</span> <span class="toc-text">Feign 和 Ribbon 配合使用，你知道怎么配置超时吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置大全"><span class="toc-number">3.2.1.</span> <span class="toc-text">配置大全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你是否知道Ribbon会自动重试请求呢？"><span class="toc-number">3.3.</span> <span class="toc-text">你是否知道Ribbon会自动重试请求呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发限制了爬虫的抓取能力"><span class="toc-number">3.4.</span> <span class="toc-text">并发限制了爬虫的抓取能力</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库索引-索引并不是万能药"><span class="toc-number">4.</span> <span class="toc-text">数据库索引:索引并不是万能药</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB是如何存储数据的"><span class="toc-number">4.1.</span> <span class="toc-text">InnoDB是如何存储数据的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聚簇索引和二级索引"><span class="toc-number">4.2.</span> <span class="toc-text">聚簇索引和二级索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑额外创建二级索引的代价"><span class="toc-number">4.3.</span> <span class="toc-text">考虑额外创建二级索引的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引开销最佳实践"><span class="toc-number">4.4.</span> <span class="toc-text">索引开销最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不是所有针对索引列的查询都能用上索引"><span class="toc-number">4.5.</span> <span class="toc-text">不是所有针对索引列的查询都能用上索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引失效的情况"><span class="toc-number">4.5.1.</span> <span class="toc-text">索引失效的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库基于成本决定是否走索引"><span class="toc-number">4.6.</span> <span class="toc-text">数据库基于成本决定是否走索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判等问题-程序里如何确定你就是你"><span class="toc-number">5.</span> <span class="toc-text">判等问题:程序里如何确定你就是你?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注意equals和-区别"><span class="toc-number">5.1.</span> <span class="toc-text">注意equals和 == 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈谈字符串equals和"><span class="toc-number">5.2.</span> <span class="toc-text">谈谈字符串equals和 ==</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现一个equals没有这么简单"><span class="toc-number">5.3.</span> <span class="toc-text">实现一个equals没有这么简单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意-compareTo-和-equals-的逻辑一致性"><span class="toc-number">5.4.</span> <span class="toc-text">注意 compareTo 和 equals 的逻辑一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小心-Lombok-生成代码的坑"><span class="toc-number">5.5.</span> <span class="toc-text">小心 Lombok 生成代码的坑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值计算-注意精度、舍入和溢出问题"><span class="toc-number">6.</span> <span class="toc-text">数值计算:注意精度、舍入和溢出问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#危险的Double"><span class="toc-number">6.1.</span> <span class="toc-text">危险的Double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑浮点数舍入和格式化的方式"><span class="toc-number">6.2.</span> <span class="toc-text">考虑浮点数舍入和格式化的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用-equals-做判等，就一定是对的吗"><span class="toc-number">6.3.</span> <span class="toc-text">用 equals 做判等，就一定是对的吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小心数值溢出问题"><span class="toc-number">6.4.</span> <span class="toc-text">小心数值溢出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾"><span class="toc-number">6.5.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合类-坑满地的List列表操作"><span class="toc-number">7.</span> <span class="toc-text">集合类:坑满地的List列表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Arrays-asList-把数据转换为-List-的三个坑"><span class="toc-number">7.1.</span> <span class="toc-text">使用 Arrays.asList 把数据转换为 List 的三个坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-List-subList-进行切片操作居然会导致-OOM"><span class="toc-number">7.2.</span> <span class="toc-text">使用 List.subList 进行切片操作居然会导致 OOM?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一定要让合适的数据结构做合适的事情"><span class="toc-number">7.3.</span> <span class="toc-text">一定要让合适的数据结构做合适的事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-1"><span class="toc-number">7.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#空值处理-分不清楚的null和恼人的空指针"><span class="toc-number">8.</span> <span class="toc-text">空值处理:分不清楚的null和恼人的空指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#修复和定位恼人的空指针问题"><span class="toc-number">8.1.</span> <span class="toc-text">修复和定位恼人的空指针问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java线上定位问题：Arthas神器"><span class="toc-number">8.1.1.</span> <span class="toc-text">java线上定位问题：Arthas神器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理空指针-正确姿势"><span class="toc-number">8.1.2.</span> <span class="toc-text">处理空指针-正确姿势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POJO-中属性的-null-到底代表了什么"><span class="toc-number">8.2.</span> <span class="toc-text">POJO 中属性的 null 到底代表了什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义POJO需要注意的五个问题"><span class="toc-number">8.2.1.</span> <span class="toc-text">定义POJO需要注意的五个问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小心-MySQL-中有关-NULL-的三个坑"><span class="toc-number">8.3.</span> <span class="toc-text">小心 MySQL 中有关 NULL 的三个坑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异常处理-别让自己在出问题的时候变为瞎子"><span class="toc-number">9.</span> <span class="toc-text">异常处理:别让自己在出问题的时候变为瞎子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获和处理异常容易犯的错"><span class="toc-number">9.1.</span> <span class="toc-text">捕获和处理异常容易犯的错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小心-finally-中的异常"><span class="toc-number">9.2.</span> <span class="toc-text">小心 finally 中的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#千万别把异常定义为静态变量"><span class="toc-number">9.3.</span> <span class="toc-text">千万别把异常定义为静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交线程池的任务出了异常会怎么样"><span class="toc-number">9.4.</span> <span class="toc-text">提交线程池的任务出了异常会怎么样?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#日志-日志记录真没你想象的那么简单"><span class="toc-number">10.</span> <span class="toc-text">日志:日志记录真没你想象的那么简单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么我的日志会重复记录？"><span class="toc-number">10.1.</span> <span class="toc-text">为什么我的日志会重复记录？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用异步日志改善性能的坑"><span class="toc-number">10.2.</span> <span class="toc-text">使用异步日志改善性能的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用日志占位符就不需要进行日志级别判断了"><span class="toc-number">10.3.</span> <span class="toc-text">使用日志占位符就不需要进行日志级别判断了?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-2"><span class="toc-number">10.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件IO-实现高效正确的文件读写并非易事"><span class="toc-number">11.</span> <span class="toc-text">文件IO:实现高效正确的文件读写并非易事</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件读写需要确保字符编码一致"><span class="toc-number">11.1.</span> <span class="toc-text">文件读写需要确保字符编码一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Files-类静态方法进行文件操作注意释放文件句柄"><span class="toc-number">11.2.</span> <span class="toc-text">使用 Files 类静态方法进行文件操作注意释放文件句柄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resources语法糖"><span class="toc-number">11.3.</span> <span class="toc-text">try-with-resources语法糖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意读写文件要考虑设置缓冲区"><span class="toc-number">11.4.</span> <span class="toc-text">注意读写文件要考虑设置缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-3"><span class="toc-number">11.5.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8科普篇一"><span class="toc-number">12.</span> <span class="toc-text">Java8科普篇一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-表达式"><span class="toc-number">12.1.</span> <span class="toc-text">Lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Java8简化代码"><span class="toc-number">12.2.</span> <span class="toc-text">使用Java8简化代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optional方法图解"><span class="toc-number">12.3.</span> <span class="toc-text">Optional方法图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8-类对于函数式-API-增强"><span class="toc-number">12.4.</span> <span class="toc-text">Java 8 类对于函数式 API 增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行流和Java多线程实现"><span class="toc-number">12.5.</span> <span class="toc-text">并行流和Java多线程实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8科普篇二"><span class="toc-number">13.</span> <span class="toc-text">Java8科普篇二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream操作详解"><span class="toc-number">13.1.</span> <span class="toc-text">Stream操作详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#场景栗子"><span class="toc-number">13.2.</span> <span class="toc-text">场景栗子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建流"><span class="toc-number">13.2.1.</span> <span class="toc-text">创建流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">13.2.2.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">13.2.3.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-number">13.2.4.</span> <span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted"><span class="toc-number">13.2.5.</span> <span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#distinct"><span class="toc-number">13.2.6.</span> <span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skip-amp-limit"><span class="toc-number">13.2.7.</span> <span class="toc-text">skip &amp; limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collect"><span class="toc-number">13.2.8.</span> <span class="toc-text">collect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#groupBy"><span class="toc-number">13.2.9.</span> <span class="toc-text">groupBy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partitioningBy"><span class="toc-number">13.2.10.</span> <span class="toc-text">partitioningBy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连接池-别让连接池帮了倒忙"><span class="toc-number">14.</span> <span class="toc-text">连接池:别让连接池帮了倒忙</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注意鉴别客户端-SDK-是否基于连接池"><span class="toc-number">14.1.</span> <span class="toc-text">注意鉴别客户端 SDK 是否基于连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用连接池务必确保复用"><span class="toc-number">14.2.</span> <span class="toc-text">使用连接池务必确保复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Wireshark分析Http连接池"><span class="toc-number">14.2.1.</span> <span class="toc-text">Wireshark分析Http连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接池的配置不是一成不变的"><span class="toc-number">14.3.</span> <span class="toc-text">连接池的配置不是一成不变的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-4"><span class="toc-number">14.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化-一来一回你还是原来的你吗"><span class="toc-number">15.</span> <span class="toc-text">序列化:一来一回你还是原来的你吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化和反序列化需要确保算法一致"><span class="toc-number">15.1.</span> <span class="toc-text">序列化和反序列化需要确保算法一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-number">15.2.</span> <span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分析定位Java问题，一定要用好这些工具（一）"><span class="toc-number">16.</span> <span class="toc-text">分析定位Java问题，一定要用好这些工具（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-JDK-自带工具查看-JVM-情况"><span class="toc-number">16.1.</span> <span class="toc-text">使用 JDK 自带工具查看 JVM 情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Wireshark-分析-SQL-批量插入慢的问题"><span class="toc-number">16.2.</span> <span class="toc-text">使用 Wireshark 分析 SQL 批量插入慢的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分析定位Java问题，一定要用好这些工具-二"><span class="toc-number">17.</span> <span class="toc-text">分析定位Java问题，一定要用好这些工具(二)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用MAT分析OOM问题"><span class="toc-number">17.1.</span> <span class="toc-text">使用MAT分析OOM问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Arthas-分析高-CPU-问题"><span class="toc-number">17.2.</span> <span class="toc-text">使用 Arthas 分析高 CPU 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题TODO"><span class="toc-number">17.3.</span> <span class="toc-text">问题TODO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-5"><span class="toc-number">17.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#当反射、注解和泛型遇到OOP时，会有哪些坑"><span class="toc-number">18.</span> <span class="toc-text">当反射、注解和泛型遇到OOP时，会有哪些坑?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#反射调用方法不是以传参决定重载"><span class="toc-number">18.1.</span> <span class="toc-text">反射调用方法不是以传参决定重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO：泛型经过类型擦除多出桥接方法的坑"><span class="toc-number">18.2.</span> <span class="toc-text">TODO：泛型经过类型擦除多出桥接方法的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解可以继承吗？"><span class="toc-number">18.3.</span> <span class="toc-text">注解可以继承吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-6"><span class="toc-number">18.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring框架-IoC和AOP是扩展的核心"><span class="toc-number">19.</span> <span class="toc-text">Spring框架:IoC和AOP是扩展的核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单例的Bean如何注入Prototype的Bean？"><span class="toc-number">19.1.</span> <span class="toc-text">单例的Bean如何注入Prototype的Bean？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监控切面因为顺序问题导致-Spring-事务失效"><span class="toc-number">19.2.</span> <span class="toc-text">监控切面因为顺序问题导致 Spring 事务失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点总结"><span class="toc-number">19.3.</span> <span class="toc-text">重点总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring框架-框架帮我们做了很多工作也带来了复杂度"><span class="toc-number">20.</span> <span class="toc-text">Spring框架:框架帮我们做了很多工作也带来了复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign-AOP-切不到的诡异案例"><span class="toc-number">20.1.</span> <span class="toc-text">Feign AOP 切不到的诡异案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring程序配置的优先级问题"><span class="toc-number">20.2.</span> <span class="toc-text">Spring程序配置的优先级问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思考和讨论"><span class="toc-number">20.3.</span> <span class="toc-text">思考和讨论</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Noah最佳实践与踩坑</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-22</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/">Noah最佳实践与踩坑</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">52.5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 208 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="Noah-Java最佳实践与踩坑"><a href="#Noah-Java最佳实践与踩坑" class="headerlink" title="Noah-Java最佳实践与踩坑"></a>Noah-Java最佳实践与踩坑</h1><h1 id="Spring声明式事务最佳实践和踩坑"><a href="#Spring声明式事务最佳实践和踩坑" class="headerlink" title="Spring声明式事务最佳实践和踩坑"></a>Spring声明式事务最佳实践和踩坑</h1><p>大多数业务开发同学都有事务的概念，也知道如果整体考虑多个数据库操作要么成功要么失败时，需要通过数据库事务来实现多个操作的一致性和原子性。但，在使用.上大多仅限于为方法标记@Transactional,不会去关注事务是否有效、出错后事务是否正确回滚，也不会考虑复杂的业务代码中涉及多个子业务逻辑时，怎么正确处理事务。</p>
<p><a href="https://github.com/JosephZhu1983/java-common-mistakes/tree/master/src/main/java/org/geekbang/time/commonmistakes/transaction" target="_blank" rel="noopener">代码源码链接</a></p>
<h2 id="小心Spring的事务可能没有生效"><a href="#小心Spring的事务可能没有生效" class="headerlink" title="小心Spring的事务可能没有生效"></a>小心Spring的事务可能没有生效</h2><ul>
<li>@Transactional 生效原则 1：<strong>除非特殊配置(比如使用 AspectJ 静态织入实现 AOP)，否则只有定义在 public 方法上的 @Transactional 才能生效</strong>。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到， Spring 自然也无法动态增强事务处理逻辑。</li>
<li>@Transactional 生效原则 2：<strong>必须通过代理过的类从外部调用目标方法才能生效</strong>。<ul>
<li>CGLIB 通过继承方式实现代理类，private 方法在子类不可见，自然也就无法进行事务增 强;</li>
<li>this 指针代表对象自己，Spring 不可能注入 this，所以通过 this 访问方法必然不是代 理。</li>
</ul>
</li>
<li>一张图来回顾下 this 自调用、通过 self 调用，以及在 Controller 中调用 UserService 三种实现的区别</li>
</ul>
<p><img alt="image-20200412164414016" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr2t12koij31du0mh0wp.jpg" class="lazyload"></p>
<ul>
<li><p><strong>强烈建议你在开发时打开相关的 Debug 日志，以方便了解 Spring 事务实现的细节，并及时判断事务的执行情况</strong>。</p>
<ul>
<li><p>logging.level.org.springframework.orm.jpa=DEBUG</p>
</li>
<li><pre><code class="java">#this方式：在调用数据库的时候才开启了事务
[<span class="number">16</span>:<span class="number">49</span>:<span class="number">59.654</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">3</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">370</span> ] - Creating <span class="keyword">new</span> transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT

#标准controller方式，开始事务地方正是@Transaction定义的地方
[<span class="number">16</span>:<span class="number">48</span>:<span class="number">51.021</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">1</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">370</span> ] - Creating <span class="keyword">new</span> transaction with name [org.geekbang.time.commonmistakes.transaction.transactionproxyfailed.UserService.createUserPublic]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="请确认事务传播配置是否符合自己的业务逻辑"><a href="#请确认事务传播配置是否符合自己的业务逻辑" class="headerlink" title="请确认事务传播配置是否符合自己的业务逻辑"></a>请确认事务传播配置是否符合自己的业务逻辑</h2><p>在有些业务逻辑中，可能 会包含多次数据库操作，我们不一定希望将两次操作作为一个事务来处理，这时候就需要仔 细考虑事务传播的配置了，否则也可能踩坑。</p>
<p>有一个场景:一个用户注册的操作，会插入一个主用户到用户表，还会注册一个关联的 子用户。我们希望将子用户注册的数据库操作作为一个独立事务来处理，即使失败也不会影 响主流程，即不影响主用户的注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如第 1 行所示，对 createUserWrong2 方法开启了异常处理;</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.113</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">471</span> ] - Participating in existing transaction</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.114</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [INFO ] [o.g.t.c.t.t.SubUserService:<span class="number">19</span>  ] - createSubUserWithExceptionWrong start</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.115</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">356</span> ] - Found thread-bound EntityManager [SessionImpl(<span class="number">537757195</span>&lt;open&gt;)] <span class="keyword">for</span> JPA transaction</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.116</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">471</span> ] - Participating in existing transaction</span><br><span class="line"><span class="comment">//如第 5 行所示，子方法因为出现了运行时异常，标记当前事务为回滚;</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.117</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">843</span> ] - Participating transaction failed - marking existing transaction as rollback-only</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.118</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">580</span> ] - Setting JPA transaction on EntityManager [SessionImpl(<span class="number">537757195</span>&lt;open&gt;)] rollback-only</span><br><span class="line"><span class="comment">//如第 7 行所示，主方法的确捕获了异常打印出了 create sub user error 字样;</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.118</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [ERROR] [o.g.t.c.t.t.UserService:<span class="number">37</span>  ] - create sub user error:invalid status</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.119</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">741</span> ] - Initiating transaction commit</span><br><span class="line"><span class="comment">//如第 9 行所示，主方法提交了事务;</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.119</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">529</span> ] - Committing JPA transaction on EntityManager [SessionImpl(<span class="number">537757195</span>&lt;open&gt;)]</span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.122</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [DEBUG] [o.s.orm.jpa.JpaTransactionManager:<span class="number">620</span> ] - Closing JPA EntityManager [SessionImpl(<span class="number">537757195</span>&lt;open&gt;)] after transaction</span><br><span class="line"></span><br><span class="line">[<span class="number">17</span>:<span class="number">42</span>:<span class="number">00.123</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">6</span>] [ERROR] [o.g.t.c.t.t.TransactionPropagationController:<span class="number">33</span>  ] - createUserWrong2 failed, reason:Transaction silently rolled back because it has been marked as rollback-only</span><br><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>

<ul>
<li>奇怪的是，如第 11 行和 12 行所示，<strong>Controller 里出现了一个 UnexpectedRollbackException，异常描述提示最终这个事务回滚了，而且是静默回 滚的</strong>。之所以说是静默，是因为 createUserWrong2 方法本身并没有出异常，只不过提 交后发现子方法已经把当前事务设置为了回滚，无法完成提交。</li>
<li>解决方案：<ul>
<li>修复方式就很明确了，想办法让子逻辑在独立事务中运行，也就是改一下 SubUserService 注册子用户的方法。</li>
<li>为注解加上 propagation = Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执 行到这个方法时需要开启新的事务，并挂起当前事务</li>
<li>@Transactional(propagation = Propagation.REQUIRES_NEW)</li>
</ul>
</li>
</ul>
<h1 id="HTTP调用-你考虑到超时、重试、并发了吗"><a href="#HTTP调用-你考虑到超时、重试、并发了吗" class="headerlink" title="HTTP调用:你考虑到超时、重试、并发了吗?"></a>HTTP调用:你考虑到超时、重试、并发了吗?</h1><p><a href="https://github.com/JosephZhu1983/java-common-mistakes/blob/master/src/main/java/org/geekbang/time/commonmistakes/httpinvoke/ribbonretry/CommonMistakesApplication.java" target="_blank" rel="noopener">源码链接</a></p>
<p>进行 HTTP 调用本质上是通过 HTTP 协议进行一次网络请求。网络 请求必然有超时的可能性，因此我们必须考虑到这三点:</p>
<ol>
<li>框架设置的默认超时是否合理;</li>
<li>考虑到网络的不稳定，超时后的请求重试是一个不错的选择，但需要考虑服务端 接口的幂等性设计是否允许我们重试;</li>
<li>需要考虑框架是否会像浏览器那样限制并发连接数，以免在服务并发很大的情况 下，HTTP 调用的并发数限制成为瓶颈。</li>
</ol>
<p>如果使用 Spring Cloud 进行微服务开 发，就会使用 Feign 进行声明式的服务调用。</p>
<p>如果使用 Java 中最常用的 HTTP 客户端 Apache HttpClient 进行服务调用。</p>
<h2 id="配置连接超时和读取超时参数的学问"><a href="#配置连接超时和读取超时参数的学问" class="headerlink" title="配置连接超时和读取超时参数的学问"></a>配置连接超时和读取超时参数的学问</h2><p>对于 HTTP 调用，虽然应用层走的是 HTTP 协议，但网络层面始终是 TCP/IP 协议。 TCP/IP 是面向连接的协议，在传输数据之前需要建立连接。几乎所有的网络框架都会提供 这么两个超时参数:</p>
<ol>
<li>连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间;</li>
<li>读取超时参数 ReadTimeout，用来控制从 Socket 上读取数据的最长等待时间。</li>
</ol>
<h3 id="连接超时参数和连接超时的误区有这么两个"><a href="#连接超时参数和连接超时的误区有这么两个" class="headerlink" title="连接超时参数和连接超时的误区有这么两个:"></a>连接超时参数和连接超时的误区有这么两个:</h3><ol>
<li><strong>连接超时配置得特别长，比如 60 秒。</strong>TCP 三次握手建立连接需要的时间非 常短，通常在毫秒级最多到秒级。（1-5秒）即可</li>
<li><strong>排查连接超时问题，却没理清连的是哪里。</strong></li>
</ol>
<h3 id="读取超时参数和读取超时则会有更多的误区"><a href="#读取超时参数和读取超时则会有更多的误区" class="headerlink" title="读取超时参数和读取超时则会有更多的误区"></a><strong>读取超时参数和读取超时则会有更多的误区</strong></h3><ol>
<li><strong>第一个误区:</strong>认为出现了读取超时，服务端的执行就会中断。</li>
<li><strong>第二个误区:</strong>认为读取超时只是 Socket 网络层面的概念，是数据传输的最长耗时，故将其 配置得非常短，比如 100 毫秒。大部门时间是服务端处理业务逻辑的时间。</li>
<li><strong>第三个误区:</strong>认为超时时间越长任务接口成功率就越高，将读取超时参数配置得太长。<ul>
<li>对定时任务或异步任务来说，读取超时配置得长些问题不大。</li>
<li>但面向用户响应的请求或是微 服务短平快的同步接口调用，并发量一般较大，我们应该设置一个较短的读取超时时间，以 防止被下游服务拖慢，通常不会设置超过 30 秒的读取超时。</li>
</ul>
</li>
</ol>
<h2 id="Feign-和-Ribbon-配合使用，你知道怎么配置超时吗"><a href="#Feign-和-Ribbon-配合使用，你知道怎么配置超时吗" class="headerlink" title="Feign 和 Ribbon 配合使用，你知道怎么配置超时吗?"></a><strong>Feign</strong> <strong>和</strong> <strong>Ribbon</strong> <strong>配合使用，你知道怎么配置超时吗?</strong></h2><ol>
<li><p><strong>结论一，默认情况下 Feign 的读取超时是 1 秒，如此短的读 取超时算是坑点一</strong>。</p>
<ul>
<li><p>源码分析：org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration#ribbonClientConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ribbon client default connect timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONNECT_TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ribbon client default read timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_READ_TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ribbon client default Gzip Payload flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_GZIP_PAYLOAD = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RibbonClientName</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">"client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line"><span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">   config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line">   config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">   config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);</span><br><span class="line">   config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);</span><br><span class="line">   <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>结论二，也是坑点二，如果要配置 Feign 的读取超时，就必须同时配置连接超时，才能生 效</strong>。</p>
<ul>
<li><p>源码分析：org.springframework.cloud.openfeign.FeignClientFactoryBean#configureUsingProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (config.getConnectTimeout() != null &amp;&amp; config.getReadTimeout() != null) &#123;</span><br><span class="line">	builder.options(new Request.Options(config.getConnectTimeout(),</span><br><span class="line">			config.getReadTimeout()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>结论三，单独的超时可以覆盖全局超时，这符合预期，不算坑</strong>:</p>
</li>
<li><p><strong>结论四，除了可以配置 Feign，也可以配置 Ribbon 组件的参数来修改两个超时时间。这 里的坑点三是，参数首字母要大写，和 Feign 的配置不同</strong>。</p>
</li>
<li><p><strong>结论五，同时配置 Feign 和 Ribbon 的超时，以 Feign 为准</strong>。</p>
<ul>
<li><p>源码分析：org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient#getClientConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IClientConfig <span class="title">getClientConfig</span><span class="params">(Request.Options options, String clientName)</span> </span>&#123;</span><br><span class="line">	IClientConfig requestConfig;</span><br><span class="line">	<span class="keyword">if</span> (options == DEFAULT_OPTIONS) &#123;</span><br><span class="line">		requestConfig = <span class="keyword">this</span>.clientFactory.getClientConfig(clientName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		requestConfig = <span class="keyword">new</span> FeignOptionsClientConfig(options);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> requestConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="配置大全"><a href="#配置大全" class="headerlink" title="配置大全"></a>配置大全</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># fegin默认读取超时配置和链接超时配置</span><br><span class="line">feign.client.config.default.readTimeout=3000</span><br><span class="line">feign.client.config.default.connectTimeout=3000</span><br><span class="line"></span><br><span class="line"># fegin指定服务读取超时配置和链接超时配置</span><br><span class="line">feign.client.config.clientsdk.readTimeout=2000</span><br><span class="line">feign.client.config.clientsdk.connectTimeout=2000</span><br><span class="line"></span><br><span class="line"># ribbon默认读取超时配置和链接超时配置</span><br><span class="line">ribbon.ReadTimeout=4000</span><br><span class="line">ribbon.ConnectTimeout=4000</span><br><span class="line"></span><br><span class="line"># ribbon指定服务读取超时配置和链接超时配置</span><br><span class="line">clientsdk.ribbon.ReadTimeout=5000</span><br><span class="line">clientsdk.ribbon.ConnectTimeout=5000</span><br><span class="line"></span><br><span class="line"># 讲ribbon的get请求失败重试次数关闭</span><br><span class="line">ribbon.MaxAutoRetriesNextServer=0</span><br></pre></td></tr></table></figure>

<h2 id="你是否知道Ribbon会自动重试请求呢？"><a href="#你是否知道Ribbon会自动重试请求呢？" class="headerlink" title="你是否知道Ribbon会自动重试请求呢？"></a>你是否知道Ribbon会自动重试请求呢？</h2><ul>
<li><p><strong>显然，这说明客户端自作主张进 行了一次重试(GET请求)，导致短信重复发送。</strong></p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.client.config.DefaultClientConfigImpl</span><br><span class="line"><span class="comment">//MaxAutoRetriesNextServer 参数默认为 1，也就是 Get 请求在某个服务端节点出现问题(比如读取超时)时，Ribbon 会自动重试一次:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_AUTO_RETRIES = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">org.springframework.cloud.netflix.ribbon.RibbonLoadBalancedRetryPolicy</span><br><span class="line">getMaxRetriesOnNextServer==DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<ol>
<li>把发短信接口从 Get 改为 Post。其实，这里还有一个 API 设计问题，有状态的 API 接口不应该定义为 Get。根据 HTTP 协议的规范，Get 请求用于数据查询（无状态，幂等），而 Post 才是把数据提交到服务端用于修改或新增。选择 Get 还是 Post 的依据，应该是 API 的 行为，而不是参数大小。<strong>这里的一个误区是，Get 请求的参数包含在 Url QueryString中，会受浏览器长度限制，所以一些同学会选择使用 JSON 以 Post 提交大参数，使用 Get 提交小参数。</strong></li>
<li>将 MaxAutoRetriesNextServer 参数配置为 0，禁用服务调用失败后在下一个服 务端节点的自动重试。在配置文件中添加一行即可。（todo：源码实现）</li>
</ol>
</li>
</ul>
<h2 id="并发限制了爬虫的抓取能力"><a href="#并发限制了爬虫的抓取能力" class="headerlink" title="并发限制了爬虫的抓取能力"></a>并发限制了爬虫的抓取能力</h2><ul>
<li><p>源码分析：org.apache.http.impl.conn.PoolingHttpClientConnectionManager构造器。</p>
<ul>
<li><p>关键两个参数，final int defaultMaxPerRoute, final int maxTotal</p>
</li>
<li><p><strong>defaultMaxPerRoute=2，也就是同一个主机 / 域名的最大并发请求数为 2。我们的爬 虫需要 10 个并发，显然是默认值太小限制了爬虫的效率。</strong></p>
<p><strong>maxTotal=20，也就是所有主机整体最大并发为 20</strong>，这也是 HttpClient 整体的并发 度。目前，我们请求数是 10 最大并发是 10，20 不会成为瓶颈。举一个例子，使用同一 个 HttpClient 访问 10 个域名，defaultMaxPerRoute 设置为 10，为确保每一个域名 都能达到 10 并发，需要把 maxTotal 设置为 100。</p>
</li>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PoolingHttpClientConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> HttpClientConnectionOperator httpClientConnectionOperator,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeToLive, <span class="keyword">final</span> TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.configData = <span class="keyword">new</span> ConfigData();</span><br><span class="line">    <span class="keyword">this</span>.pool = <span class="keyword">new</span> CPool(<span class="keyword">new</span> InternalConnectionFactory(</span><br><span class="line">            <span class="keyword">this</span>.configData, connFactory), <span class="number">2</span>, <span class="number">20</span>, timeToLive, timeUnit);</span><br><span class="line">    <span class="keyword">this</span>.pool.setValidateAfterInactivity(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">this</span>.connectionOperator = Args.notNull(httpClientConnectionOperator, <span class="string">"HttpClientConnectionOperator"</span>);</span><br><span class="line">    <span class="keyword">this</span>.isShutDown = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConnFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> defaultMaxPerRoute, <span class="keyword">final</span> <span class="keyword">int</span> maxTotal,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeToLive, <span class="keyword">final</span> TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(connFactory, defaultMaxPerRoute, maxTotal);</span><br><span class="line">    <span class="keyword">this</span>.timeToLive = timeToLive;</span><br><span class="line">    <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="数据库索引-索引并不是万能药"><a href="#数据库索引-索引并不是万能药" class="headerlink" title="数据库索引:索引并不是万能药"></a><strong>数据库索引:索引并不是万能药</strong></h1><h2 id="InnoDB是如何存储数据的"><a href="#InnoDB是如何存储数据的" class="headerlink" title="InnoDB是如何存储数据的"></a>InnoDB是如何存储数据的</h2><ul>
<li>MySQL 把数据存储和查询操作抽象成了存储引擎，不同的存储引擎，对数据的存储和读取 方式各不相同。MySQL 支持多种存储引擎，并且可以以表为粒度设置存储引擎。因为支持 事务，我们最常使用的是 InnoDB。</li>
<li>虽然数据保存在磁盘中，但其处理是在内存中进行的。为了减少磁盘随机读取次数， InnoDB 采用页而不是行的粒度来保存数据，即数据被分成若干页，以页为单位保存在磁盘 中。InnoDB 的页大小，一般是 16KB。</li>
<li>各个数据页组成一个双向链表，每个数据页中的记录按照主键顺序组成单向链表;每一个数 据页中有一个页目录，方便按照主键查询记录。数据页的结构如下:<img alt="image-20200419204721780" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzd65nvcaj311n0r8jx7.jpg" class="lazyload"><ul>
<li>页目录通过槽把记录分成不同的小组，每个小组有若干条记录。如图所示，记录中最前面的 小方块中的数字，代表的是当前分组的记录条数，最小和最大的槽指向 2 个特殊的伪记 录。有了槽之后，我们按照主键搜索页中记录时，就可以采用二分法快速搜索，无需从最小 记录开始遍历整个页中的记录链表。</li>
<li>举一个例子，如果要搜索主键(PK)=15 的记录:<ul>
<li>先二分得出槽中间位是 (0+6)/2=3，看到其指向的记录是 12&lt;15，所以需要从 #3 槽后 继续搜索记录;</li>
<li>再使用二分搜索出 #3 槽和 #6 槽的中间位是 (3+6)/2=4.5 取整 4，#4 槽对应的记录是 16&gt;15，所以记录一定在 #4 槽中;</li>
<li>再从 #3 槽指向的 12 号记录开始向下搜索 3 次，定位到 15 号记录。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a><strong>聚簇索引和二级索引</strong></h2><ul>
<li><p>说到索引，页目录就是最简单的索引，是通过对记录进行一级分组来降低搜索的时间复杂 度。但，这样能够降低的时间复杂度数量级，非常有限。当有无数个数据页来存储表数据的 时候，我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p>
</li>
<li><p>B+ 树的特点包括:<img alt="image-20200419205414532" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzdd9v2grj319a0rfn00.jpg" class="lazyload"></p>
<ol>
<li>最底层的节点叫作叶子节点，用来存放数据;</li>
<li>其他上层节点叫作非叶子节点，仅用来存放目录项，作为索引;</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量;</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，加速范围查找。</li>
</ol>
</li>
<li><p>因此，InnoDB 使用 B+ 树，既可以保存实际数据，也可以加速数据搜索，这就是聚簇索 引。如果把上图叶子节点下面方块中的省略号看作实际数据的话，那么它就是聚簇索引的示 意图。<strong>由于数据在物理上只会保存一份，所以包含实际数据的聚簇索引只能有一个</strong>。</p>
<ul>
<li>InnoDB 会自动使用主键(唯一定义一条记录的单个或多个字段)作为聚簇索引的索引键 (如果没有主键，就选择第一个不包含 NULL 值的唯一列)。上图方框中的数字代表了索 引键的值，对聚簇索引而言一般就是主键。</li>
<li>我们再看看 B+ 树如何实现快速查找主键。比如，我们要搜索 PK=4 的数据，通过根节点 中的索引可以知道数据在第一个记录指向的 2 号页中，通过 2 号页的索引又可以知道数据 在 5 号页，5 号页就是实际的数据页，然后再通过二分法查找页目录马上可以找到记录的 指针。</li>
</ul>
</li>
<li><p>二级索引：为了实现非主键字段的快速搜索<img alt="image-20200419210551905" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzdpdbkwdj31950rftby.jpg" class="lazyload"></p>
<ul>
<li>这次二级索引的叶子节点中保存的不是实际数据，而是主键，获得主键值后去聚簇索引中获 得数据行。这个过程就叫作<strong>回表。</strong></li>
<li>举个例子，有个索引是针对用户名字段创建的，索引记录上面方块中的字母是用户名，按照 顺序形成链表。如果我们要搜索用户名为 b 的数据，经过两次定位可以得出在 #5 数据页 中，查出所有的主键为 7 和 6，再拿着这两个主键继续使用聚簇索引进行两次回表得到完 整数据。</li>
</ul>
</li>
</ul>
<h2 id="考虑额外创建二级索引的代价"><a href="#考虑额外创建二级索引的代价" class="headerlink" title="考虑额外创建二级索引的代价"></a>考虑额外创建二级索引的代价</h2><p>创建二级索引的代价，主要表现在维护代价、空间代价和回表代价三个方面。</p>
<ul>
<li><strong>首先是维护代价</strong>。创建 N 个二级索引，就需要再创建 N 棵 B+ 树，新增数据时不仅要修改 聚簇索引，还需要修改这 N 个二级索引。<ul>
<li>这里，我再额外提一下，页中的记录都是按照索引值从小到大的顺序存放的，新增记录就需 要往页中插入数据，现有的页满了就需要新创建一个页，把现有页的部分数据移过去，这就 是页分裂;如果删除了许多数据使得页比较空闲，还需要进行页合并。页分裂和合并，都会 有 IO 代价，并且可能在操作过程中产生死锁。</li>
</ul>
</li>
<li><strong>其次是空间代价</strong>。虽然二级索引不保存原始数据，但要保存索引列的数据，所以会占用更多 的空间。<ul>
<li>查看表数据长度和索引长度大小：<code>select DATA_LENGTH, INDEX_LENGTH from information_schema.TABLES where TABLE_NAME=&#39;person&#39;;</code></li>
</ul>
</li>
<li><strong>最后是回表的代价</strong>。二级索引不保存原始数据，通过索引找到主键后需要再查询聚簇索引， 才能得到我们要的数据。<ul>
<li>explain分析：Extra 列多了一行 Using index 的提示，证明这次查询直接查的是二级索引，免 去了回表。</li>
</ul>
</li>
<li>联合索引示意图<img alt="image-20200419213417028" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzeixewayj310a0rjq5k.jpg" class="lazyload"><ul>
<li><strong>索引覆盖</strong>：在联合索引中直接查找到需要的字段数据。</li>
</ul>
</li>
</ul>
<h2 id="索引开销最佳实践"><a href="#索引开销最佳实践" class="headerlink" title="索引开销最佳实践"></a>索引开销最佳实践</h2><ol>
<li>第一，无需一开始就建立索引，可以等到业务场景明确后，或者是数据量超过 1 万、查询 变慢后，再针对需要查询、排序或分组的字段创建索引。创建索引后可以使用 EXPLAIN 命 令，确认查询是否可以使用索引。</li>
<li>第二，尽量索引轻量级的字段，比如能索引 int 字段就不要索引 varchar 字段。索引字段也 可以是部分前缀，在创建的时候指定字段索引长度。针对长文本的搜索，可以考虑使用 Elasticsearch 等专门用于文本搜索的索引数据库。</li>
<li>第三，尽量不要在 SQL 语句中 SELECT *，而是 SELECT 必要的字段，甚至可以考虑使用联 合索引来包含我们要搜索的字段，既能实现索引加速，又可以避免回表的开销。</li>
</ol>
<h2 id="不是所有针对索引列的查询都能用上索引"><a href="#不是所有针对索引列的查询都能用上索引" class="headerlink" title="不是所有针对索引列的查询都能用上索引"></a>不是所有针对索引列的查询都能用上索引</h2><p>两个问题，引发的思考：</p>
<ul>
<li>是不是建了索引一定可以用上? </li>
<li>怎么选择创建联合索引还是多个独立索引?</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ol>
<li><p>第一，<strong>索引只能匹配列前缀</strong>，对<code>like %xxxx</code>无效</p>
<ul>
<li><p>原因很简单，索引 B+ 树中行数据按照索引值排序，只能根据前缀进行比较。</p>
</li>
<li><p>必要要实现后缀匹配，可以考虑把数据反过来存储。（todo：实践）</p>
</li>
</ul>
</li>
<li><p>第二，<strong>条件涉及函数操作无法走索引</strong>，比如搜索条件用到了 LENGTH 函数，</p>
<ul>
<li>同样的原因，索引保存的是索引列的原始值，而不是经过函数计算后的值。</li>
<li>只能保存一份函数变换后的值，然后重新针对这个计算列做索 引。（todo：实践）</li>
</ul>
</li>
<li><p>第三，<strong>联合索引只能匹配左边的列</strong>。</p>
<ul>
<li>也就是说，虽然对 name 和 score 建了联合索引，但 是仅按照 score 列搜索无法走索引:</li>
<li>原因也很简单，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会 按照第二列排序。也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个 列必须是联合索引中从最左边开始连续的列。</li>
<li>需要注意的是，因为有查询优化器，所以 name 作为 WHERE 子句的第几个条件并不是很 重要。（本质通过查询优化器，where的查询条件会被优化顺序，命中联合索引）</li>
</ul>
</li>
</ol>
<ul>
<li>是不是建了索引一定可以用上? <ul>
<li>是不是建了索引一定可以用上?并不是，只有当查询能符合索引存储的实际结构时，才 能用上。这里，我只给出了三个肯定用不上索引的反例。其实，有的时候即使可以走索 引，MySQL 也不一定会选择使用索引。我会在下一小节展开这一点。</li>
</ul>
</li>
<li>怎么选择创建联合索引还是多个独立索引?<ul>
<li>怎么选择建联合索引还是多个独立索引?如果你的搜索条件经常会使用多个字段进行搜 索，那么可以考虑针对这几个字段建联合索引;同时，针对多字段建立联合索引，使用 索引覆盖的可能更大。如果只会查询单个字段，可以考虑建单独的索引，毕竟联合索引 保存了不必要字段也有成本。</li>
</ul>
</li>
</ul>
<h2 id="数据库基于成本决定是否走索引"><a href="#数据库基于成本决定是否走索引" class="headerlink" title="数据库基于成本决定是否走索引"></a>数据库基于成本决定是否走索引</h2><p>通过前面的案例，我们可以看到，查询数据可以直接在聚簇索引上进行全表扫描，也可以走 二级索引扫描后到聚簇索引回表。看到这里，你不禁要问了，MySQL 到底是怎么确定走哪 种方案的呢。</p>
<ul>
<li><p>如何计算查询成本？</p>
<ol>
<li>IO成本：是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的 IO 成本常数 是 1(也就是读取 1 个页成本是 1)。</li>
<li>CPU成本：是检测数据是否满足条件和排序等 CPU 操作的成本。默认情况下，检测记 录的成本是 0.2。</li>
</ol>
</li>
<li><p>全表扫描的成本？</p>
<ol>
<li>全表扫描，就是把聚簇索引中的记录依次和给定的搜索条件做比较，把符合搜索条件的记录 加入结果集的过程</li>
<li>聚簇索引占用的页面数，用来计算读取数据的 IO 成本<ul>
<li>(页大小=聚簇索引占用的空间/每个页的大小)=&gt;data_length/innodb每页大小为16kb</li>
</ul>
</li>
<li>表中的记录数，用来计算搜索的 CPU 成本(rows * 0.2)</li>
<li><code>SHOW TABLE STATUS LIKE &#39;person&#39;;</code><ul>
<li>因此我们可以计算出：10w的数据，row=10086，Data_length=5783552 byte，IO成本=289，cpu成本=20017，因此全表扫描的成本=20306</li>
</ul>
</li>
</ol>
</li>
<li><p>两个结论：</p>
<ol>
<li>MySQL 选择索引，并不是按照 WHERE 条件中列的顺序进行的;</li>
<li>即便列有索引，甚至有多个可能的索引方案，MySQL 也可能不走索引。</li>
<li><code>EXPLAIN SELECT * FROM person FORCE INDEX(name_score) WHERE xx=xx</code>，使用走强制索引</li>
</ol>
</li>
<li><p>用 optimizer trace 功能查看优化器生成执行 计划的整个过程</p>
<ol>
<li><p>mysql计算查询成本sql：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=on"</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">NAME</span> &gt;<span class="string">'name84059'</span> <span class="keyword">and</span> create_time&gt;<span class="string">'2020-04-18 00:00:00'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.OPTIMIZER_TRACE;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=off"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成本结果分析：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"analyzing_range_alternatives":&#123;</span><br><span class="line">	"range_scan_alternatives":[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"index"</span>:<span class="string">"name_score"</span>,</span><br><span class="line">            <span class="attr">"ranges"</span>:[</span><br><span class="line">                <span class="string">"name84059 &lt; name"</span>		<span class="comment">//条件命中索引成本计算</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"index_dives_for_eq_ranges"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"rowid_ordered"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"using_mrr"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"index_only"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"rows"</span>:<span class="number">25362</span>,			<span class="comment">//扫描行数</span></span><br><span class="line">            <span class="attr">"cost"</span>:<span class="number">30435</span>,			<span class="comment">//成本（二级索引+聚蔟索引查询成本）</span></span><br><span class="line">            <span class="attr">"chosen"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cause"</span>:<span class="string">"cost"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"index"</span>:<span class="string">"create_time"</span>,</span><br><span class="line">            <span class="attr">"ranges"</span>:[</span><br><span class="line">                <span class="string">"0x5e9a4300 &lt; create_time"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"index_dives_for_eq_ranges"</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"rowid_ordered"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"using_mrr"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"index_only"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"rows"</span>:<span class="number">50067</span>,</span><br><span class="line">            <span class="attr">"cost"</span>:<span class="number">60081</span>,</span><br><span class="line">            <span class="attr">"chosen"</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cause"</span>:<span class="string">"cost"</span></span><br><span class="line">        &#125;</span><br><span class="line">],</span><br><span class="line">  </span><br><span class="line">"rows_estimation":[</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"table"</span>:<span class="string">"`person`"</span>,</span><br><span class="line">    <span class="attr">"range_analysis"</span>:&#123;</span><br><span class="line">        <span class="attr">"table_scan"</span>:&#123;</span><br><span class="line">            <span class="attr">"rows"</span>:<span class="number">100135</span>,		</span><br><span class="line">            <span class="attr">"cost"</span>:<span class="number">20382</span>		<span class="comment">//全表成本</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="判等问题-程序里如何确定你就是你"><a href="#判等问题-程序里如何确定你就是你" class="headerlink" title="判等问题:程序里如何确定你就是你?"></a><strong>判等问题:程序里如何确定你就是你?</strong></h1><h2 id="注意equals和-区别"><a href="#注意equals和-区别" class="headerlink" title="注意equals和 == 区别"></a>注意equals和 == 区别</h2><ul>
<li><p>对基本类型，比如 int、long，进行判等，只能使用 ==，比较的是直接值。因为基本类 型的值就是其数值。</p>
</li>
<li><p>对引用类型，比如 Integer、Long 和 String，进行判等，需要使用 equals 进行内容判 等。因为引用类型的直接值是指针，使用 == 的话，比较的是指针，也就是两个对象在 内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</p>
</li>
<li><p>第一个结论:<strong>比较值的内容，除了基本类型只能使用 == 外，其他类型都需要使用 equals</strong>。</p>
<ul>
<li><p>Integer和int使用 == 判断相等的情况</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 127;</span><br><span class="line">Integer b = 127;</span><br><span class="line">a == b ? true</span><br><span class="line"></span><br><span class="line">Integer c = 128;</span><br><span class="line">Integer d = 128;</span><br><span class="line">c == d ? false</span><br><span class="line"></span><br><span class="line">Integer e = 127;</span><br><span class="line">Integer f = new Integer(127);</span><br><span class="line">e == f ? false</span><br><span class="line"></span><br><span class="line">Integer g = new Integer(127);</span><br><span class="line">Integer h = new Integer(127);</span><br><span class="line">g == h ? false</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">int j = 128;</span><br><span class="line">i == j ? true</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码分析：Integer缓存了一部分的值[-128,127(默认值)]，<strong>转换在内部其实做了缓存，使得两个 Integer 指向同一个对象</strong>。 JVM 参数加上 - XX:AutoBoxCacheMax=1000。<strong>只 需要记得比较 Integer 的值请使用 equals，而不是 ==</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注意枚举使用Integer来表示整数，使用==进行判等的问题。只有超过了127&amp;&amp;使用==进行判断的隐藏bug</p>
</li>
</ul>
<h2 id="谈谈字符串equals和"><a href="#谈谈字符串equals和" class="headerlink" title="谈谈字符串equals和 =="></a>谈谈字符串equals和 ==</h2><ul>
<li><p>字符串比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String a = <span class="string">"1"</span>;</span><br><span class="line">String b = <span class="string">"1"</span>;</span><br><span class="line">a == b ? <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"2"</span>);c == d ? <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">String e = <span class="keyword">new</span> String(<span class="string">"3"</span>).intern();</span><br><span class="line">String f = <span class="keyword">new</span> String(<span class="string">"3"</span>).intern();</span><br><span class="line">e == f ? <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">String g = <span class="keyword">new</span> String(<span class="string">"4"</span>);</span><br><span class="line">String h = <span class="keyword">new</span> String(<span class="string">"4"</span>);</span><br><span class="line">g .equals h ? <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我先和你说说 Java 的字符串常量池机制。首先要明确的是其设计初 衷是节省内存。当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行 检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回;否则， 创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是 字符串驻留或池化。</p>
</li>
<li><p><strong>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码 中滥用 intern，可能会产生性能问题</strong>。</p>
</li>
<li><p>通过循环把 1 到 1000 万之间的数字以字符串形式 intern 后，存入一个 List:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"internperformance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">internperformance</span><span class="params">(@RequestParam(value = <span class="string">"size"</span>, defaultValue = <span class="string">"10000000"</span>)</span> <span class="keyword">int</span> size) </span>&#123;</span><br><span class="line">        <span class="comment">//-XX:+PrintStringTableStatistics</span></span><br><span class="line">        <span class="comment">//-XX:StringTableSize=10000000</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        list = IntStream.rangeClosed(<span class="number">1</span>, size)</span><br><span class="line">                .mapToObj(i -&gt; String.valueOf(i).intern())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125; took:&#123;&#125;"</span>, size, System.currentTimeMillis() - begin);</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :  <span class="number">10031852</span> = <span class="number">240764448</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :  <span class="number">10031852</span> = <span class="number">563163800</span> bytes, avg  <span class="number">56.138</span></span><br><span class="line">Total footprint         :           = <span class="number">804408352</span> bytes</span><br><span class="line">Average bucket size     :   <span class="number">167.161</span></span><br><span class="line">Variance of bucket size :    <span class="number">55.844</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">7.473</span></span><br><span class="line">Maximum bucket size     :       <span class="number">198</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Average bucket size     :   167.161，表明每个桶的平均长度</li>
<li>buckets：桶的大小</li>
<li>其实，原因在于字符串常量池是一个固定容量的 Map。如果容量太小(Number of buckets=60013)、字符串太多(1000 万个字符串)，那么每一个桶中的字符串数量会 非常多，所以搜索起来就很慢。输出结果中的 Average bucket size=167，代表了 Map 中桶的平均长度是 167。</li>
</ul>
</li>
<li><p>第二原则了:<strong>没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标</strong>。</p>
</li>
</ul>
<h2 id="实现一个equals没有这么简单"><a href="#实现一个equals没有这么简单" class="headerlink" title="实现一个equals没有这么简单"></a>实现一个equals没有这么简单</h2><ul>
<li><p>对于自定义类型，如果不重写 equals 的话，默认就是使用 Object 基类的按引用的比较方 式。我们写一个自定义类测试一下。</p>
</li>
<li><p>自定义实现equals方法的，扣心自问2个问题。</p>
<ol>
<li>比较一个 XX 对象和 null;</li>
<li>比较一个 Object 对象和一个 XX 对象;</li>
</ol>
</li>
<li><p><strong>通过这些失效的用例，我们大概可以总结出实现一个更好的 equals 应该注意的点:</strong></p>
<ol>
<li><p>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true;</p>
</li>
<li><p>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle;</p>
</li>
<li><p>需要判断两个对象的类型，如果类型都不同，那么直接返回 false;</p>
</li>
<li><p>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</p>
</li>
<li><p>hashCode方法也需要重写，确保散列表的比较符合预期</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        PointRight that = (PointRight) o;</span><br><span class="line">        <span class="keyword">return</span> x == that.x &amp;&amp; y == that.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><p>String源码的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hashCode 和 equals 要配对实现。</p>
<ol>
<li>确保散列表的使用符合预期</li>
<li>散列表需要使用 hashCode 来定位元素放到哪个桶。如果自定义 对象没有实现自定义的 hashCode 方法，就会使用 Object 超类的默认实现，<strong>得到的两个 hashCode 是不同的，导致无法满足需求</strong>。</li>
<li><code>Objects.hash</code>方法</li>
</ol>
</li>
</ul>
<h2 id="注意-compareTo-和-equals-的逻辑一致性"><a href="#注意-compareTo-和-equals-的逻辑一致性" class="headerlink" title="注意 compareTo 和 equals 的逻辑一致性"></a><strong>注意</strong> <strong>compareTo</strong> <strong>和</strong> <strong>equals</strong> 的逻辑一致性</h2><ul>
<li><p><strong>Collections.binarySearch 方法内部调用了元素的 compareTo 方法进行比较</strong>;</p>
<ul>
<li>List.indexOf和Collections.binarySearch的算法实现不同O(n)和O(logn)。</li>
</ul>
</li>
<li><p>compareTo标准实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(StudentRight other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Comparator.comparing(StudentRight::getName)</span><br><span class="line">            .thenComparingInt(StudentRight::getId)</span><br><span class="line">            .compare(<span class="keyword">this</span>, other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于自定义的类型，如果要实现 Comparable，请记得 equals、 hashCode、compareTo 三者逻辑一致</strong>。</p>
</li>
</ul>
<h2 id="小心-Lombok-生成代码的坑"><a href="#小心-Lombok-生成代码的坑" class="headerlink" title="小心 Lombok 生成代码的坑"></a><strong>小心</strong> <strong>Lombok</strong> <strong>生成代码的</strong>坑</h2><ul>
<li>使用<code>@Data</code>注解，包括了<code>@EqualsAndHashCode</code>自动生成equals和hashcode方法。<ul>
<li><code>@EqualsAndHashCode.Exclude</code>排除equals和hashcode的实现中移除指定字段</li>
</ul>
</li>
<li><strong>说明 @EqualsAndHashCode 默认实现没有使用父类属性。</strong><ul>
<li>在继承关系中：<code>@EqualsAndHashCode(callSuper = true)</code></li>
</ul>
</li>
</ul>
<h1 id="数值计算-注意精度、舍入和溢出问题"><a href="#数值计算-注意精度、舍入和溢出问题" class="headerlink" title="数值计算:注意精度、舍入和溢出问题"></a><strong>数值计算:注意精度、舍入和溢出问题</strong></h1><p>解决10%+10%，神器问题</p>
<h2 id="危险的Double"><a href="#危险的Double" class="headerlink" title="危险的Double"></a>危险的Double</h2><ul>
<li><p><strong>对于计算 机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</strong></p>
</li>
<li><p><strong>使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal</strong>:</p>
<ul>
<li><p>BigDecimal 有 scale 和 precision 的概念，scale 表 示小数点右边的位数，而 precision 表示精度，也就是有效数字的长度。</p>
</li>
<li><p>关于右边位数和精度问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testScale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigDecimal bigDecimal1 = <span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>);</span><br><span class="line">        BigDecimal bigDecimal2 = <span class="keyword">new</span> BigDecimal(String.valueOf(<span class="number">100</span>d));</span><br><span class="line">        BigDecimal bigDecimal3 = <span class="keyword">new</span> BigDecimal(String.valueOf(<span class="number">100</span>));</span><br><span class="line">        BigDecimal bigDecimal4 = BigDecimal.valueOf(<span class="number">100</span>d);</span><br><span class="line">        BigDecimal bigDecimal5 = <span class="keyword">new</span> BigDecimal(Double.toString(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"scale &#123;&#125; precision &#123;&#125; result &#123;&#125;"</span>, bigDecimal.scale(), bigDecimal.precision(), bigDecimal.multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"4.015"</span>)));</span><br><span class="line">        print(bigDecimal1); <span class="comment">//scale 0 precision 3 result 401.500</span></span><br><span class="line">        print(bigDecimal2); <span class="comment">//scale 1 precision 4 result 401.5000</span></span><br><span class="line">        print(bigDecimal3); <span class="comment">//scale 0 precision 3 result 401.500</span></span><br><span class="line">        print(bigDecimal4); <span class="comment">//scale 1 precision 4 result 401.5000</span></span><br><span class="line">        print(bigDecimal5); <span class="comment">//scale 1 precision 4 result 401.5000</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>如果一定要用 Double 来初始化 BigDecimal 的话，可以使用 BigDecimal.valueOf 方 法</strong></p>
</li>
</ul>
<h2 id="考虑浮点数舍入和格式化的方式"><a href="#考虑浮点数舍入和格式化的方式" class="headerlink" title="考虑浮点数舍入和格式化的方式"></a>考虑浮点数舍入和格式化的方式</h2><ul>
<li><p>神器问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num1 = <span class="number">3.35</span>;</span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">3.35f</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">"%.1f"</span>, num1));<span class="comment">//四舍五入=3.4</span></span><br><span class="line">System.out.println(String.format(<span class="string">"%.1f"</span>, num2));<span class="comment">//四舍五入=3.3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这就是由精度问题和舍入方式共同导致的，double 和 float 的 3.35 其实相当于 3.350xxx 和 3.349xxx:</li>
<li>String.format 采用四舍五入的方式进行舍入，取 1 位小数，double 的 3.350 四舍五入为 3.4，而 float 的 3.349 四舍五入为 3.3。</li>
<li>我们看一下 Formatter 类的相关源码，可以发现使用的舍入模式是 HALF_UP</li>
</ul>
</li>
<li><p>所以浮点数避坑第二原则:<strong>浮点数的字符串格式化也要通过 BigDecimal 进行。</strong></p>
</li>
</ul>
<h2 id="用-equals-做判等，就一定是对的吗"><a href="#用-equals-做判等，就一定是对的吗" class="headerlink" title="用 equals 做判等，就一定是对的吗?"></a><strong>用</strong> <strong>equals</strong> <strong>做判等，就一定是对的吗?</strong></h2><ul>
<li><p>问题：<code>System.out.println(new BigDecimal(&quot;1.0&quot;).equals(new BigDecimal(&quot;1&quot;)))</code></p>
</li>
<li><p>源码分析：value and scale 都需要比较，因此上面的问题是false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this &#123;<span class="doctag">@code</span> BigDecimal&#125; with the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Object&#125; for equality.  Unlike &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #compareTo(BigDecimal) compareTo&#125;, this method considers two</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> BigDecimal&#125; objects equal only if they are equal in</span></span><br><span class="line"><span class="comment">     * value and scale (thus 2.0 is not equal to 2.00 when compared by</span></span><br><span class="line"><span class="comment">     * this method).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  x &#123;<span class="doctag">@code</span> Object&#125; to which this &#123;<span class="doctag">@code</span> BigDecimal&#125; is</span></span><br><span class="line"><span class="comment">     *         to be compared.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if the specified &#123;<span class="doctag">@code</span> Object&#125; is a</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> BigDecimal&#125; whose value and scale are equal to this</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> BigDecimal&#125;'s.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>    #compareTo(java.math.BigDecimal)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>    #hashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x <span class="keyword">instanceof</span> BigDecimal))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        BigDecimal xDec = (BigDecimal) x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (scale != xDec.scale)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> s = <span class="keyword">this</span>.intCompact;</span><br><span class="line">        <span class="keyword">long</span> xs = xDec.intCompact;</span><br><span class="line">        <span class="keyword">if</span> (s != INFLATED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xs == INFLATED)</span><br><span class="line">                xs = compactValFor(xDec.intVal);</span><br><span class="line">            <span class="keyword">return</span> xs == s;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xs != INFLATED)</span><br><span class="line">            <span class="keyword">return</span> xs == compactValFor(<span class="keyword">this</span>.intVal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.inflated().equals(xDec.inflated());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong></p>
<ul>
<li>方案：<code>System.out.println(new BigDecimal(&quot;1.0&quot;).compareTo(new BigDecimal(&quot;1&quot;))==0);</code></li>
</ul>
</li>
<li><p>那本质就是说compareTo与（equals和hashcode方法）实现的比较逻辑是不同，因此可以这样做。</p>
</li>
<li><p>问题：当容器HashSet或者HashMap，add(1.0)/put(1.0)之后，collect.contaion(1)的时候，返回false。如何解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">Set&lt;BigDecimal&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    hashSet1.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>));</span><br><span class="line">    System.out.println(hashSet1.contains(<span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>)));<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>本质说明：HashSet和HashMap在对值进行比较的时候，调用的是equals和hashcode方法。而TreeSet和TreeMap调用的是compareTo方法。</li>
<li>第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使 用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。</li>
<li>第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的:</li>
</ol>
</li>
</ul>
<h2 id="小心数值溢出问题"><a href="#小心数值溢出问题" class="headerlink" title="小心数值溢出问题"></a><strong>小心数值溢出问题</strong></h2><p>数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超 出表达范围的可能性。</p>
<ul>
<li><p>问题：数值计算溢出问题，<strong>显然这是发生了溢出，而且是默默的溢出，并没有任何异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>);</span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol>
<li>方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运 算，这些方法可以在数值溢出时主动抛出异常</li>
<li>方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则 是对大数进行科学计算的专家</li>
</ol>
</li>
</ul>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一，切记，要精确表示浮点数应该使用 BigDecimal。并且，使用 BigDecimal 的 Double 入参的构造方法同样存在精度丢失问题，应该使用 String 入参的构造方法或者 BigDecimal.valueOf 方法来初始化。</li>
<li>第二，对浮点数做精确计算，参与计算的各种数值应该始终使用 BigDecimal，所有的计算 都要通过 BigDecimal 的方法进行，切勿只是让 BigDecimal 来走过场。任何一个环节出现 精度损失，最后的计算结果可能都会出现误差。</li>
<li>第三，对于浮点数的格式化，如果使用 String.format 的话，需要认识到它使用的是四舍五 入，可以考虑使用 DecimalFormat 来明确指定舍入方式。但考虑到精度问题，我更建议使 用 BigDecimal 来表示浮点数，并使用其 setScale 方法指定舍入的位数和方式。</li>
<li>第四，进行数值运算时要小心溢出问题，虽然溢出后不会出现异常，但得到的计算结果是完 全错误的。我们考虑使用 Math.xxxExact 方法来进行运算，在溢出时能抛出异常，更建议 对于可能会出现溢出的大数运算使用 BigInteger 类。</li>
<li>总之，对于金融、科学计算等场景，请尽可能使用 BigDecimal 和 BigInteger，避免由精 度和溢出问题引发难以发现，但影响重大的 Bug。</li>
</ol>
<h1 id="集合类-坑满地的List列表操作"><a href="#集合类-坑满地的List列表操作" class="headerlink" title="集合类:坑满地的List列表操作"></a><strong>集合类:坑满地的</strong>List列表操作</h1><p>xx大师说过，程序=数据结构+算法。Java 的集合类包括 Map 和 Collection 两大类。Collection 包 括 List、Set 和 Queue 三个小类，其中 List 列表集合是最重要也是所有业务代码都会用到的。</p>
<p>我们就从把数组转换为 List 集合、对 List 进行切片操作、List 搜索的性能问题等几 个方面着手。来谈谈java集合的坑。</p>
<h2 id="使用-Arrays-asList-把数据转换为-List-的三个坑"><a href="#使用-Arrays-asList-把数据转换为-List-的三个坑" class="headerlink" title="使用 Arrays.asList 把数据转换为 List 的三个坑"></a><strong>使用</strong> <strong>Arrays.asList</strong> <strong>把数据转换为</strong> <strong>List</strong> <strong>的三个坑</strong></h2><ul>
<li><p>第一个坑是，<strong>不能直接使用 Arrays.asList 来转换基本类型数组</strong></p>
</li>
<li><p>问题：使用Arrays.asList初始化基本数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List list = Arrays.asList(arr);</span><br><span class="line">        log.info(<span class="string">"list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;"</span>, list, list.size(), list.get(<span class="number">0</span>).getClass());</span><br><span class="line"><span class="comment">//list:[[I@d7b1517] size:1 class:class [I</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* Arrays.asList的源码</span></span><br><span class="line"><span class="comment">		**/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>其原因是，只能是把 int 装箱为 Integer，不可能把 int 数组装箱为 Integer 数组。我们知 道，Arrays.asList 方法传入的是一个泛型 T 类型可变参数，最终 int 数组整体作为了一个 对象成为了泛型类型 T</li>
<li>解决方案1：对于基本数据类型的数组，使用<code>Arrays.stream(arr).boxed().collect(Collectors.toList());</code>先对基本数据类型的数组进行装箱。</li>
<li>解决方案2：只能把基本数据类型数组，声明为包装类型的数组</li>
</ol>
</li>
<li><p>第二个坑，<strong>Arrays.asList 返回的 List 不支持增删操作</strong></p>
</li>
<li><p>第三个坑，<strong>对原始数组的修改会影响到我们获得的那个 List</strong>。</p>
</li>
<li><p>问题：操作Arrays.asList生成的List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"4"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"arr:&#123;&#125; list:&#123;&#125;"</span>, Arrays.toString(arr), list);</span><br><span class="line"><span class="comment">//java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">//arr:[1, 4, 3] list:[1, 4, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>源码分析：Arrays.asList 返回的 List 并不是 我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。ArrayList 内部类继承自 AbstractList 类，并没有覆写父类的 add 方法，而父类中 add 方法的实现，就是抛出 UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.AbstractList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看一下 java.util.Arrays.ArrayList内部类 的实现，可 以发现 ArrayList 其实是直接使用了原始的数组。所以，我们要特别小心，把通过 Arrays.asList 获得的 List 交给其他方法处理，很容易因为共享了数组，相互修改产生 Bug。</p>
</li>
</ul>
</li>
<li><p>解决方案：使用真的ArrayList，而不是Arrays内部类的ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(arr));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-List-subList-进行切片操作居然会导致-OOM"><a href="#使用-List-subList-进行切片操作居然会导致-OOM" class="headerlink" title="使用 List.subList 进行切片操作居然会导致 OOM?"></a><strong>使用</strong> <strong>List.subList</strong> <strong>进行切片操作居然会导致</strong> <strong>OOM</strong>?</h2><p>业务开发时常常要对 List 做切片处理，即取出其中部分元素构成一个新的 List，我们通常 会想到使用 List.subList 方法。但，和 Arrays.asList 的问题类似，List.subList 返回的子List 不是一个普通的 ArrayList。这个子 List 可以认为是原始 List 的视图，会和原始 List 相 互影响。如果不注意，很可能会因此产生 OOM 问题。</p>
<ul>
<li><p>问题一：注意使用ArraysList.subList()方法，导致OOM，看源码！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">           List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100000</span>).boxed().collect(Collectors.toList());</span><br><span class="line">           System.out.println(<span class="string">"运行了第"</span> + i + <span class="string">"次，还是没有出现oom"</span>);</span><br><span class="line">           data.add(rawList.subList(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//可以最大堆和初始化堆，更快看到效果OOM，Java heap space</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建太多对象没有被收回（强引用），导致OOM。</li>
<li><strong>出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为 它始终被 subList 方法返回的 List 强引用。</strong></li>
<li>解决方案：<code>data.add(new ArrayList&lt;&gt;(rawList.subList(0, 1)));</code>不强依赖原List</li>
</ul>
</li>
<li><p>问题二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).boxed().collect(Collectors.toList());</span><br><span class="line">    List&lt;Integer&gt; subList = list.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(subList);</span><br><span class="line">    subList.remove(<span class="number">1</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subList.forEach(System.out::println);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们通过源码分析可以知道，ArrayList.SubList的内部类，所有的操作都是操作它的parent（ArrayList），所以当我们直接修改了list，导致只是修改list的modCount，而sublist的modCount就少了一次，在所有操作之前都会判断modCount的大小，不然就会抛出<code>ConcurrentModificationException</code>异常</p>
</li>
<li><p>当你操作subList的时候，因为是直接操作的List，所以会影响到list的数据</p>
</li>
<li><p>SubList 是原始 List 的视图。</p>
</li>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//SubList是原始List的视图</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//每次插件modCount</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//本质就是操作parent的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//本质就是操作parent的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + index);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//新的ArrayList</span></span><br><span class="line">List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;(list.subList(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//java8 stream操作</span></span><br><span class="line">List&lt;Integer&gt; subList = list.stream().skip(<span class="number">1</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构 造方法传入 SubList，来构建一个独立的 ArrayList;</li>
<li>另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制 流中元素的个数，同样可以达到 SubList 切片的目的。</li>
</ul>
</li>
</ul>
<h2 id="一定要让合适的数据结构做合适的事情"><a href="#一定要让合适的数据结构做合适的事情" class="headerlink" title="一定要让合适的数据结构做合适的事情"></a><strong>一定要让合适的数据结构做合适的事情</strong></h2><ul>
<li><p><strong>第一个误区是，</strong>使用数据结构不考虑平衡时间和空间**。</p>
</li>
<li><p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在100w个元素，进行1000次查询耗时（list和map的耗时）</span></span><br><span class="line"><span class="number">20861992</span></span><br><span class="line"><span class="number">72388672</span></span><br><span class="line">StopWatch <span class="string">''</span>: running time = <span class="number">3402737445</span> ns</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="number">2912953845</span>  <span class="number">086</span>%  listSearch	<span class="comment">//2.9s</span></span><br><span class="line"><span class="number">489783600</span>  <span class="number">014</span>%  mapSearch		<span class="comment">//0.4s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们知道，搜索 ArrayList 的时间复杂度是 O(n)，而 HashMap 的 get 操作的时间复杂度 是 O(1)。<strong>所以，要对大 List 进行单值搜索的话，可以考虑使用 HashMap，其中 Key 是 要搜索的值，Value 是原始对象，会比使用 ArrayList 有非常明显的性能优势。</strong></p>
</li>
<li><p>本质也是空间换时间：List占用21MB，而HashMap占用70MB</p>
</li>
<li><p>即使我们要搜索的不是单值而是条件区间，也可以尝试使用 HashMap 来进行“搜索性能 优化”。如果你的条件区间是固定的话，可以提前把 HashMap 按照条件区间进行分组， Key 就是不同的区间。（todo）</p>
</li>
<li><p><strong>第二个误区是，过于迷信教科书的大 O 时间复杂度</strong>。</p>
</li>
<li><p>ArrayList和LinkedList基于连续存储的数组和基于指针串联的链表(双向)两种方式</p>
<ul>
<li>对于数组，随机元素访问的时间复杂度是 O(1)，元素插入操作是 O(n);</li>
<li>对于链表，随机元素访问的时间复杂度是 O(n)，元素插入操作是 O(1)。</li>
</ul>
</li>
<li><p>问题：那么，在大量的元素插入、很少的随机访问的业务场景下，是不是就应该使用 LinkedList 呢？</p>
</li>
<li><p>通过实验和查看源码我们可以知道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	LinkedList的源码分析：</span></span><br><span class="line"><span class="comment">* 在linkedList中的add操作，有三种：默认的add，只有一个参数，总是插到双向链表的尾部</span></span><br><span class="line"><span class="comment">* 带两个参数的add，链表需要要通过O(n)的时间复杂度找到index,在index后面利用双向链表,直接index</span></span><br><span class="line"><span class="comment">* 第三种：addFirst利用双向链表，总是插在头部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment">     * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>记录一个有趣的事情：LinkedList 的作者约书亚 · 布洛克(Josh Bloch)，曾经说过<code>Dose anyone actually use LinkedList? I wrote it,and I never use it</code></li>
<li>结论：在各种常用场景下，LinkedList 几乎都不能在性能上胜出 ArrayList。抛开算法层面不谈，由于 CPU 缓存、内存连续性等问题，链表这种数 据结构的实现方式对性能并不友好，即使在它最擅长的场景都不一定可以发挥威力。</li>
</ul>
</li>
</ul>
<h2 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一，想当然认为，Arrays.asList 和 List.subList 得到的 List 是普通的、独立的 ArrayList，在使用时出现各种奇怪的问题。<ul>
<li>Arrays.asList 得到的是 Arrays 的内部类 ArrayList，List.subList 得到的是 ArrayList 的 内部类 SubList，不能把这两个内部类转换（当成）为 ArrayList 使用。</li>
<li>Arrays.asList 直接使用了原始数组，可以认为是共享“存储”，而且不支持增删元素; List.subList 直接引用了原始的 List，也可以认为是共享“存储”，而且对原始 List 直接 进行结构性修改会导致 SubList 出现异常。</li>
<li>对 Arrays.asList 和 List.subList 容易忽略的是，新的 List 持有了原始数据的引用，可能 会导致原始数据也无法 GC 的问题，最终导致 OOM。</li>
</ul>
</li>
<li>第二，想当然认为，Arrays.asList 一定可以把所有数组转换为正确的 List。当传入基本类 型数组的时候，List 的元素是数组本身，而不是数组中的元素。</li>
<li>第三，想当然认为，内存中任何集合的搜索都是很快的，结果在搜索超大 ArrayList 的时候 遇到性能问题。我们考虑利用 HashMap 哈希表随机查找的时间复杂度为 O(1) 这个特性来 优化性能，不过也要考虑 HashMap 存储空间上的代价，要平衡时间和空间。</li>
<li>第四，想当然认为，链表适合元素增删的场景，选用 LinkedList 作为数据结构。在真实场 景中读写增删一般是平衡的，而且增删不可能只是对头尾对象进行操作，可能在 90% 的情 况下都得不到性能增益，建议使用之前通过性能测试评估一下。</li>
</ol>
<h1 id="空值处理-分不清楚的null和恼人的空指针"><a href="#空值处理-分不清楚的null和恼人的空指针" class="headerlink" title="空值处理:分不清楚的null和恼人的空指针"></a>空值处理:分不清楚的null和恼人的空指针</h1><p>程序中的变量是 null，就意味着它没有引用指向或者说没有指针。这时，我们对这个变量 进行任何操作，都必然会引发空指针异常，在 Java 中就是 NullPointerException。</p>
<h2 id="修复和定位恼人的空指针问题"><a href="#修复和定位恼人的空指针问题" class="headerlink" title="修复和定位恼人的空指针问题"></a>修复和定位恼人的空指针问题</h2><p><strong>NullPointerException 是 Java 代码中最常见的异常，我将其最可能出现的场景归为以下</strong></p>
<p><strong>5 种</strong>:</p>
<ol>
<li>参数值是 Integer 等包装类型，使用时因为自动拆箱出现了空指针异常;</li>
<li>字符串比较出现空指针异常;</li>
<li>诸如 ConcurrentHashMap 这样的容器不支持 Key 和 Value 为 null，强行 put null 的 Key 或 Value 会出现空指针异常;</li>
<li>A 对象包含了 B，在通过 A 对象的字段获得 B 之后，没有对字段判空就级联调用 B 的方 法出现空指针异常;</li>
<li>方法或远程服务返回的 List 不是空而是 null，没有进行判空就直接调用 List 的方法出现 空指针异常。</li>
</ol>
<ul>
<li><p>实验栗子源码：模拟上面见到空指针的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wrong</span><span class="params">(@RequestParam(value = <span class="string">"test"</span>, defaultValue = <span class="string">"1111"</span>)</span> String test) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrongMethod(test.charAt(<span class="number">0</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> FooService(),</span><br><span class="line">            test.charAt(<span class="number">1</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="number">1</span>,</span><br><span class="line">            test.charAt(<span class="number">2</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>,</span><br><span class="line">            test.charAt(<span class="number">3</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>).size();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">wrongMethod</span><span class="params">(FooService fooService, Integer i, String s, String t)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"result &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, i + <span class="number">1</span>, s.equals(<span class="string">"OK"</span>), s.equals(t),</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;().put(<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    <span class="keyword">if</span> (fooService.getBarService().bar().equals(<span class="string">"OK"</span>))</span><br><span class="line">        log.info(<span class="string">"OK"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>requestParam参数是一个由 0 和 1 构成的、长度为 4 的字符串，第几位设置为 1 就代表第几个参数为 null，用来控制 wrongMethod 方法的 4 个入参。</li>
<li>四处异常<ul>
<li>对入参 Integer i 进行 +1 操作;</li>
<li>对入参 String s 进行比较操作，判断内容是否等于”OK”;</li>
<li>对入参 String s 和入参 String t 进行比较操作，判断两者是否相等;</li>
<li>对 new 出来的 ConcurrentHashMap 进行 put 操作，Key 和 Value 都设置为 null。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="java线上定位问题：Arthas神器"><a href="#java线上定位问题：Arthas神器" class="headerlink" title="java线上定位问题：Arthas神器"></a>java线上定位问题：<strong>Arthas神器</strong></h3><ul>
<li><p>运行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看方法的入参</span></span><br><span class="line">watch org.geekbang.time.commonmistakes.nullvalue.avoidnullpointerexception.AvoidNullPointerExceptionController wrongMethod params</span><br><span class="line"></span><br><span class="line">ts=2020-04-27 07:56:23; [cost=1.857199ms] result=@Object[][</span><br><span class="line">    null,</span><br><span class="line">    null,</span><br><span class="line">    @String[OK],</span><br><span class="line">    null,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">stack 命令来查看 wrongMethod 方法的调用栈</span></span><br><span class="line">stack org.geekbang.time.commonmistakes.nullvalue.avoidnullpointerexception.AvoidNullPointerExceptionController wrongMethod</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-x 参数设置为 2 代表参数打印的深度为 2 层</span></span><br><span class="line">watch org.geekbang.time.commonmistakes.nullvalue.avoidnullpointerexception.AvoidNullPointerExceptionController rightMethod params -x 2</span><br><span class="line"></span><br><span class="line">ts=2020-04-27 08:29:15; [cost=6.957267ms] result=@Object[][</span><br><span class="line">    @FooService[</span><br><span class="line">        barService=null,</span><br><span class="line">        this$0=@AvoidNullPointerExceptionController[org.geekbang.time.commonmistakes.nullvalue.avoidnullpointerexception.AvoidNullPointerExceptionController@49809275],</span><br><span class="line">    ],</span><br><span class="line">    @Integer[1],</span><br><span class="line">    @String[OK],</span><br><span class="line">    @String[OK],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">使用帮助文档</a></p>
</li>
</ul>
<h3 id="处理空指针-正确姿势"><a href="#处理空指针-正确姿势" class="headerlink" title="处理空指针-正确姿势"></a>处理空指针-正确姿势</h3><ul>
<li><p>其实，对于任何空指针异常的处理，最直白的方式是先判空后操作。不过，这只能让异常不 再出现，我们还是要找到程序逻辑中出现的空指针究竟是来源于入参还是 Bug:</p>
<ol>
<li>如果是来源于入参，还要进一步分析入参是否合理等;</li>
<li>如果是来源于 Bug，那空指针不一定是纯粹的程序 Bug，可能还涉及业务属性和接口调 用规范等。</li>
</ol>
</li>
<li><p>因为是 Demo，所以我们只考虑纯粹的空指针判空这种修复方式。如果要先判空 后处理，大多数人会想到使用 if-else 代码块。但，这种方式既增加代码量又会降低易读 性，我们可以尝试利用 Java 8 的 Optional 类来消除这样的 if-else 逻辑，使用一行代码进 行判空和处理。</p>
<ol>
<li>对于 Integer 的判空，可以使用 Optional.ofNullable 来构造一个 Optional，然后使用 orElse(0) 把 null 替换为默认值再进行 +1 操作。</li>
<li>对于 String 和字面量的比较，可以把字面量放在前面，比如”OK”.equals(s)，这样即使 s 是 null 也不会出现空指针异常;而对于两个可能为 null 的字符串变量的 equals 比 较，可以使用 Objects.equals，它会做判空处理。</li>
<li>对于 ConcurrentHashMap，既然其 Key 和 Value 都不支持 null，修复方式就是不要 把 null 存进去。HashMap 的 Key 和 Value 可以存入 null，而 ConcurrentHashMap 看似是 HashMap 的线程安全版本，却不支持 null 值的 Key 和 Value，这是容易产生误 区的一个地方。</li>
<li>对于类似 fooService.getBarService().bar().equals(“OK”) 的级联调用，需要判空的 地方有很多，包括 fooService、getBarService() 方法的返回值，以及 bar 方法返回的 字符串。如果使用 if-else 来判空的话可能需要好几行代码，但使用 Optional 的话一行 代码就够了。</li>
<li>对于 rightMethod 返回的 List，由于不能确认其是否为 null，所以在调用 size 方法获 得列表大小之前，同样可以使用 Optional.ofNullable 包装一下返回值，然后通 过.orElse(Collections.emptyList()) 实现在 List 为 null 的时候获得一个空的 List，最后 再调用 size 方法。</li>
</ol>
</li>
<li><p>正确处理空指针代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">rightMethod</span><span class="params">(FooService fooService, Integer i, String s, String t)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"result &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, Optional.ofNullable(i).orElse(<span class="number">0</span>) + <span class="number">1</span>, <span class="string">"OK"</span>.equals(s), Objects.equals(s, t), <span class="keyword">new</span> HashMap&lt;String, String&gt;().put(<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    Optional.ofNullable(fooService)</span><br><span class="line">            .map(FooService::getBarService)</span><br><span class="line">            .filter(barService -&gt; <span class="string">"OK"</span>.equals(barService.bar()))</span><br><span class="line">            .ifPresent(result -&gt; log.info(<span class="string">"OK"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(@RequestParam(value = <span class="string">"test"</span>, defaultValue = <span class="string">"1111"</span>)</span> String test) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(rightMethod(test.charAt(<span class="number">0</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> FooService(),</span><br><span class="line">            test.charAt(<span class="number">1</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="number">1</span>,</span><br><span class="line">            test.charAt(<span class="number">2</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>,</span><br><span class="line">            test.charAt(<span class="number">3</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>))</span><br><span class="line">            .orElse(Collections.emptyList()).size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用判空方式或 Optional 方式来避免出现空指针异常，不一定是解 决问题的最好方式，空指针没出现可能隐藏了更深的 Bug</strong>。</p>
<ul>
<li>因此，解决空指针异常，还是 要真正 case by case(具体问题具体分析) 地定位分析案例，然后再去做判空处理，而处理时也并不只是判断非 空然后进行正常业务流程这么简单，同样需要考虑为空的时候是<strong>应该出异常、设默认值还是 记录日志等。</strong></li>
</ul>
</li>
</ul>
<h2 id="POJO-中属性的-null-到底代表了什么"><a href="#POJO-中属性的-null-到底代表了什么" class="headerlink" title="POJO 中属性的 null 到底代表了什么?"></a><strong>POJO</strong> <strong>中属性的</strong> <strong>null</strong> <strong>到底代表了什么?</strong></h2><ul>
<li><p>相比判空避免空指针异常，更容易出错的是 null 的定位问题。对程序来说，null 就是指针没有任何指向，而结合业务逻辑情况就复杂得多，我们需要考虑：</p>
<ol>
<li>DTO 中字段的 null 到底意味着什么?是客户端没有传给我们这个信息吗?</li>
<li>既然空指针问题很讨厌，那么 DTO 中的字段要设置默认值么?</li>
<li>如果数据库实体中的字段有 null，那么通过数据访问框架保存数据是否会覆盖数据库中 的既有数据?</li>
</ol>
</li>
<li><p>问题栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date createDate = <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">wrong</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        user.setNickname(String.format(<span class="string">"guest%s"</span>, user.getName()));</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//curl -H "Content-Type:application/json" -X POST -d '&#123; "id":1, "name":null&#125;' http://127.0.0.1:45678/pojonull/wrong</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用方只希望重置用户名，但 age 也被设置为了 null;</li>
<li>nickname 是用户类型加姓名，name 重置为 null 的话，访客用户的昵称应该是guest，而不是 guestnull，重现了文首提到的那个笑点;</li>
<li>创建时间时间也被更新了</li>
</ul>
</li>
<li><p>解决方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;String&gt; name;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Integer&gt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, columnDefinition = <span class="string">"TIMESTAMP DEFAULT CURRENT_TIMESTAMP"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"right"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserEntity <span class="title">right</span><span class="params">(@RequestBody UserDto user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用dto字段，只更新指定字段</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.getId() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户Id不能为空"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能够使用@DynamicUpdate，只更新更改了字段。</span></span><br><span class="line">        UserEntity userEntity = userEntityRepository.findById(user.getId())</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用了optional的特性，可以区分，客户端是没有传入该字段，还是传入null</span></span><br><span class="line">        <span class="keyword">if</span> (user.getName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userEntity.setName(user.getName().orElse(<span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        userEntity.setNickname(<span class="string">"guest"</span> + userEntity.getName());</span><br><span class="line">        <span class="keyword">if</span> (user.getAge() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userEntity.setAge(user.getAge().orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"年龄不能为空"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userEntityRepository.save(userEntity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDto 中只保留 id、name 和 age 三个属性，且 name 和 age 使用 Optional 来包 装，以区分客户端不传数据还是故意传 null。</li>
<li>在 UserEntity 的字段上使用 @Column 注解，把数据库字段 name、nickname、age 和 createDate 都设置为 NOT NULL，并设置 createDate 的默认值为 CURRENT_TIMESTAMP，由数据库来生成创建时间。</li>
<li>使用 Hibernate 的 <strong>@DynamicUpdate</strong> 注解实现更新 SQL 的动态生成，实现只更新修 改后的字段，不过需要先查询一次实体，让 Hibernate 可以“跟踪”实体属性的当前状 态，以确保有效。</li>
</ul>
</li>
</ul>
<h3 id="定义POJO需要注意的五个问题"><a href="#定义POJO需要注意的五个问题" class="headerlink" title="定义POJO需要注意的五个问题"></a>定义POJO需要注意的五个问题</h3><ol>
<li>明确 DTO 种 null 的含义。<strong>对于 JSON 到 DTO 的反序列化过程，null 的表达是有歧义 的，客户端不传某个属性，或者传 null，这个属性在 DTO 中都是 null。</strong><ul>
<li>但，对于用户 信息更新操作，不传意味着客户端不需要更新这个属性，维持数据库原先的值;</li>
<li>传了 null，意味着客户端希望重置这个属性。</li>
<li>因为 Java 中的 null 就是没有这个数据，无法区 分这两种表达，所以本例中的 age 属性也被设置为了 null，或许我们可以借助 Optional 来解决这个问题。</li>
</ul>
</li>
<li><strong>POJO 中的字段有默认值。如果客户端不传值，就会赋值为默认值，导致创建时间也被 更新到了数据库中。</strong></li>
<li><strong>注意字符串格式化时可能会把 null 值格式化为 null 字符串。</strong><code>String.format(&quot;guest%s&quot;, user.getName())</code></li>
<li><strong>DTO 和 Entity 共用了一个 POJO</strong>。对于用户昵称的设置是程序控制的，我们不应该把 它们暴露在 DTO 中，否则很容易把客户端随意设置的值更新到数据库中。此外，创建时 间最好让数据库设置为当前时间，不用程序控制，可以通过在字段上设置 columnDefinition 来实现。</li>
<li><strong>数据库字段允许保存 null，会进一步增加出错的可能性和复杂度</strong>。因为如果数据真正落 地的时候也支持 NULL 的话，可能就有 NULL、空字符串和字符串 null 三种状态。</li>
</ol>
<h2 id="小心-MySQL-中有关-NULL-的三个坑"><a href="#小心-MySQL-中有关-NULL-的三个坑" class="headerlink" title="小心 MySQL 中有关 NULL 的三个坑"></a><strong>小心</strong> <strong>MySQL</strong> <strong>中有关</strong> <strong>NULL</strong> 的三个坑</h2><ul>
<li><p>数据库表字段允许存 NULL 除了会让我们困惑外，还容易有坑。这里我会结合NULL 字段，和你着重说明 sum 函数、count 函数，以及 NULL 值条件可能踩的坑。</p>
</li>
<li><p>问题源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一张表，表示score字段允许为NULL，并且插入一条记录</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error sql</span></span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT SUM(score) FROM `user`"</span>)</span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT COUNT(score) FROM `user`"</span>)</span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT * FROM `user` WHERE score=null"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//right sql</span></span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT IFNULL(SUM(score),0) FROM `user`"</span>)</span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT COUNT(*) FROM `user`"</span>)</span><br><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"SELECT * FROM `user` WHERE score IS NULL"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 sum 函数统计一个只有 NULL 值的列的总和，比如 SUM(score);</li>
<li>select 记录数量，count 使用一个允许 NULL 的字段，比如 COUNT(score);</li>
<li>使用 =NULL 条件查询字段值为 NULL 的记录，比如 score=null 条件。</li>
</ul>
</li>
<li><p>期望和原因</p>
<ol>
<li>虽然记录的 score 都是 NULL，但 sum 的结果应该是 0 才对;<ul>
<li><strong>MySQL 中 sum 函数没统计到任何记录时，会返回 null 而不是 0</strong>，可以使用 IFNULL 函数把 null 转换为 0;</li>
</ul>
</li>
<li>虽然这条记录的 score 是 NULL，但记录总数应该是 1 才对;<ul>
<li><strong>MySQL 中 count 字段不统计 null 值</strong>，COUNT(*) 才是统计所有记录数量的正确方 式。</li>
</ul>
</li>
<li>使用 =NULL 并没有查询到 id=1 的记录，查询条件失效。<ul>
<li><strong>MySQL 中 =NULL 并不是判断条件而是赋值</strong>，对 NULL 进行判断只能使用 IS NULL 或 者 IS NOT NULL。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="异常处理-别让自己在出问题的时候变为瞎子"><a href="#异常处理-别让自己在出问题的时候变为瞎子" class="headerlink" title="异常处理:别让自己在出问题的时候变为瞎子"></a><strong>异常处理:别让自己在出问题的时候变为瞎子</strong></h1><p>应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目 中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流 水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日 志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。（都不可取）</p>
<h2 id="捕获和处理异常容易犯的错"><a href="#捕获和处理异常容易犯的错" class="headerlink" title="捕获和处理异常容易犯的错"></a>捕获和处理异常容易犯的错</h2><ul>
<li><p><strong>第一个错：”统一异常处理”，不在业务代码层面考虑异常处理，仅在框架 层面粗犷捕获和处理异常。</strong></p>
</li>
<li><p>每层架构的工作性质不同，且从业务性质上异常可能分为业务异常和系统异常两大类，这就 决定了很难进行统一的异常处理。我们从底向上看一下三层架构:</p>
<ol>
<li>Repository 层出现异常或许可以忽略，或许可以降级，或许需要转化为一个友好的异 常。如果一律捕获异常仅记录日志，很可能业务逻辑已经出错，而用户和程序本身完全 感知不到。</li>
<li>Service 层往往涉及数据库事务，出现异常同样不适合捕获，否则事务无法自动回滚。此 外 Service 层涉及业务逻辑，有些业务逻辑执行中遇到业务异常，可能需要在异常后转 入分支业务流程。如果业务异常都被框架捕获了，业务功能就会不正常。</li>
<li>如果下层异常上升到 Controller 层还是无法处理的话，Controller 层往往会给予用户友 好提示，或是根据每一个 API 的异常表返回指定的异常类型，同样无法对所有异常一视 同仁。</li>
</ol>
</li>
<li><p>因此，我不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架 可以做兜底工作。如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异 常转换，比如通过 @RestControllerAdvice + @ExceptionHandler，来捕获这些“未处 理”异常:</p>
<ul>
<li><p>对于自定义的业务异常，以 Warn 级别的日志记录异常以及当前 URL、执行方法等信息 后，提取异常中的错误码和消息等信息，转换为合适的 API 包装体返回给 API 调用方;</p>
</li>
<li><p>对于无法处理的系统异常，以 Error 级别的日志记录异常和上下文信息(比如 URL、参 数、用户 ID)后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以 API 包装 体返回给调用方。</p>
</li>
<li><p>源码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> GENERIC_SERVER_ERROR_CODE = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String GENERIC_SERVER_ERROR_MESSAGE = <span class="string">"服务器忙，请稍后再试"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse <span class="title">handle</span><span class="params">(HttpServletRequest req, HandlerMethod method, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException exception = (BusinessException) ex;</span><br><span class="line">            log.warn(String.format(<span class="string">"访问 %s -&gt; %s 出现业务异常！"</span>, req.getRequestURI(), method.toString()), ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> APIResponse(<span class="keyword">false</span>, <span class="keyword">null</span>, exception.getCode(), exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//兜底工作</span></span><br><span class="line">            log.error(String.format(<span class="string">"访问 %s -&gt; %s 出现系统异常！"</span>, req.getRequestURI(), method.toString()), ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> APIResponse(<span class="keyword">false</span>, <span class="keyword">null</span>, GENERIC_SERVER_ERROR_CODE, GENERIC_SERVER_ERROR_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第二个错，<strong>捕获了异常后直接生吞</strong>。</p>
<ol>
<li>在任何时候，我们捕获了异常都不应该生吞，也就是直 接丢弃异常不记录、不抛出。这样的处理方式还不如不捕获异常，因为被生吞掉的异常一旦 导致 Bug，就很难在程序中找到蛛丝马迹，使得 Bug 排查工作难上加难。</li>
<li>通常情况下，生吞异常的原因，可能是不希望自己的方法抛出受检异常，只是为了把异 常“处理掉”而捕获并生吞异常，也可能是想当然地认为异常并不重要或不可能产生。但不 管是什么原因，不管是你认为多么不重要的异常，都不应该生吞，哪怕是一个日志也好。</li>
</ol>
</li>
<li><p>第三个错，<strong>丢弃异常的原始信息</strong>。</p>
</li>
<li><p>第四个错，<strong>抛出异常时不指定任何消息。</strong></p>
</li>
<li><p>总之，如果你捕获了异常打算处理的话，<strong>除了通过日志正确记录异常原始信息外，通常还有 三种处理模式</strong>:</p>
<ol>
<li>转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消 息，而不是随便抛一个无关或没有任何信息的异常，并最好通过 cause 关联老异常。</li>
<li>重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更 严重，需要考虑当前情况是否适合重试。</li>
<li>恢复，即尝试进行降级处理，或使用默认值来替代原始数据。</li>
</ol>
</li>
</ul>
<h2 id="小心-finally-中的异常"><a href="#小心-finally-中的异常" class="headerlink" title="小心 finally 中的异常"></a><strong>小心</strong> <strong>finally</strong> <strong>中的异常</strong></h2><ul>
<li><p><strong>虽然 try 中的逻辑出现了异常，但却被 finally 中的异常覆盖了</strong>。</p>
</li>
<li><p>栗子源码：finally的异常覆盖try异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"finally"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Exception e = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        e = ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(ex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方案一：fianlly的异常，finally自己捕获和处理</li>
<li>方案二： try 中的异常作为主异常抛出，使用 addSuppressed 方法把 finally 中的异常 附加到主异常上</li>
</ul>
</li>
<li><p>try-with-resources来处理资源关闭的正确姿势：<code>implements AutoCloseable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"close error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"useresourceright"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useresourceright</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (TestResource testResource = <span class="keyword">new</span> TestResource()) &#123;</span><br><span class="line">            testResource.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现<code>implements AutoCloseable</code>接口</li>
<li>本质就是，使用 addSuppressed 方法把 finally 中的异常 附加到主异常上</li>
</ul>
</li>
</ul>
<h2 id="千万别把异常定义为静态变量"><a href="#千万别把异常定义为静态变量" class="headerlink" title="千万别把异常定义为静态变量"></a>千万别把异常定义为静态变量</h2><ul>
<li><p>既然我们通常会自定义一个业务异常类型，来包含更多的异常信息，比如异常错误码、友好 的错误提示等，那就需要在业务逻辑各处，手动抛出各种业务异常来返回指定的错误码描述</p>
</li>
<li><p><strong>最终定位到原因是把异常定义为了静态变量，导致异常栈信息错</strong>，也就是大家为什么经常说异常的定位问题不精确的问题，是自己异常定义的问题。而不是jdk的问题。</p>
<ul>
<li>把异常定义为静态变量会导致异常信息固化，这就和异常的栈一定是需要根据当前调用来动 态获取相矛盾。</li>
</ul>
</li>
<li><p>正确定义业务异常姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：导致异常的堆栈信息紊乱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BusinessException ORDEREXISTS = <span class="keyword">new</span> BusinessException(<span class="string">"订单已经存在"</span>, <span class="number">3001</span>);</span><br><span class="line"><span class="comment">//正确姿势：通过不同的方法把每一种异常都 new 出 来抛出即可:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BusinessException <span class="title">orderExists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BusinessException(<span class="string">"订单已经存在"</span>, <span class="number">3001</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="提交线程池的任务出了异常会怎么样"><a href="#提交线程池的任务出了异常会怎么样" class="headerlink" title="提交线程池的任务出了异常会怎么样?"></a>提交线程池的任务出了异常会怎么样?</h2><ul>
<li><p>线程池常用作异步处理或并行处理。那么，把任务提交 到线程池处理，任务本身出现异常时会怎样呢?</p>
</li>
<li><p>栗子源码：execute执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    		<span class="comment">//todo:作用范围多大</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -&gt; log.error(<span class="string">"Thread &#123;&#125; got exception"</span>, thread, throwable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"execute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String prefix = <span class="string">"test"</span>;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(prefix + <span class="string">"%d"</span>)</span><br><span class="line">                .setUncaughtExceptionHandler((thread, throwable) -&gt; log.error(<span class="string">"ThreadPool &#123;&#125; got exception"</span>, thread, throwable))</span><br><span class="line">                .get());</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>);</span><br><span class="line">            log.info(<span class="string">"I'm done : &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadPool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">[<span class="number">08</span>:<span class="number">04</span>:<span class="number">40.258</span>] [test0] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:<span class="number">36</span>  ] - I<span class="string">'m done : 1</span></span><br><span class="line"><span class="string">[08:04:40.260] [test0] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:36  ] - I'</span>m done : <span class="number">2</span></span><br><span class="line">[<span class="number">08</span>:<span class="number">04</span>:<span class="number">40.260</span>] [test0] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:<span class="number">36</span>  ] - I<span class="string">'m done : 3</span></span><br><span class="line"><span class="string">[08:04:40.260] [test0] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:36  ] - I'</span>m done : <span class="number">4</span></span><br><span class="line"><span class="comment">//发生异常切换了线程</span></span><br><span class="line">[<span class="number">08</span>:<span class="number">04</span>:<span class="number">40.261</span>] [test1] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:<span class="number">36</span>  ] - I<span class="string">'m done : 6</span></span><br><span class="line"><span class="string">[08:04:40.261] [test1] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:36  ] - I'</span>m done : <span class="number">7</span></span><br><span class="line">[<span class="number">08</span>:<span class="number">04</span>:<span class="number">40.261</span>] [test1] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:<span class="number">36</span>  ] - I<span class="string">'m done : 8</span></span><br><span class="line"><span class="string">[08:04:40.262] [test1] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:36  ] - I'</span>m done : <span class="number">9</span></span><br><span class="line">[<span class="number">08</span>:<span class="number">04</span>:<span class="number">40.262</span>] [test1] [INFO ] [o.g.t.c.e.t.ThreadPoolAndExceptionController:<span class="number">36</span>  ] - I<span class="string">'m done : 10</span></span><br><span class="line"><span class="string">[08:04:40.267] [test0] [ERROR] [o.g.t.c.e.t.ThreadPoolAndExceptionController:32  ] - ThreadPool Thread[test0,5,main] got exception</span></span><br><span class="line"><span class="string">java.lang.RuntimeException: error</span></span><br><span class="line"><span class="string">	at org.geekbang.time.commonmistakes.exception.threadpoolandexception.ThreadPoolAndExceptionController.lambda$null$2(ThreadPoolAndExceptionController.java:35)</span></span><br><span class="line"><span class="string">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span></span><br><span class="line"><span class="string">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span></span><br><span class="line"><span class="string">	at java.lang.Thread.run(Thread.java:745)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任务 1 到 4 所在的线程是 test0，任务 6 开始运行在线程 test1。由于我的线程池通过 线程工厂为线程使用统一的前缀 test 加上计数器进行命名，因此<strong>从线程名的改变可以知 道因为异常的抛出老线程退出了，线程池只能重新创建一个线程</strong>。如果每个异步任务都 以异常结束，那么线程池可能完全起不到线程重用的作用。</li>
</ul>
</li>
<li><p>因为没有手动捕获异常进行处理，ThreadGroup 帮我们进行了未捕获异常的默认处理， 向标准错误输出打印了出现异常的线程名称和异常信息。<strong>显然，这种没有以统一的错误 日志格式记录错误信息打印出来的形式，对生产级代码是不合适的</strong>，ThreadGroup 的相 关源码如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                             + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义线程池处理异常的正确姿势</p>
<ol>
<li><p>以 execute 方法提交到线程池的异步任务，最好在任务内部做好异常处理;</p>
</li>
<li><p>设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常 处理程序:<code>Thread.setDefaultUncaughtExceptionHandler</code>，对@Async生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  	<span class="comment">//设置默认线程池异步执行任务出错执行的逻辑（全局）</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -&gt; log.error(<span class="string">"Thread &#123;&#125; got exception"</span>, thread, throwable));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(prefix + <span class="string">"%d"</span>)</span><br><span class="line">            .setUncaughtExceptionHandler((thread, throwable) -&gt; log.error(<span class="string">"ThreadPool &#123;&#125; got exception"</span>, thread, throwable))</span><br><span class="line">            .get());</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>栗子源码：submit执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"submitright"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRight</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String prefix = <span class="string">"test"</span>;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(prefix + <span class="string">"%d"</span>).get());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&gt; tasks = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).mapToObj(i -&gt; threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>);</span><br><span class="line">            log.info(<span class="string">"I'm done : &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        tasks.forEach(task -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"Got exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadPool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们执行submit就是关心执行结果，当我们没有到FutureTask.get的时候，是没有异常信息打印的。把执行过程的异常封装为<code>ExecutionException</code></p>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes this future to report an &#123;<span class="doctag">@link</span> ExecutionException&#125;</span></span><br><span class="line"><span class="comment"> * with the given throwable as its cause, unless this future has</span></span><br><span class="line"><span class="comment"> * already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the &#123;<span class="doctag">@link</span> #run&#125; method</span></span><br><span class="line"><span class="comment"> * upon failure of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the cause of failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="日志-日志记录真没你想象的那么简单"><a href="#日志-日志记录真没你想象的那么简单" class="headerlink" title="日志:日志记录真没你想象的那么简单"></a>日志:日志记录真没你想象的那么简单</h1><ul>
<li>日志框架众多，不同的类库可能会使用不同的日志框架，如何兼容是一个问题。配置复杂且容易出错。日志配置文件通常很复杂，因此有些开发同学会从其他项目或者 网络上复制一份配置文件，但却不知道如何修改，甚至是胡乱修改，造成很多问题。比 如，重复记录日志的问题、同步日志的性能问题、异步记录的错误配置问题。</li>
<li>Logback、Log4j、Log4j2、commons-logging、JDK 自带的 java.util.logging 等，都 是 Java 体系的日志框架，确实非常多。而不同的类库，还可能选择使用不同的日志框架。 这样一来，日志的统一管理就变得非常困难。为了解决这个问题，就有了 SLF4J(Simple Logging Facade For Java)<img alt="image-20200501110039844" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gecrnefxsfj30xq0u00yo.jpg" class="lazyload"><ul>
<li>一是提供了统一的日志门面 API，即图中紫色部分，实现了中立的日志记录 API。</li>
<li>二是桥接功能，即图中蓝色部分，用来把各种日志框架的 API(图中绿色部分)桥接到 SLF4J API。这样一来，即便你的程序中使用了各种日志 API 记录日志，最终都可以桥接 到 SLF4J 门面 API。</li>
<li>三是适配功能，即图中红色部分，可以实现 SLF4J API 和实际日志框架(图中灰色部 分)的绑定。SLF4J 只是日志标准，我们还是需要一个实际的日志框架。日志框架本身 没有实现 SLF4J API，所以需要有一个前置转换。Logback 就是按照 SLF4J API 标准实 现的，因此不需要绑定模块做转换。</li>
<li>需要理清楚的是，虽然我们可以使用 log4j-over-slf4j 来实现 Log4j 桥接到 SLF4J，也可 以使用 slf4j-log4j12 实现 SLF4J 适配到 Log4j，也把它们画到了一列，<strong>但是它不能同时使 用它们，否则就会产生死循环。jcl 和 jul 也是同样的道理。</strong></li>
</ul>
</li>
</ul>
<h2 id="为什么我的日志会重复记录？"><a href="#为什么我的日志会重复记录？" class="headerlink" title="为什么我的日志会重复记录？"></a>为什么我的日志会重复记录？</h2><ul>
<li><p>用几个栗子复习日志（Logback）配置，<strong>第一个案例是，logger 配置继承关系导致日志重复记录</strong>。</p>
</li>
<li><p>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL（日志级别从高到底）</p>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--首先将 CONSOLE Appender 定义为 ConsoleAppender，也就是把日志 输出到控制台(System.out/System.err);然后通过 PatternLayout 定义了日志的输 出格式。--&gt;</span><br><span class="line">    &lt;appender name=<span class="string">"CONSOLE"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">        &lt;layout <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;!-- 实现了一个 Logger 配置，将应用包的日志级别设置为 DEBUG、日志输出 同样使用 CONSOLE Appender。--&gt;</span><br><span class="line">    &lt;logger name=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> level=<span class="string">"DEBUG"</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"CONSOLE"</span>/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;!--设置了全局的日志级别为 INFO，日志输出使用 CONSOLE Appender--&gt;</span><br><span class="line">    &lt;root level=<span class="string">"INFO"</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"CONSOLE"</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">          </span><br><span class="line">&lt;!--    配置的初衷是实现自定义的 logger 配置，让应用内的日志暂 时开启 DEBUG 级别的日志记录。--&gt;</span><br><span class="line">&lt;logger name=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> level=<span class="string">"DEBUG"</span>/&gt;          </span><br><span class="line">          </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"log"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"debug"</span>);</span><br><span class="line">        log.info(<span class="string">"info"</span>);</span><br><span class="line">        log.warn(<span class="string">"warn"</span>);</span><br><span class="line">        log.error(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CONSOLE 这个 Appender 同时挂载到了两个 Logger 上，一个是我们定义的，一个是，由于我们定义的继承自root，所以同一条日志既会通 过 logger 记录，也会发送到 root 记录，因此应用 package 下的日志出现了重复记录。</p>
</li>
<li><p>如果自定义的需要把日志输出到不同的 Appender，比如将应用的日志输出到文件 app.log，把其他框架的日志输出到控制台，可以设置的 additivity 属性为 false，这样就 不会继承的 Appender 了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>第二个案例是，错误配置 LevelFilter 造成日志重复记录。</strong></p>
</li>
<li><p>错误配置分析：在记录日志到控制台的同时，把日志记录按照不同的级别记 录到两个文件中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logDir"</span> <span class="attr">value</span>=<span class="string">"./logs"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"app.name"</span> <span class="attr">value</span>=<span class="string">"common-mistakes"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    第一个 ConsoleAppender，用于把所有日志输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        定义了一个 FileAppender，用于记录文件日志，并定义了文件名、记录 日志的格式和编码等信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_info.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--         LevelFilter 过滤日志， 将过滤级别设置为 INFO，目的是希望 _info.log 文件中可以记录 INFO 级别的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        使用 ThresholdFilter 来过滤日 志，过滤级别设置为 WARN，目的是把 WARN 以上级别的日志记录到另一个 _error.log 文件中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--	定义的 root 引用了三个 Appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO_FILE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR_FILE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>但是上面的配置,没有按照我们的期望执行,在info文件包括了：info、warn、error的日志。</p>
</li>
<li><p>问题解决：增加配置项。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_info.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--解决方案：只接受INFO级别的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>源码分析：复习一下 ThresholdFilter 和 LevelFilter 的配置方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThresholdFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Level level;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.getLevel().isGreaterOrEqual(level)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.DENY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelFilter</span> <span class="keyword">extends</span> <span class="title">AbstractMatcherFilter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Level level;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.getLevel().equals(level)) &#123;</span><br><span class="line">            <span class="keyword">return</span> onMatch;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> onMismatch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//自定义：LevelsFilter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleLevelsFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String levels;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; levelList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (levelList == <span class="keyword">null</span> &amp;&amp; !StringUtils.isEmpty(levels)) &#123;</span><br><span class="line">            levelList = Arrays.asList(levels.split(<span class="string">"\\|"</span>)).stream()</span><br><span class="line">                    .map(item -&gt; Level.valueOf(item))</span><br><span class="line">                    .map(level -&gt; level.toInt())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (levelList.contains(event.getLevel().toInt()))</span><br><span class="line">            <span class="keyword">return</span> FilterReply.ACCEPT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FilterReply.DENY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和 ThresholdFilter 不同的是，LevelFilter 仅仅配置 level 是无法真正起作用的。<strong>由于没有 配置 onMatch 和 onMismatch 属性，所以相当于这个过滤器是无用的，导致 INFO 以 上级别的日志都记录了。</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="使用异步日志改善性能的坑"><a href="#使用异步日志改善性能的坑" class="headerlink" title="使用异步日志改善性能的坑"></a>使用异步日志改善性能的坑</h2><ul>
<li><p>模拟实验标准：记录1000次日志，每次记录1MB记录大小的字符串。和记录10000 次日志的耗时。分别是9s和44s,耗时比较长。</p>
</li>
<li><p>栗子源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"performance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">(@RequestParam(name = <span class="string">"count"</span>, defaultValue = <span class="string">"1000"</span>)</span> <span class="keyword">int</span> count) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成1.9MB大小的字符串</span></span><br><span class="line">        String payload = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">                .mapToObj(__ -&gt; <span class="string">"a"</span>)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">""</span>)) + UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环次数写入文件</span></span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, count).forEach(i -&gt; log.info(<span class="string">"&#123;&#125; &#123;&#125;"</span>, i, payload));</span><br><span class="line">				<span class="comment">// EvaluatorFilter(求值过滤器)</span></span><br><span class="line">        Marker timeMarker = MarkerFactory.getMarker(<span class="string">"time"</span>);</span><br><span class="line"></span><br><span class="line">        log.info(timeMarker, <span class="string">"took &#123;&#125; ms"</span>, System.currentTimeMillis() - begin);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//配置文件    </span></span><br><span class="line">    &lt;appender name=<span class="string">"FILE"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span><br><span class="line">        &lt;file&gt;app.log&lt;/file&gt;</span><br><span class="line">        &lt;encoder <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name=<span class="string">"CONSOLE"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">        &lt;layout <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">        &lt;filter <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.filter.EvaluatorFilter"</span>&gt;</span><br><span class="line">          	&lt;!-- EvaluatorFilter(求值过滤器) --&gt;</span><br><span class="line">            &lt;evaluator <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.boolex.OnMarkerEvaluator"</span>&gt;</span><br><span class="line">                &lt;marker&gt;time&lt;/marker&gt;</span><br><span class="line">            &lt;/evaluator&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=<span class="string">"INFO"</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"FILE"</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">"CONSOLE"</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在追加日志的时候，是直接把日志写入 OutputStream 中，属于同 步记录日志:</span></span><br><span class="line">FileAppender&lt;E&gt; extends OutputStreamAppender&lt;E&gt; extends UnsynchronizedAppenderBase&lt;E&gt;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(E event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// this step avoids LBCLASSIC-139</span></span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> DeferredProcessingAware) &#123;</span><br><span class="line">                ((DeferredProcessingAware) event).prepareForDeferredProcessing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// the synchronization prevents the OutputStream from being closed while we</span></span><br><span class="line">            <span class="comment">// are writing. It also prevents multiple threads from entering the same</span></span><br><span class="line">            <span class="comment">// converter. Converters assume that they are in a synchronized block.</span></span><br><span class="line">            <span class="comment">// lock.lock();</span></span><br><span class="line">          </span><br><span class="line">					  <span class="comment">//编码LoggingEvent</span></span><br><span class="line">            <span class="keyword">byte</span>[] byteArray = <span class="keyword">this</span>.encoder.encode(event);</span><br><span class="line">          	<span class="comment">//写字节流</span></span><br><span class="line">            writeBytes(byteArray);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="comment">// as soon as an exception occurs, move to non-started state</span></span><br><span class="line">            <span class="comment">// and add a single ErrorStatus to the SM.</span></span><br><span class="line">            <span class="keyword">this</span>.started = <span class="keyword">false</span>;</span><br><span class="line">            addStatus(<span class="keyword">new</span> ErrorStatus(<span class="string">"IO failure in appender"</span>, <span class="keyword">this</span>, ioe));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] byteArray)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(byteArray == <span class="keyword">null</span> || byteArray.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//这个OutputStream其实是一个ResilientFileOutputStream，其内部使用的是带缓存</span></span><br><span class="line">            <span class="keyword">this</span>.outputStream.write(byteArray);</span><br><span class="line">            <span class="keyword">if</span> (immediateFlush) &#123;</span><br><span class="line">                <span class="keyword">this</span>.outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方案：使用 Logback 提供的 AsyncAppender 即可实现异步的日志记录。 AsyncAppende 类似装饰模式，也就是在不改变类原有基本功能的情况下为其增添新功 能。这样，我们就可以把 AsyncAppender 附加在其他的 Appender 上，将其变为异步 的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ASYNCFILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试一下可以发现，记录 1000 次日志和 10000 次日志的调用耗时，分别是 735 毫秒和 668 毫秒。性能居然那么好，会有坑吗？</p>
</li>
<li><p><strong>遇到过很多关于 AsyncAppender 异步日志的 坑，这些坑可以归结为三类:</strong></p>
<ul>
<li>记录异步日志撑爆内存;</li>
<li>记录异步日志出现日志丢失;</li>
<li>记录异步日志出现阻塞。</li>
</ul>
</li>
</ul>
</li>
<li><p>栗子源码：模拟AsyncAppender异步记录日志，日志丢失的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name=<span class="string">"CONSOLE"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.geekbang.time.commonmistakes.logging.async.MySlowAppender"</span>&gt;</span><br><span class="line">		&lt;layout <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n&lt;/pattern&gt;</span><br><span class="line">		&lt;/layout&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">	&lt;appender name=<span class="string">"ASYNC"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span><br><span class="line">		&lt;appender-ref ref=<span class="string">"CONSOLE"</span> /&gt;</span><br><span class="line">        &lt;includeCallerData&gt;true&lt;/includeCallerData&gt;</span><br><span class="line">        &lt;!--		&lt;discardingThreshold&gt;200&lt;/discardingThreshold&gt;--&gt;</span><br><span class="line">        &lt;!--		&lt;queueSize&gt;1000&lt;/queueSize&gt;--&gt;</span><br><span class="line">        &lt;!--		&lt;neverBlock&gt;true&lt;/neverBlock&gt;--&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line">	&lt;root level=<span class="string">"INFO"</span>&gt;</span><br><span class="line">		&lt;appender-ref ref=<span class="string">"ASYNC"</span> /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//重写ConsoleAppender，模拟写入慢日志    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySlowAppender</span> <span class="keyword">extends</span> <span class="title">ConsoleAppender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟慢日志</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.subAppend(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>循环写了1000次日志，但是最后写入成功的只有215条记录。</p>
</li>
<li><p>源码分析：AsyncAppender 提供了一些配置参数，而我们没用对。我们结 合相关源码分析一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncAppender</span> <span class="keyword">extends</span> <span class="title">AsyncAppenderBase</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> includeCallerData = <span class="keyword">false</span>;<span class="comment">//是否收集调用方数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Events of level TRACE, DEBUG and INFO are deemed to be discardable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the event is of level TRACE, DEBUG or INFO false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDiscardable</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        Level level = event.getLevel();</span><br><span class="line">        <span class="keyword">return</span> level.toInt() &lt;= Level.INFO_INT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(ILoggingEvent eventObject)</span> </span>&#123;</span><br><span class="line">        eventObject.prepareForDeferredProcessing();</span><br><span class="line">        <span class="keyword">if</span> (includeCallerData)</span><br><span class="line">            eventObject.getCallerData();<span class="comment">//丢弃&lt;=INFO级别的日志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIncludeCallerData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> includeCallerData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncludeCallerData</span><span class="params">(<span class="keyword">boolean</span> includeCallerData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.includeCallerData = includeCallerData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncAppenderBase</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnsynchronizedAppenderBase</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">AppenderAttachable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  BlockingQueue&lt;E&gt; blockingQueue;<span class="comment">//异步日志的关键，阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default buffer size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">256</span>;<span class="comment">//默认队列大小</span></span><br><span class="line">    <span class="keyword">int</span> queueSize = DEFAULT_QUEUE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> appenderCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> discardingThreshold = UNDEFINED;</span><br><span class="line">    <span class="keyword">boolean</span> neverBlock = <span class="keyword">false</span>;<span class="comment">//控制队列满的时候加入数据时是否直接丢弃，不会阻塞等待</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isStarted())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (appenderCount == <span class="number">0</span>) &#123;</span><br><span class="line">            addError(<span class="string">"No attached appenders found."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queueSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            addError(<span class="string">"Invalid queue size ["</span> + queueSize + <span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;E&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (discardingThreshold == UNDEFINED)</span><br><span class="line">            discardingThreshold = queueSize / <span class="number">5</span>;<span class="comment">//默认丢弃阈值是队列剩余量低于队列长度（剩余日志条数）</span></span><br><span class="line">        addInfo(<span class="string">"Setting discardingThreshold to "</span> + discardingThreshold);</span><br><span class="line">        worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        worker.setName(<span class="string">"AsyncAppender-Worker-"</span> + getName());</span><br><span class="line">        <span class="comment">// make sure this instance is marked as "started" before staring the worker Thread</span></span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">        worker.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (neverBlock) &#123;</span><br><span class="line">            blockingQueue.offer(eventObject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            putUninterruptibly(eventObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//阻塞队列还剩下多少的时候丢弃&amp;&amp;丢弃日志级别</span></span><br><span class="line">        <span class="keyword">if</span> (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preprocess(eventObject);</span><br><span class="line">        put(eventObject);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>includeCallerData 用于控制是否收集调用方数据，默认是 false，此时方法行号、方法 名等信息将不能显示()。</li>
<li>queueSize 用于控制阻塞队列大小，使用的 ArrayBlockingQueue 阻塞队列()，默认大小是 256，即内存中最多保存 256 条日志。</li>
<li>discardingThreshold 是控制丢弃日志的阈值，主要是防止队列满后阻塞。默认情况 下，队列剩余量低于队列长度的 20%，就会丢弃 TRACE、DEBUG 和 INFO 级别的日 志。</li>
<li>neverBlock 用于控制队列满的时候，加入的数据是否直接丢弃，不会阻塞等待，默认是 false(允许阻塞)。这里需要注意一下 offer 方法和 put 方法的区别，当队列 满的时候 offer 方法不阻塞，而 put 方法会阻塞;neverBlock 为 true 时，使用 offer 方法。</li>
</ul>
</li>
<li><p>看到默认队列大小为 256，达到 80% 容量后开始丢弃 &lt;=INFO 级别的日志后，我们就可 以理解日志中为什么只有 215 条 INFO 日志了。</p>
</li>
<li><p>我们可以继续分析下异步记录日志出现坑的原因。</p>
<ul>
<li>queueSize 设置得特别大，就可能会导致 OOM。</li>
<li>queueSize 设置得比较小(默认值就非常小)，且 discardingThreshold 设置为大于 0 的值(或者为默认值)，队列剩余容量少于 discardingThreshold 的配置就会丢弃 &lt;=INFO 的日志。这里的坑点有两个。一是，因为 discardingThreshold 的存在，设置 queueSize 时容易踩坑。比如，本例中最大日志并发是 1000，即便设置 queueSize 为 1000 同样会导致日志丢失。二是，discardingThreshold 参数容易有歧义，它不是百分 比，而是日志条数。对于总容量 10000 的队列，如果希望队列剩余容量少于 1000 条的 时候丢弃，需要配置为 1000。</li>
<li>neverBlock 默认为 false，意味着总可能会出现阻塞。如果 discardingThreshold 为 0，那么队列满时再有日志写入就会阻塞;如果 discardingThreshold 不为 0，也只会丢 弃 &lt;=INFO 级别的日志，那么出现大量错误日志时，还是会阻塞程序。</li>
</ul>
</li>
<li><p>可以看出 queueSize、discardingThreshold 和 neverBlock 这三个参数息息相关，务必 按需进行设置和取舍，到底是性能为先，还是数据不丢为先:</p>
<ul>
<li>如果考虑绝对性能为先，那就设置 neverBlock 为 true，永不阻塞。</li>
<li>如果考虑绝对不丢数据为先，那就设置 discardingThreshold 为 0，即使是 &lt;=INFO 的 级别日志也不会丢，但最好把 queueSize 设置大一点，毕竟默认的 queueSize 显然太 小，太容易阻塞。</li>
<li>如果希望兼顾两者，可以丢弃不重要的日志，把 queueSize 设置大一点，再设置一个合 理的 discardingThreshold。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用日志占位符就不需要进行日志级别判断了"><a href="#使用日志占位符就不需要进行日志级别判断了" class="headerlink" title="使用日志占位符就不需要进行日志级别判断了?"></a>使用日志占位符就不需要进行日志级别判断了?</h2><p>不知道你有没有听人说过:SLF4J 的{}占位符语法，到真正记录日志时才会获取实际参数， 因此解决了日志数据获取的性能问题。你觉得，这种说法对吗?（错误说法）</p>
<ul>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细节注解</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"logging"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SLF4J 的&#123;&#125;占位符语法，到真正记录日志时才会获取实际参数， 因此解决了日志数据获取的性能问题。错误说法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">      	<span class="comment">//拼接字符串方式记录 slowString;</span></span><br><span class="line">        stopWatch.start(<span class="string">"debug1"</span>);</span><br><span class="line">        log.debug(<span class="string">"debug1:"</span> + slowString(<span class="string">"debug1"</span>));</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">				<span class="comment">//使用占位符方式记录 slowString;</span></span><br><span class="line">        stopWatch.start(<span class="string">"debug2"</span>);</span><br><span class="line">        log.debug(<span class="string">"debug2:&#123;&#125;"</span>, slowString(<span class="string">"debug2"</span>));</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">				<span class="comment">//先判断日志级别是否启用 DEBUG。</span></span><br><span class="line">        stopWatch.start(<span class="string">"debug3"</span>);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"debug3:&#123;&#125;"</span>, slowString(<span class="string">"debug3"</span>));</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">				<span class="comment">//最佳实践</span></span><br><span class="line">        stopWatch.start(<span class="string">"debug4"</span>);</span><br><span class="line">        log.debug(<span class="string">"debug4:&#123;&#125;"</span>, () -&gt; slowString(<span class="string">"debug4"</span>));</span><br><span class="line">        stopWatch.stop();</span><br><span class="line"></span><br><span class="line">        log.info(stopWatch.prettyPrint());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">slowString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"slowString called via "</span> + s);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实验结果</span></span><br><span class="line">slowString called via debug1</span><br><span class="line">slowString called via debug2</span><br><span class="line">[<span class="number">18</span>:<span class="number">11</span>:<span class="number">38.517</span>] [http-nio-<span class="number">45678</span>-exec-<span class="number">2</span>] [INFO ] [o.g.t.c.l.placeholder.LoggingController:<span class="number">32</span>  ] - StopWatch <span class="string">''</span>: running time = <span class="number">2008376517</span> ns</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="number">1004357006</span>  <span class="number">050</span>%  debug1</span><br><span class="line"><span class="number">1004003087</span>  <span class="number">050</span>%  debug2</span><br><span class="line"><span class="number">000002588</span>  <span class="number">000</span>%  debug3</span><br><span class="line"><span class="number">000013836</span>  <span class="number">000</span>%  debug4</span><br></pre></td></tr></table></figure>

<ul>
<li>如果我们记录 DEBUG 日志，并设置只记录 &gt;=INFO 级别的日志，程序是否也会耗时 1 秒 呢?我们使用三种方法来测试。</li>
<li>使用占位符方式记录 slowString 的方式，同样需要耗时 1 秒，是因为这种方式虽然允许我 们传入 Object，不用拼接字符串，但也只是延迟(如果日志不记录那么就是省去)了日志 参数对象.toString() 和字符串拼接的耗时。</li>
<li>除非事先判断日志级别，否则必然会调用 slowString 方法。<strong>回到之前提的 问题，使用{}占位符语法不能通过延迟参数值获取，来解决日志数据获取的性能问题。</strong><ul>
<li>除了事先判断日志级别，我们还可以通过 lambda 表达式进行延迟参数内容获取。但， SLF4J 的 API 还不支持 lambda，因此需要使用 Log4j2 日志 API，把 Lombok 的 @Slf4j 注解替换为 @Log4j2 注解，这样就可以提供一个 lambda 表达式作为提供参数数据的方 法:</li>
<li>其实，我们只是换成了 Log4j2 API，真正的日志记录还是走的 Logback 框架。没错，这 就是 SLF4J 适配的一个好处。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>我将记录日志的坑，总结为框架使用配置和记录本身两个方面。</p>
<ul>
<li>Java 的日志框架众多，SLF4J 实现了这些框架记录日志的统一。在使用 SLF4J 时，我们需 要理清楚其桥接 API 和绑定这两个模块。如果程序启动时出现 SLF4J 的错误提示，那很可 能是配置出现了问题，可以使用 Maven 的 dependency:tree 命令梳理依赖关系。</li>
<li>Logback 是 Java 最常用的日志框架，其配置比较复杂，你可以参考官方文档中关于 Appender、Layout、Filter 的配置，切记不要随意从其他地方复制别人的配置，避免出现 错误或与当前需求不符。</li>
<li>使用异步日志解决性能问题，是用空间换时间。但空间毕竟有限，当空间满了之后，我们要 考虑是阻塞等待，还是丢弃日志。如果更希望不丢弃重要日志，那么选择阻塞等待;如果更 希望程序不要因为日志记录而阻塞，那么就需要丢弃日志。</li>
<li>最后，我强调的是，日志框架提供的参数化日志记录方式不能完全取代日志级别的判断。如 果你的日志量很大，获取日志参数代价也很大，就要进行相应日志级别的判断，避免不记录 日志也要花费时间获取日志参数的问题。</li>
</ul>
<h1 id="文件IO-实现高效正确的文件读写并非易事"><a href="#文件IO-实现高效正确的文件读写并非易事" class="headerlink" title="文件IO:实现高效正确的文件读写并非易事"></a><strong>文件</strong>IO:实现高效正确的文件读写并非易事</h1><p>随着数据库系统的成熟和普及，需要直接做文件 IO 操作的需求越来越少，这就导致我们对 相关 API 不够熟悉，以至于遇到类似文件导出、三方文件对账等需求时，只能临时抱佛 脚，随意搜索一些代码完成需求，出现性能问题或者 Bug 后不知从何处入手。</p>
<p>今天这篇文章，我就会从字符编码、缓冲区和文件句柄释放这 3 个常见问题出发，和你分享如何解决与文件操作相关的性能问题或者 Bug。</p>
<h2 id="文件读写需要确保字符编码一致"><a href="#文件读写需要确保字符编码一致" class="headerlink" title="文件读写需要确保字符编码一致"></a>文件读写需要确保字符编码一致</h2><ul>
<li><p>一份相同的代码，在两台机器出现乱码的问题如何解决</p>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 GBK 编码把“你好 hi”写入一个名为 hello.txt 的文本文件，</span></span><br><span class="line"><span class="comment"> * 然后直接以字节数组形式读取文件内容，转换为十六进制字符串输出到日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"hello.txt"</span>));</span><br><span class="line">    Files.write(Paths.get(<span class="string">"hello.txt"</span>), <span class="string">"你好hi"</span>.getBytes(Charset.forName(<span class="string">"GBK"</span>)));</span><br><span class="line">    log.info(<span class="string">"bytes:&#123;&#125;"</span>, Hex.encodeHexString(Files.readAllBytes(Paths.get(<span class="string">"hello.txt"</span>))).toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//读取机器的默认编码格式</span></span><br><span class="line">    log.info(<span class="string">"charset: &#123;&#125;"</span>, Charset.defaultCharset());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    String content = <span class="string">""</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//FileReader 是以当前机器的默认字符集来读取文件的</span></span><br><span class="line">    <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"hello.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            content += <span class="keyword">new</span> String(chars, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//文件格式是GBK，使用UTF-8采用字符集操作，导致乱码</span></span><br><span class="line">    log.info(<span class="string">"result:&#123;&#125;"</span>, content);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//UTF-8 编码 的“你好”的十六进制是 E4BDA0E5A5BD，每一个汉字需要三个字节;而 GBK 编码的汉 字，每一个汉字两个字节。</span></span><br><span class="line">    Files.write(Paths.get(<span class="string">"hello2.txt"</span>), <span class="string">"你好hi"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line">    log.info(<span class="string">"bytes:&#123;&#125;"</span>, Hex.encodeHexString(Files.readAllBytes(Paths.get(<span class="string">"hello2.txt"</span>))).toUpperCase());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正确姿势：读取GBK写入的字符。</span></span><br><span class="line"><span class="comment"> * 最佳实践：FileReader 是以当前机器的默认字符集来读取文件的。</span></span><br><span class="line"><span class="comment"> * 按照文档所说，直接使用 FileInputStream 拿文件流， 然后使用 InputStreamReader 读取字符流，并指定字符集为 GBK。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    String content = <span class="string">""</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"hello.txt"</span>);</span><br><span class="line">         InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream, Charset.forName(<span class="string">"GBK"</span>))) &#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = inputStreamReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            content += <span class="keyword">new</span> String(chars, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    log.info(<span class="string">"result: &#123;&#125;"</span>, content);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正确姿势读取GBK字符02</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    log.info(<span class="string">"result: &#123;&#125;"</span>, Files.readAllLines(Paths.get(<span class="string">"hello.txt"</span>), Charset.forName(<span class="string">"GBK"</span>)).stream().findFirst().orElse(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然我们打开文本文件时看到的是“你好 hi”，但不管是什么文字，计算机中都是按照一 定的规则将其以二进制保存的。</p>
<ul>
<li>这个规则就是字符集，字符集枚举了所有支持的字符映射成 二进制的映射表。</li>
<li>在处理文件读写的时候，如果是在字节层面进行操作，那么不会涉及字符 编码问题;而如果需要在字符层面进行读写的话，就需要明确字符的编码方式也就是字符集 了。</li>
</ul>
</li>
<li><p>最佳实践：FileReader 是以当前机器的默认字符集来读取文件的。按照文档所说，直接使用 FileInputStream 拿文件流， 然后使用 InputStreamReader 读取字符流，并指定字符集为 GBK。</p>
</li>
<li><p><code>java.nio.file.Files#readAllLines(java.nio.file.Path, java.nio.charset.Charset)</code><strong>但这种方式有个问题是，读取超出内存大小的大文件时会出现 OOM</strong>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">readAllLines</span><span class="params">(Path path, Charset cs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = newBufferedReader(path, cs)) &#123;</span><br><span class="line">      	<span class="comment">//把文件读取的所有内容都读取到List中</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            String line = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            result.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案，按需读取，而不是一次性读取所有内容。解决方案就是 Files 类的 lines 方法</li>
</ul>
</li>
</ul>
<h2 id="使用-Files-类静态方法进行文件操作注意释放文件句柄"><a href="#使用-Files-类静态方法进行文件操作注意释放文件句柄" class="headerlink" title="使用 Files 类静态方法进行文件操作注意释放文件句柄"></a><strong>使用</strong> <strong>Files</strong> <strong>类静态方法进行文件操作注意释放文件句柄</strong></h2><ul>
<li><p>栗子源码：读取一个5G文件大小的行数，证明Files.lines是一行行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readLargeFileWrong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    log.info(<span class="string">"lines &#123;&#125;"</span>, Files.readAllLines(Paths.get(<span class="string">"large.txt"</span>)).size());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readLargeFileRight</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    Files.lines(Paths.get(<span class="string">"large.txt"</span>)).forEach(line -&gt; atomicLong.incrementAndGet());</span><br><span class="line">    log.info(<span class="string">"lines &#123;&#125;"</span>, atomicLong.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码优化点：问题在于读取完文件后没有关闭。我们通常会认为静态方法的调用不涉及资源释放，因为方 法调用结束自然代表资源使用完成，由 API 释放资源，但对于 Files 类的一些返回 Stream 的方法并不是这样。这，是一个很容易被忽略的严重问题。</li>
</ul>
</li>
<li><p>句柄栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//ps aux | grep CommonMistakesApplication</span></span><br><span class="line">      <span class="comment">//lsof -p 63937</span></span><br><span class="line">    	<span class="comment">//lsof -p 63937 | grep demo.txt | wc -l</span></span><br><span class="line">      LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">      IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>).forEach(i -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">              Files.lines(Paths.get(<span class="string">"demo.txt"</span>)).forEach(line -&gt; longAdder.increment());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      log.info(<span class="string">"total : &#123;&#125;"</span>, longAdder.longValue());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//正确读写文件的正确姿势</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html</span></span><br><span class="line">      LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">      IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>).forEach(i -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"demo.txt"</span>))) &#123;</span><br><span class="line">              lines.forEach(line -&gt; longAdder.increment());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      log.info(<span class="string">"total : &#123;&#125;"</span>, longAdder.longValue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序在生产上运行一段时间后就会出现 too many files 的错误， 我们想当然地认为是 OS 设置的最大文件句柄太小了，就让运维放开这个限制，但放开后还 是会出现这样的问题。经排查发现，其实是文件句柄没有释放导致的，问题就出在 Files.lines 方法上。</li>
<li><code>lsof -p 63937 | grep demo.txt | wc -l</code>查看打开了1w多的文件，句柄被消耗完了。</li>
<li><strong>其实，在JDK 文档中有提到，注意使用 try-with-resources 方式来配合，确保流的 close 方法可以调用释放资源。</strong></li>
<li>这也很容易理解，使用流式处理，如果不显式地告诉程序什么时候用完了流，程序又如何知 道呢，它也不能帮我们做主何时关闭文件。</li>
</ul>
</li>
<li><p>源码分析:try-with-resources来处理资源关闭的正确姿势：<code>implements AutoCloseable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path, Charset cs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = Files.newBufferedReader(path, cs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> br.lines().onClose(asUncheckedRunnable(br));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error|RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    e.addSuppressed(ex);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">asUncheckedRunnable</span><span class="params">(Closeable c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedIOException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closeable</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this stream and releases any system resources associated</span></span><br><span class="line"><span class="comment">     * with it. If the stream is already closed then invoking this</span></span><br><span class="line"><span class="comment">     * method has no effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; As noted in &#123;<span class="doctag">@link</span> AutoCloseable#close()&#125;, cases where the</span></span><br><span class="line"><span class="comment">     * close may fail require careful attention. It is strongly advised</span></span><br><span class="line"><span class="comment">     * to relinquish the underlying resources and to internally</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;mark&lt;/em&gt; the &#123;<span class="doctag">@code</span> Closeable&#125; as closed, prior to throwing</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> IOException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 lines 方法源码可以发现，Stream 的 close 注册了一个回调，来关闭 BufferedReader 进行资源释放。</li>
</ul>
</li>
<li><p>BufferedReader ，从命名上可以看出，使用 BufferedReader 进行字符流读取时，用到了缓冲。这里缓冲 Buffer 的意思是，使用一块内存区域作为直接操作的中转。</p>
<ul>
<li>读取文件操作就是一次性读取一大块数据(比如 8KB)到缓冲区，后续的读取可以 直接从缓冲区返回数据，而不是每次都直接对应文件 IO。</li>
<li>写操作也是类似。如果每次写几 十字节到文件都对应一次 IO 操作，那么写一个几百兆的大文件可能就需要千万次的 IO 操 作，耗时会非常久。</li>
</ul>
</li>
</ul>
<h2 id="try-with-resources语法糖"><a href="#try-with-resources语法糖" class="headerlink" title="try-with-resources语法糖"></a>try-with-resources语法糖</h2><ul>
<li><p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//try-with-resouces</span></span><br><span class="line">        <span class="keyword">try</span> (NoahResource nr = <span class="keyword">new</span> NoahResource()) &#123;</span><br><span class="line">            nr.read(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NoahResource nr = <span class="keyword">new</span> NoahResource();</span><br><span class="line">        Throwable var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nr.read((String)<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            var2 = var11;</span><br><span class="line">            <span class="keyword">throw</span> var11;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        nr.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                        var2.addSuppressed(var10);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nr.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="注意读写文件要考虑设置缓冲区"><a href="#注意读写文件要考虑设置缓冲区" class="headerlink" title="注意读写文件要考虑设置缓冲区"></a>注意读写文件要考虑设置缓冲区</h2><ul>
<li><p>场景：开发人员写的文件处理代码大概是这样的:使用 FileInputStream 获得一个文件输入 流，然后调用其 read 方法每次读取一个字节，最后通过一个 FileOutputStream 文件输出 流把处理后的结果写入另一个文件。</p>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个文件随机写入 100 万行数据，文件大小在 35MB 左 右:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    Files.write(Paths.get(<span class="string">"src.txt"</span>),</span><br><span class="line">            IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>).mapToObj(i -&gt; UUID.randomUUID().toString()).collect(Collectors.toList())</span><br><span class="line">            , UTF_8, CREATE, TRUNCATE_EXISTING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读一个字节，写入一个字节</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用 FileInputStream 获得一个文件输入 流，然后调用其 read 方法每次读取一个字节，最后通过一个 FileOutputStream 文件输出 流把处理后的结果写入另一个文件</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 显然，每读取一个字节、每写入一个字节都进行一次 IO 操作，代价太大了。</span></span><br><span class="line"><span class="comment"> * 复制一个 35MB 的文件居然耗时 190 秒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perByteOperation</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"src.txt"</span>);</span><br><span class="line">         FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"dest.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span> ((i = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用缓存区</span></span><br><span class="line"><span class="comment"> * 改良后，使用 100 字节作为缓冲区，使用 FileInputStream 的 byte[]的重载来一次性读取 一定字节的数据，</span></span><br><span class="line"><span class="comment"> * 同时使用 FileOutputStream 的 byte[]的重载实现一次性从缓冲区写入 一定字节的数据到文件:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferOperationWith100Buffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"src.txt"</span>);</span><br><span class="line">         FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"dest.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>显然，每读取一个字节、每写入一个字节都进行一次 IO 操作，代价太大了</strong></li>
<li>使用Buffer缓存区。仅仅使用了 100 个字节的缓冲区作为过渡，完成 35M 文件的复制耗时缩短到了 26 秒，是 无缓冲时性能的 7 倍。</li>
<li>实现文件读写还要自己 new 一个缓冲区出来，太麻烦了，不是有一个 BufferedInputStream 和 BufferedOutputStream 可以实现输入输出流的缓冲处理吗?是的，它们在内部实现了一个默认 8KB 大小的缓冲区。但是，在使用 BufferedInputStream 和 BufferedOutputStream 时，</li>
<li><strong>我还是建议你再使用一个缓冲进行 读写，不要因为它们实现了内部缓冲就进行逐字节的操作。</strong></li>
</ul>
</li>
<li><p>关于读写文件Buffered最佳实践栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用BufferedInputStream和BufferedOutputStream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferedStreamByteOperation</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src.txt"</span>));</span><br><span class="line">         BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"dest.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span> ((i = bufferedInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bufferedOutputStream.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 额外使用一个8KB缓冲，再使用BufferedInputStream和BufferedOutputStream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferedStreamBufferOperation</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src.txt"</span>));</span><br><span class="line">         BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"dest.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bufferedOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接使用FileInputStream和FileOutputStream，再使用一个8KB的缓冲</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">largerBufferOperation</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"src.txt"</span>);</span><br><span class="line">         FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"dest.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Buffer三种读写方式性能测试：<ul>
<li>直接使用 BufferedInputStream 和 BufferedOutputStream;</li>
<li>额外使用一个 8KB 缓冲，使用 BufferedInputStream 和 BufferedOutputStream;</li>
<li>直接使用 FileInputStream 和 FileOutputStream，再使用一个 8KB 的缓冲。</li>
</ul>
</li>
<li>第一种（bufferedStreamByteOperation）方式虽然使用了缓冲流，但逐字节的操作因为方法调用次数实在太多还是 慢，耗时 1.4 秒。后面两种方式的性能差不多，耗时 110 毫秒左右。虽然第三种方式没有 使用缓冲流，但使用了 8KB 大小的缓冲区，和缓冲流默认的缓冲区大小相同。</li>
<li>看到这里，你可能会疑惑了，既然这样使用 BufferedInputStream 和 BufferedOutputStream 有什么意义呢?<ul>
<li>其实，这里我是为了演示所以示例三使用了固定大小的缓冲区，但在实际代码中每次需要读 取的字节数很可能不是固定的，有的时候读取几个字节，有的时候读取几百字节，这个时候 有一个固定大小较大的缓冲，也就是使用 BufferedInputStream 和 BufferedOutputStream 做为后备的稳定的二次缓冲，就非常有意义了。</li>
</ul>
</li>
</ul>
</li>
<li><p>最后我要补充说明的是，对于类似的文件复制操作，如果希望有更高性能，可以使用 FileChannel 的 transfreTo 方法进行流的复制。在一些操作系统(比如高版本的 Linux 和 UNIX)上可以实现 DMA(直接内存访问)，也就是数据从磁盘经过总线直接发送到目标 文件，无需经过内存和 CPU 进行数据中转。</p>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最高效的文件复制：走总线发送给目标，不走内存和cpu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileChannelOperation</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.deleteIfExists(Paths.get(<span class="string">"dest.txt"</span>));</span><br><span class="line">  </span><br><span class="line">    FileChannel in = FileChannel.open(Paths.get(<span class="string">"src.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel out = FileChannel.open(Paths.get(<span class="string">"dest.txt"</span>), CREATE, WRITE);</span><br><span class="line">    in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一，如果需要读写字符流，那么需要确保文件中字符的字符集和字符流的字符集是一致 的，否则可能产生乱码。</li>
<li>第二，使用 Files 类的一些流式处理操作，注意使用 try-with-resources 包装 Stream，确 保底层文件资源可以释放，避免产生 too many open files 的问题。</li>
<li>第三，进行文件字节流操作的时候，一般情况下不考虑进行逐字节操作，使用缓冲区进行批 量读写减少 IO 次数，性能会好很多。一般可以考虑直接使用缓冲输入输出流 BufferedXXXStream，追求极限性能的话可以考虑使用 FileChannel 进行流转发。</li>
<li>最后我要强调的是，文件操作因为涉及操作系统和文件系统的实现，JDK 并不能确保所有 IO API 在所有平台的逻辑一致性，代码迁移到新的操作系统或文件系统时，要重新进行功 能测试和性能测试。</li>
</ol>
<h1 id="Java8科普篇一"><a href="#Java8科普篇一" class="headerlink" title="Java8科普篇一"></a>Java8科普篇一</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a><strong>Lambda</strong> <strong>表达式</strong></h2><ul>
<li><p>Lambda 表达式的初衷是，进一步简化匿名类的语法(不过实现上，Lambda 表达式并不 是匿名类的语法糖)，使 Java 走向函数式编程。对于匿名类，虽然没有类名，但还是要给出方法定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambdavsanonymousclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//匿名类</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"hello2"</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么，Lambda 表达式如何匹配 Java 的类型系统呢? 答案=函数式接口（java.util.function 包中定义了各种函数式接口）。</p>
</li>
<li><p><strong>函数式接口是一种只有单一抽象方法的接口</strong>，使用 @FunctionalInterface 来描述，可以隐 式地转换成 Lambda 表达式。使用 Lambda 表达式来实现函数式接口，不需要提供类名和 方法定义，通过一行代码提供函数式接口的实例，就可以让函数成为程序中的头等公民，可 以像普通数据一样作为参数传递，而不是作为一个固定的类中的固定方法。</p>
</li>
<li><p>常见的函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">functionalInterfaces</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以看一下java.util.function包</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用于提供数据的 Supplier 接口，就只有一个 get 抽象方法，没有任何入参、有一个返回值</span></span><br><span class="line">    Supplier&lt;String&gt; supplier = String::<span class="keyword">new</span>;</span><br><span class="line">    Supplier&lt;String&gt; stringSupplier = () -&gt; <span class="string">"OK"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Predicate的例子：Predicate接口是输入一个参数，返回布尔值</span></span><br><span class="line">    Predicate&lt;Integer&gt; positiveNumber = i -&gt; i &gt; <span class="number">0</span>;</span><br><span class="line">    Predicate&lt;Integer&gt; evenNumber = i -&gt; i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    assertTrue(positiveNumber.and(evenNumber).test(<span class="number">2</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Consumer的例子，输出两行abcdefg。Consumer接口是消费一个数据</span></span><br><span class="line">    Consumer&lt;String&gt; println = System.out::println;</span><br><span class="line">    println.andThen(println).accept(<span class="string">"abcdefg"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Function的例子，Function接口是输入一个数据，计算后输出一个数据。</span></span><br><span class="line">    Function&lt;String, String&gt; upperCase = String::toUpperCase;</span><br><span class="line">    Function&lt;String, String&gt; duplicate = s -&gt; s.concat(s);</span><br><span class="line">    assertThat(upperCase.andThen(duplicate).apply(<span class="string">"test"</span>), is(<span class="string">"TESTTEST"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Supplier的例子，Supplier是提供一个数据的接口</span></span><br><span class="line">    Supplier&lt;Integer&gt; random = () -&gt; ThreadLocalRandom.current().nextInt();</span><br><span class="line">    System.out.println(random.get());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//BinaryOperator，BinaryOperator是输入两个同类型参数，输出一个同类型参数的接口</span></span><br><span class="line">    BinaryOperator&lt;Integer&gt; add = Integer::sum;</span><br><span class="line">    BinaryOperator&lt;Integer&gt; subtraction = (a, b) -&gt; a - b;</span><br><span class="line">    assertThat(subtraction.apply(add.apply(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), is(<span class="number">0</span>));</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>java.util.function 包中定义了各种函数式接口</li>
<li>Predicate接口是输入一个参数，返回布尔值</li>
<li>Consumer接口是消费一个数据</li>
<li>Function接口是输入一个数据，计算后输出一个数据。</li>
<li>Supplier是提供一个数据的接口</li>
<li>BinaryOperator是输入两个同类型参数，输出一个同类型参数的接口</li>
</ol>
</li>
<li><p>Predicate、Function 等函数式接口，还使用 default 关键字实现了几个默认方法。<strong>这样一 来，它们既可以满足函数式接口只有一个抽象方法，又能为接口提供额外的功能。</strong></p>
</li>
<li><p>很明显，Lambda 表达式给了我们复用代码的更多可能性:我们可以把一大段逻辑中变化 的部分抽象出函数式接口，由外部方法提供函数实现，重用方法内的整体逻辑处理</p>
</li>
</ul>
<h2 id="使用Java8简化代码"><a href="#使用Java8简化代码" class="headerlink" title="使用Java8简化代码"></a>使用Java8简化代码</h2><p>这一部分，我会通过几个具体的例子，带你感受一下使用 Java 8 简化代码的三个重要方面:</p>
<ol>
<li>使用 Stream 简化集合操作;</li>
<li>使用 Optional 简化判空逻辑;</li>
<li>JDK8 结合 Lambda 和 Stream 对各种类的增强。</li>
</ol>
<ul>
<li><p>计算x-y坐标的平均距离，栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 业务功能：普通实现</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 把整数列表转换为 Point2D 列表;</span></span><br><span class="line"><span class="comment">    * 遍历 Point2D 列表过滤出 Y 轴 &gt;1 的对象;</span></span><br><span class="line"><span class="comment">    * 计算 Point2D 点到原点的距离;</span></span><br><span class="line"><span class="comment">    * 累加所有计算出的距离，并计算距离的平均值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ints</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(List&lt;Integer&gt; ints)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//临时中间集合</span></span><br><span class="line">       List&lt;Point2D&gt; point2DList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Integer i : ints) &#123;</span><br><span class="line">           point2DList.add(<span class="keyword">new</span> Point2D.Double((<span class="keyword">double</span>) i % <span class="number">3</span>, (<span class="keyword">double</span>) i / <span class="number">3</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//临时变量,纯粹是为了获得最后结果需要的中间变量</span></span><br><span class="line">       <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">for</span> (Point2D point2D : point2DList) &#123;</span><br><span class="line">           <span class="comment">//过滤</span></span><br><span class="line">           <span class="keyword">if</span> (point2D.getY() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//算距离</span></span><br><span class="line">               <span class="keyword">double</span> distance = point2D.distance(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">               total += distance;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count &gt; <span class="number">0</span> ? total / count : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用Java8 stream遍历集合</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * map 方法传入的是一个 Function，可以实现对象转换;</span></span><br><span class="line"><span class="comment">    * filter 方法传入一个 Predicate，实现对象的布尔判断，只保留返回 true 的数据;</span></span><br><span class="line"><span class="comment">    * mapToDouble 用于把对象转换为 double;</span></span><br><span class="line"><span class="comment">    * 通过 average 方法返回一个 OptionalDouble，代表可能包含值也可能不包含值的可空 double。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; ints = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">       <span class="keyword">double</span> average = calc(ints);</span><br><span class="line">       <span class="keyword">double</span> streamResult = ints.stream()</span><br><span class="line">               .map(i -&gt; <span class="keyword">new</span> Point2D.Double((<span class="keyword">double</span>) i % <span class="number">3</span>, (<span class="keyword">double</span>) i / <span class="number">3</span>))</span><br><span class="line">               .filter(point -&gt; point.getY() &gt; <span class="number">1</span>)</span><br><span class="line">               .mapToDouble(point -&gt; point.distance(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">               .average()</span><br><span class="line">               .orElse(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//如何用一行代码来实现,比较一下可读性</span></span><br><span class="line">       assertThat(average, is(streamResult));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional使用栗子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = IllegalArgumentException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">optional</span>() </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通过get方法获取Optional中的实际值</span></span><br><span class="line">    assertThat(Optional.of(<span class="number">1</span>).get(), is(<span class="number">1</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通过ofNullable来初始化一个null，通过orElse方法实现Optional中无数据的时候返回一个默认值A</span></span><br><span class="line">    assertThat(Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">"A"</span>), is(<span class="string">"A"</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//OptionalDouble是基本类型double的Optional对象，isPresent判断有无数据</span></span><br><span class="line">    assertFalse(OptionalDouble.empty().isPresent());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通过map方法可以对Optional对象进行级联转换，不会出现空指针，转换后还是一个Optional</span></span><br><span class="line">    assertThat(Optional.of(<span class="number">1</span>).map(Math::incrementExact).get(), is(<span class="number">2</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通过filter实现Optional中数据的过滤，得到一个Optional，然后级联使用orElse提供默认值</span></span><br><span class="line">    assertThat(Optional.of(<span class="number">1</span>).filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>).orElse(<span class="keyword">null</span>), is(nullValue()));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//通过orElseThrow实现无数据时抛出异常</span></span><br><span class="line">    Optional.empty().orElseThrow(IllegalArgumentException::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Optional方法图解"><a href="#Optional方法图解" class="headerlink" title="Optional方法图解"></a>Optional方法图解</h2><p>源码位置<code>java.util.Optional</code><img alt="image-20200506065409101" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geicmhplfbj31170u07wh.jpg" class="lazyload"></p>
<h2 id="Java-8-类对于函数式-API-增强"><a href="#Java-8-类对于函数式-API-增强" class="headerlink" title="Java 8 类对于函数式 API 增强"></a><strong>Java 8</strong> <strong>类对于函数式</strong> <strong>API</strong> 增强</h2><ul>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> Product <span class="title">getProductAndCacheCool</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//todo:实现value=null，也保存进去，缓存穿透，要看Map的具体实现，当前是ConrecntHashMap，看下HashMap</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> cache.computeIfAbsent(id, i -&gt; <span class="comment">//当Key不存在的时候提供一个Function来代表根据Key获取Value的过程</span></span><br><span class="line">              Product.getData().stream()</span><br><span class="line">                      .filter(p -&gt; p.getId().equals(i)) <span class="comment">//过滤</span></span><br><span class="line">                      .findFirst() <span class="comment">//找第一个，得到Optional&lt;Product&gt;</span></span><br><span class="line">                      .orElse(<span class="keyword">null</span>)); <span class="comment">//如果找不Product到则使用null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//java.util.Map#computeIfAbsent，源码分析</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">          Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(mappingFunction);</span><br><span class="line">      V v;</span><br><span class="line">      <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          V newValue;</span><br><span class="line">          <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              put(key, newValue);</span><br><span class="line">              <span class="keyword">return</span> newValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filesExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//无限深度，递归遍历文件夹</span></span><br><span class="line">      <span class="keyword">try</span> (Stream&lt;Path&gt; pathStream = Files.walk(Paths.get(<span class="string">"."</span>))) &#123;</span><br><span class="line">          pathStream.filter(Files::isRegularFile) <span class="comment">//只查普通文件</span></span><br><span class="line">                  .filter(FileSystems.getDefault().getPathMatcher(<span class="string">"glob:**/*.java"</span>)::matches) <span class="comment">//搜索java源码文件</span></span><br><span class="line">                  .flatMap(ThrowingFunction.unchecked(path -&gt;</span><br><span class="line">                          Files.readAllLines(path).stream() <span class="comment">//读取文件内容，转换为Stream&lt;List&gt;</span></span><br><span class="line">                                  .filter(line -&gt; Pattern.compile(<span class="string">"public class"</span>).matcher(line).find()) <span class="comment">//使用正则过滤带有public class的行</span></span><br><span class="line">                                  .map(line -&gt; path.getFileName() + <span class="string">" &gt;&gt; "</span> + line))) <span class="comment">//把这行文件内容转换为文件名+行</span></span><br><span class="line">                  .forEach(System.out::println); <span class="comment">//打印所有的行</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义捕获受检异常转换为运行时异常的函数式接口</span></span><br><span class="line">  <span class="meta">@FunctionalInterface</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThrowingFunction</span>&lt;<span class="title">T</span>, <span class="title">R</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Throwable</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> &lt;T, R, E extends Throwable&gt; <span class="function">Function&lt;T, R&gt; <span class="title">unchecked</span><span class="params">(ThrowingFunction&lt;T, R, E&gt; f)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> t -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> f.apply(t);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function">R <span class="title">apply</span><span class="params">(T t)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="并行流和Java多线程实现"><a href="#并行流和Java多线程实现" class="headerlink" title="并行流和Java多线程实现"></a>并行流和Java多线程实现</h2><p>前面我们看到的 Stream 操作都是串行 Stream，操作只是在一个线程中执行，此外 Java 8 还提供了并行流的功能:通过 parallel 方法，一键把 Stream 转换为并行操作提交到线程 池处理。</p>
<ul>
<li><p>栗子场景：为了实现多线程这五种实现方式，我们设计一个场景:使用 20 个线程(threadCount)以并行方 式总计执行 10000 次(taskCount)操作。因为单个任务单线程执行需要 10 毫秒(任务 代码如下)，也就是每秒吞吐量是 100 个操作，那 20 个线程 QPS 是 2000，执行完 10000 次操作最少耗时 5 秒。（todo：谈谈你对QPS的理解，那线程越多，QPS越高？）</p>
<ul>
<li><p>QPS理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//线程数为20的时候的qps</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line">5683286850  019%  thread</span><br><span class="line">5608652892  019%  threadpool</span><br><span class="line">6119871101  021%  stream</span><br><span class="line">6088013378  021%  forkjoin</span><br><span class="line">6130607306  021%  completableFuture</span><br><span class="line"></span><br><span class="line">//线程数为40的时候的qps</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line">2972616257  019%  thread</span><br><span class="line">2884939811  019%  threadpool</span><br><span class="line">3111060456  020%  stream</span><br><span class="line">3184826327  021%  forkjoin</span><br><span class="line">3137196085  021%  completableFuture</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(AtomicInteger atomicInteger)</span> </span>&#123;</span><br><span class="line">       atomicInteger.incrementAndGet();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第一种方式是使用线程。直接把任务按照线程数均匀分割，分配到不同的线程执行，使用 CountDownLatch 来阻塞主线程，直到所有线程都完成操作。</span></span><br><span class="line"><span class="comment">    * 这种方式，需要我们自己分 割任务</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">thread</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">       AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//size的大小是线程数的大小，而不是任务数的大小</span></span><br><span class="line">       CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">  </span><br><span class="line">       IntStream.rangeClosed(<span class="number">1</span>, threadCount).mapToObj(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           IntStream.rangeClosed(<span class="number">1</span>, taskCount / threadCount).forEach(j -&gt; increment(atomicInteger));</span><br><span class="line">           countDownLatch.countDown();</span><br><span class="line">       &#125;)).forEach(Thread::start);</span><br><span class="line">  </span><br><span class="line">       countDownLatch.await();</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第二种方式是，使用 Executors.newFixedThreadPool 来获得固定线程数的线程池，使用 execute 提交所有任务到线程池执行，最后关闭线程池等待所有任务执行完成:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">threadpool</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">       AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">  </span><br><span class="line">       IntStream.rangeClosed(<span class="number">1</span>, taskCount).forEach(i -&gt; executorService.execute(() -&gt; increment(atomicInteger)));</span><br><span class="line">  </span><br><span class="line">       executorService.shutdown();</span><br><span class="line">       executorService.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第三种方式是，使用 ForkJoinPool 而不是普通线程池执行任务。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * ForkJoinPool 和传统的 ThreadPoolExecutor 区别在于，前者对于 n 并行度有 n 个独立 队列，后者是共享队列。</span></span><br><span class="line"><span class="comment">    * 如果有大量执行耗时比较短的任务，ThreadPoolExecutor 的单队 列就可能会成为瓶颈。</span></span><br><span class="line"><span class="comment">    * 这时，使用 ForkJoinPool 性能会更好。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">forkjoin</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">       AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//定义并行度</span></span><br><span class="line">       ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(threadCount);</span><br><span class="line">       forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)));</span><br><span class="line">  </span><br><span class="line">       forkJoinPool.shutdown();</span><br><span class="line">       forkJoinPool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第四种方式是，直接使用并行流，并行流使用公共的 ForkJoinPool，也就是 ForkJoinPool.commonPool()。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">stream</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//设置公共ForkJoinPool的并行度</span></span><br><span class="line">       System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, String.valueOf(threadCount));</span><br><span class="line">  </span><br><span class="line">       AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger));</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第五种方式是，使用 CompletableFuture 来实现</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadCount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">completableFuture</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">  </span><br><span class="line">       AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(threadCount);</span><br><span class="line">  </span><br><span class="line">       CompletableFuture.runAsync(() -&gt; IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)), forkJoinPool).get();</span><br><span class="line">       <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>理论科普</p>
<ol>
<li>第一种方式是使用线程。直接把任务按照线程数均匀分割，分配到不同的线程执行，使用 CountDownLatch 来阻塞主线程，直到所有线程都完成操作</li>
<li>第二种方式是，使用 Executors.newFixedThreadPool 来获得固定线程数的线程池，使用 execute 提交所有任务到线程池执行，最后关闭线程池等待所有任务执行完成</li>
<li>第三种方式是，使用 ForkJoinPool 而不是普通线程池执行任务。<ul>
<li>ForkJoinPool 和传统的 ThreadPoolExecutor 区别在于，前者对于 n 并行度有 n 个独立 队列，后者是共享队列。如果有大量执行耗时比较短的任务，ThreadPoolExecutor 的单队 列就可能会成为瓶颈。这时，使用 ForkJoinPool 性能会更好</li>
</ul>
</li>
<li>第四种方式是，直接使用并行流，并行流使用公共的 ForkJoinPool，也就是 ForkJoinPool.commonPool()。<ul>
<li>公共的 ForkJoinPool 默认的并行度是 CPU 核心数 -1，原因是对于 CPU 绑定的任务分配 超过 CPU 个数的线程没有意义。由于并行流还会使用主线程执行任务，也会占用一个 CPU 核心，所以公共 ForkJoinPool 的并行度即使 -1 也能用满所有 CPU 核心</li>
<li><code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, String.valueOf(threadCount));</code></li>
</ul>
</li>
<li>第五种方式是，使用 CompletableFuture 来实现。</li>
</ol>
</li>
<li><p>一般而 言，使用线程池(第二种)和直接使用并行流(第四种)的方式在业务代码中比较常用。<strong>另外需要注意的是，在上面的例子中我们一定是先运行 stream 方法再运行 forkjoin 方 法，对公共 ForkJoinPool 默认并行度的修改才能生效。</strong>因此我的建议是，设置 ForkJoinPool 公共线程池默认并行度的操作，应该放在应用 启动时设置。</p>
</li>
</ul>
<h1 id="Java8科普篇二"><a href="#Java8科普篇二" class="headerlink" title="Java8科普篇二"></a>Java8科普篇二</h1><h2 id="Stream操作详解"><a href="#Stream操作详解" class="headerlink" title="Stream操作详解"></a>Stream操作详解</h2><p><img alt="image-20200507070630780" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejilmihmcj31160r61d2.jpg" class="lazyload"></p>
<h2 id="场景栗子"><a href="#场景栗子" class="headerlink" title="场景栗子"></a>场景栗子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long customerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单商品明细</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; orderItemList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double totalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime placedAt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单商品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double productPrice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer productQuantity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顾客类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Stream.of 方法直接传入多个元素构成一个流;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        Stream.of(arr).forEach(System.out::println);</span><br><span class="line">        Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).forEach(System.out::println);</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"a"</span>).map(item -&gt; item.getClass().getName()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Stream.iterate 方法使用迭代的方式构造一个无限流，然后使用 limit 限制流元素 个数;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream.iterate(<span class="number">2</span>, item -&gt; item * <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">        Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Stream.generate 方法从外部传入一个提供元素的 Supplier 来构造无限流，然后 使用 limit 限制流元素个数;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream.generate(() -&gt; <span class="string">"test"</span>).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 stream 方法把 List 或数组转换为流;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>).stream().forEach(System.out::println);</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 IntStream 或 DoubleStream 构造基本类型的流。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">primitive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演示IntStream和DoubleStream</span></span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">3</span>).mapToObj(i -&gt; <span class="string">"x"</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        DoubleStream.of(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//各种转换</span></span><br><span class="line">        System.out.println(IntStream.of(<span class="number">1</span>, <span class="number">2</span>).toArray().getClass()); <span class="comment">//class [I</span></span><br><span class="line">        System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>).mapToInt(Integer::intValue).toArray().getClass()); <span class="comment">//class [I</span></span><br><span class="line">        System.out.println(IntStream.of(<span class="number">1</span>, <span class="number">2</span>).boxed().toArray().getClass()); <span class="comment">//class [Ljava.lang.Object;</span></span><br><span class="line">        System.out.println(IntStream.of(<span class="number">1</span>, <span class="number">2</span>).asDoubleStream().toArray().getClass()); <span class="comment">//class [D</span></span><br><span class="line">        System.out.println(IntStream.of(<span class="number">1</span>, <span class="number">2</span>).asLongStream().toArray().getClass()); <span class="comment">//class [J</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).stream()   <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">                .mapToInt(String::length)       <span class="comment">// IntStream</span></span><br><span class="line">                .asLongStream()                 <span class="comment">// LongStream</span></span><br><span class="line">                .mapToDouble(x -&gt; x / <span class="number">10.0</span>)     <span class="comment">// DoubleStream</span></span><br><span class="line">                .boxed()                        <span class="comment">// Stream&lt;Double&gt;</span></span><br><span class="line">                .mapToLong(x -&gt; <span class="number">1L</span>)             <span class="comment">// LongStream</span></span><br><span class="line">                .mapToObj(x -&gt; <span class="string">""</span>)              <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 stream 方法把 List 或数组转换为流;</li>
<li>通过 Stream.of 方法直接传入多个元素构成一个流;</li>
<li>通过 Stream.iterate 方法使用迭代的方式构造一个无限流，然后使用 limit 限制流元素个数</li>
<li>通过 Stream.generate 方法从外部传入一个提供元素的 Supplier 来构造无限流，然后 使用 limit 限制流元素个数;</li>
<li>通过 IntStream 或 DoubleStream 构造基本类型的流。</li>
</ol>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"//最近半年的金额大于40的订单"</span>);</span><br><span class="line">    orders.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(order -&gt; order.getPlacedAt().isAfter(LocalDateTime.now().minusMonths(<span class="number">6</span>)))</span><br><span class="line">            .filter(order -&gt; order.getTotalPrice() &gt; <span class="number">40</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算所有订单商品数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过两次遍历实现</span></span><br><span class="line">        LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        orders.stream().forEach(order -&gt;</span><br><span class="line">                order.getOrderItemList().forEach(orderItem -&gt; longAdder.add(orderItem.getProductQuantity())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用两次mapToLong+sum方法实现</span></span><br><span class="line">        assertThat(longAdder.longValue(), is(orders.stream().mapToLong(order -&gt;</span><br><span class="line">                order.getOrderItemList().stream()</span><br><span class="line">                        .mapToLong(OrderItem::getProductQuantity).sum()).sum()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把IntStream通过转换Stream&lt;Project&gt;</span></span><br><span class="line">        System.out.println(IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> Product((<span class="keyword">long</span>) i, <span class="string">"product"</span> + i, i * <span class="number">100.0</span>))</span><br><span class="line">                .collect(toList()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们看看 flatMap 展开或者叫扁平化操作，相当于 map+flat，通过 map 把每一 个元素替换为一个流，然后展开这个流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计所有订单的总价格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖订单上的总价格字段</span></span><br><span class="line">    System.out.println(orders.stream().mapToDouble(order -&gt; order.getTotalPrice()).sum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不依赖订单上的总价格,可以直接展开订单商品进行价格统计</span></span><br><span class="line">    System.out.println(orders.stream()</span><br><span class="line">            .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class="line">            .mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()).sum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种方式flatMap+mapToDouble=flatMapToDouble</span></span><br><span class="line">    System.out.println(orders.stream()</span><br><span class="line">            .flatMapToDouble(order -&gt;</span><br><span class="line">                    order.getOrderItemList()</span><br><span class="line">                            .stream().mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()))</span><br><span class="line">            .sum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"//大于50的订单,按照订单价格倒序前5"</span>);</span><br><span class="line">        orders.stream().filter(order -&gt; order.getTotalPrice() &gt; <span class="number">50</span>)</span><br><span class="line">                .sorted(comparing(Order::getTotalPrice).reversed())</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"//不去重的下单用户"</span>);</span><br><span class="line">        System.out.println(orders.stream().map(order -&gt; order.getCustomerName()).collect(joining(<span class="string">","</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"//去重的下单用户"</span>);</span><br><span class="line">        System.out.println(orders.stream().map(order -&gt; order.getCustomerName()).distinct().collect(joining(<span class="string">","</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"//所有购买过的商品"</span>);</span><br><span class="line">        System.out.println(orders.stream()</span><br><span class="line">                .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class="line">                .map(OrderItem::getProductName)</span><br><span class="line">                .distinct().collect(joining(<span class="string">","</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="skip-amp-limit"><a href="#skip-amp-limit" class="headerlink" title="skip &amp; limit"></a><strong>skip &amp; limit</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照下单时间排序，查询前2个订单的顾客姓名和下单时间</span></span><br><span class="line">    orders.stream()</span><br><span class="line">            .sorted(comparing(Order::getPlacedAt))</span><br><span class="line">            .map(order -&gt; order.getCustomerName() + <span class="string">"@"</span> + order.getPlacedAt())</span><br><span class="line">            .limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照下单时间排序，查询第3和第4个订单的顾客姓名和下单时间</span></span><br><span class="line">    orders.stream()</span><br><span class="line">            .sorted(comparing(Order::getPlacedAt))</span><br><span class="line">            .map(order -&gt; order.getCustomerName() + <span class="string">"@"</span> + order.getPlacedAt())</span><br><span class="line">            .skip(<span class="number">2</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>collect 是收集操作，对流进行终结(终止)操作，把流导出为我们需要的数据结构。“终 结”是指，导出后，无法再串联使用其他中间操作，比如 filter、map、flatmap、 sorted、distinct、limit、skip。在 Stream 操作中，collect 是最复杂的终结操作，比较简单的终结操作还有 forEach、 toArray、min、max、count、anyMatch 等，我就不再展开了，你可以查询JDK 文 档，搜索 terminal operation 或 intermediate operation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"//生成一定位数的随机字符串"</span>);</span><br><span class="line">    System.out.println(random.ints(<span class="number">48</span>, <span class="number">122</span>)</span><br><span class="line">            .filter(i -&gt; (i &lt; <span class="number">57</span> || i &gt; <span class="number">65</span>) &amp;&amp; (i &lt; <span class="number">90</span> || i &gt; <span class="number">97</span>))</span><br><span class="line">            .mapToObj(i -&gt; (<span class="keyword">char</span>) i)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append, StringBuilder::append)</span><br><span class="line">            .toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//所有下单的用户,使用toSet去重了"</span>);</span><br><span class="line">    System.out.println(orders.stream()</span><br><span class="line">            .map(order -&gt; order.getCustomerName()).collect(toSet())</span><br><span class="line">            .stream().collect(joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//用toCollection收集器指定集合类型"</span>);</span><br><span class="line">    System.out.println(orders.stream().limit(<span class="number">2</span>).collect(toCollection(LinkedList::<span class="keyword">new</span>)).getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//使用toMap获取订单ID+下单用户名的Map"</span>);</span><br><span class="line">    orders.stream()</span><br><span class="line">            .collect(toMap(Order::getId, Order::getCustomerName))</span><br><span class="line">            .entrySet().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//使用toMap获取下单用户名+最近一次下单时间的Map"</span>);</span><br><span class="line">    orders.stream()</span><br><span class="line">            .collect(toMap(Order::getCustomerName, Order::getPlacedAt, (x, y) -&gt; x.isAfter(y) ? x : y))</span><br><span class="line">            .entrySet().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//订单平均购买的商品数量"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect(averagingInt(order -&gt;</span><br><span class="line">            order.getOrderItemList().stream()</span><br><span class="line">                    .collect(summingInt(OrderItem::getProductQuantity)))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20200508071631447" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekoibz798j30t30pm7bb.jpg" class="lazyload"></p>
<h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>nb强大的groupBy操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">groupBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"//按照用户名分组，统计下单数量"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, counting()))</span><br><span class="line">            .entrySet().stream().sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//按照用户名分组,统计订单总金额"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, summingDouble(Order::getTotalPrice)))</span><br><span class="line">            .entrySet().stream().sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//按照用户名分组,统计商品采购数量"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName,</span><br><span class="line">            summingInt(order -&gt; order.getOrderItemList().stream()</span><br><span class="line">                    .collect(summingInt(OrderItem::getProductQuantity)))))</span><br><span class="line">            .entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).collect(toList()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//统计最受欢迎的商品，倒序后取第一个"</span>);</span><br><span class="line">    orders.stream()</span><br><span class="line">            .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class="line">            .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))</span><br><span class="line">            .entrySet().stream()</span><br><span class="line">            .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed())</span><br><span class="line">            .map(Map.Entry::getKey)</span><br><span class="line">            .findFirst()</span><br><span class="line">            .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//统计最受欢迎的商品的另一种方式,直接利用maxBy"</span>);</span><br><span class="line">    orders.stream()</span><br><span class="line">            .flatMap(order -&gt; order.getOrderItemList().stream())</span><br><span class="line">            .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))</span><br><span class="line">            .entrySet().stream()</span><br><span class="line">            .collect(maxBy(Map.Entry.comparingByValue()))</span><br><span class="line">            .map(Map.Entry::getKey)</span><br><span class="line">            .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//按照用户名分组，选用户下的总金额最大的订单"</span>);</span><br><span class="line">    orders.stream().collect(groupingBy(Order::getCustomerName, collectingAndThen(maxBy(comparingDouble(Order::getTotalPrice)), Optional::get)))</span><br><span class="line">            .forEach((k, v) -&gt; System.out.println(k + <span class="string">"#"</span> + v.getTotalPrice() + <span class="string">"@"</span> + v.getPlacedAt()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//根据下单年月分组统计订单ID列表"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect</span><br><span class="line">            (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(<span class="string">"yyyyMM"</span>)),</span><br><span class="line">                    mapping(order -&gt; order.getId(), toList()))));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//根据下单年月+用户名两次分组，统计订单ID列表"</span>);</span><br><span class="line">    System.out.println(orders.stream().collect</span><br><span class="line">            (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(<span class="string">"yyyyMM"</span>)),</span><br><span class="line">                    groupingBy(order -&gt; order.getCustomerName(),</span><br><span class="line">                            mapping(order -&gt; order.getId(), toList())))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy"></a>partitioningBy</h3><p>partitioningBy 用于分区，分区是特殊的分组，只有 true 和 false 两组。比如，我们把用 户按照是否下单进行分区，给 partitioningBy 方法传入一个 Predicate 作为数据分区的区 分，输出是 Map&lt;Boolean, List&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先来看一下所有下单的用户</span></span><br><span class="line">    orders.stream().map(order -&gt; order.getCustomerName()).collect(toSet()).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//根据是否有下单记录进行分区</span></span><br><span class="line">    System.out.println(Customer.getData().stream().collect(</span><br><span class="line">            partitioningBy(customer -&gt; orders.stream().mapToLong(Order::getCustomerId)</span><br><span class="line">                    .anyMatch(id -&gt; id == customer.getId()))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="连接池-别让连接池帮了倒忙"><a href="#连接池-别让连接池帮了倒忙" class="headerlink" title="连接池:别让连接池帮了倒忙"></a><strong>连接池:别让连接池帮了倒忙</strong></h1><p>连接池的结构。连接池一般对外提供获得连接、归还连接的接口给客户端使 用，并暴露最小空闲连接数、最大连接数等可配置参数，在内部则实现连接建立、连接心跳保持、连接管理、空闲连接回收、连接可用性检测等功能。<img alt="image-20200511064746979" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo4jcyi0zj310f0ly40q.jpg" class="lazyload"></p>
<h2 id="注意鉴别客户端-SDK-是否基于连接池"><a href="#注意鉴别客户端-SDK-是否基于连接池" class="headerlink" title="注意鉴别客户端 SDK 是否基于连接池"></a><strong>注意鉴别客户端</strong> <strong>SDK</strong> <strong>是否基于连接池</strong></h2><p>在使用三方客户端进行网络通信时，我们首先要确定客户端 SDK 是否是基于连接池技术实现的。我们知道，TCP 是面向连接的基于字节流的协议：</p>
<ul>
<li>面向连接，意味着连接需要先创建再使用，创建连接的三次握手有一定开销;</li>
<li>基于字节流，意味着字节是发送数据的最小单元，TCP 协议本身无法区分哪几个字节是 完整的消息体，也无法感知是否有多个客户端在使用同一个 TCP 连接，TCP 只是一个读 写数据的管道。</li>
</ul>
<p>如果客户端 SDK 没有使用连接池，而直接是 TCP 连接，那么就需要考虑每次建立 TCP 连 接的开销，<strong>并且因为 TCP 基于字节流，在多线程的情况下对同一连接进行复用，可能会产 生线程安全问题</strong>。</p>
<p>我们先看一下涉及 TCP 连接的客户端 SDK，对外提供 API 的三种方式。在面对各种三方客 户端的时候，只有先识别出其属于哪一种，才能理清楚使用方式。</p>
<ul>
<li>连接池和连接分离的 API:有一个 XXXPool 类负责连接池实现，先从其获得连接 XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通 常，XXXPool 是线程安全的，可以并发获取和归还连接，而 XXXConnection 是非线程 安全的。对应到连接池的结构示意图中，XXXPool 就是右边连接池那个框，左边的客户 端是我们自己的代码</li>
<li>内部带有连接池的 API:对外提供一个 XXXClient 类，通过这个类可以直接进行服务端 请求;这个类内部维护了连接池，SDK 使用者无需考虑连接的获取和归还问题。一般而 言，XXXClient 是线程安全的。对应到连接池的结构示意图中，整个 API 就是蓝色框包 裹的部分</li>
<li>非连接池的 API:一般命名为 XXXConnection，以区分其是基于连接池还是单连接的， 而不建议命名为 XXXClient 或直接是 XXX。直接连接方式的 API 基于单一连接，每次使 用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示 意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接</li>
</ul>
<p>连接池SDK的最佳实践：</p>
<ul>
<li>如果是分离方式，那么连接池本身一般是线程安全的，可以复用。每次使用需要从连接 池获取连接，使用后归还，归还的工作由使用者负责。</li>
<li>如果是内置连接池，SDK 会负责连接的获取和归还，使用的时候直接复用客户端。</li>
<li>如果 SDK 没有实现连接池(大多数中间件、数据库的客户端 SDK 都会支持连接池)， 那通常不是线程安全的，而且短连接的方式性能不会很高，使用的时候需要考虑是否自 己封装一个连接池。</li>
</ul>
<p>栗子源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>)) &#123;</span><br><span class="line">            Assert.isTrue(<span class="string">"OK"</span>.equals(jedis.set(<span class="string">"a"</span>, <span class="string">"1"</span>)), <span class="string">"set a = 1 return OK"</span>);</span><br><span class="line">            Assert.isTrue(<span class="string">"OK"</span>.equals(jedis.set(<span class="string">"b"</span>, <span class="string">"2"</span>)), <span class="string">"set b = 2 return OK"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//进程退出后清理连接池的工作</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            jedisPool.close();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/wrong"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                String result = jedis.get(<span class="string">"a"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"1"</span>.equals(result)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Expect a to be 1 but found &#123;&#125;"</span>, result);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                String result = jedis.get(<span class="string">"b"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"2"</span>.equals(result)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Expect b to be 2 but found &#123;&#125;"</span>, result);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三种报错</span></span><br><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: Failed connecting to host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span></span><br><span class="line">Caused by: java.net.SocketException: Socket is not connected</span><br><span class="line">Exception in thread <span class="string">"Thread-42"</span> redis.clients.jedis.exceptions.JedisConnectionException: Attempting to read from a broken connection</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[<span class="number">07</span>:<span class="number">13</span>:<span class="number">39.107</span>] [Thread-<span class="number">44</span>] [WARN ] [o.g.t.c.c.jedis.JedisMisreuseController:<span class="number">50</span>  ] - Expect b to be <span class="number">2</span> but found <span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">"Thread-43"</span> redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: Read timed out  </span><br><span class="line">  </span><br><span class="line">java.io.IOException: Socket Closed</span><br></pre></td></tr></table></figure>

<p>执行程序多次，可以看到日志中出现了各种奇怪的异常信息，有的是读取 Key 为 b 的 Value 读取到了 1，有的是流非正常结束，还有的是连接关闭异常。</p>
<p>Jedis源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jedis</span> <span class="keyword">extends</span> <span class="title">BinaryJedis</span> <span class="keyword">implements</span> <span class="title">JedisCommands</span>, <span class="title">MultiKeyCommands</span>,</span></span><br><span class="line"><span class="class">    <span class="title">AdvancedJedisCommands</span>, <span class="title">ScriptingCommands</span>, <span class="title">BasicCommands</span>, <span class="title">ClusterCommands</span>, <span class="title">SentinelCommands</span>, <span class="title">ModuleCommands</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryJedis</span> <span class="keyword">implements</span> <span class="title">BasicCommands</span>, <span class="title">BinaryJedisCommands</span>, <span class="title">MultiKeyBinaryCommands</span>,</span></span><br><span class="line"><span class="class">    <span class="title">AdvancedBinaryJedisCommands</span>, <span class="title">BinaryScriptingCommands</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Client client = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> Transaction transaction = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> Pipeline pipeline = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[][] dummyArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>][];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">BinaryClient</span> <span class="keyword">implements</span> <span class="title">Commands</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryClient</span> <span class="keyword">extends</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[][] EMPTY_ARGS = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>][];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String host = Protocol.DEFAULT_HOST;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port = Protocol.DEFAULT_PORT;</span><br><span class="line">  <span class="keyword">private</span> Socket socket;</span><br><span class="line">  <span class="keyword">private</span> RedisOutputStream outputStream;</span><br><span class="line">  <span class="keyword">private</span> RedisInputStream inputStream;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTimeout = Protocol.DEFAULT_TIMEOUT;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> soTimeout = Protocol.DEFAULT_TIMEOUT;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> ssl;</span><br><span class="line">  <span class="keyword">private</span> SSLSocketFactory sslSocketFactory;</span><br><span class="line">  <span class="keyword">private</span> SSLParameters sslParameters;</span><br><span class="line">  <span class="keyword">private</span> HostnameVerifier hostnameVerifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.clients.jedis.Protocol#sendCommand(redis.clients.jedis.util.RedisOutputStream, byte[], byte[]...)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendCommand</span><span class="params">(<span class="keyword">final</span> RedisOutputStream os, <span class="keyword">final</span> <span class="keyword">byte</span>[] command,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">byte</span>[]... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      os.write(ASTERISK_BYTE);</span><br><span class="line">      os.writeIntCrLf(args.length + <span class="number">1</span>);</span><br><span class="line">      os.write(DOLLAR_BYTE);</span><br><span class="line">      os.writeIntCrLf(command.length);</span><br><span class="line">      os.write(command);</span><br><span class="line">      os.writeCrLf();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">byte</span>[] arg : args) &#123;</span><br><span class="line">        os.write(DOLLAR_BYTE);</span><br><span class="line">        os.writeIntCrLf(arg.length);</span><br><span class="line">        os.write(arg);</span><br><span class="line">        os.writeCrLf();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JedisConnectionException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Jedis 继承了 BinaryJedis，BinaryJedis 中保存了单个 Client 的实例，Client 最终继承了 Connection，Connection 中保存了单个 Socket 的实例，和 Socket 对应的 两个读写流。因此，一个 Jedis 对应一个 Socket 连接<img alt="image-20200511072148547" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo5iq52p5j30in0gl3zc.jpg" class="lazyload"></p>
<p>BinaryClient 封装了各种 Redis 命令，其最终会调用基类 Connection 的方法，使用 Protocol 类发送命令。看一下 Protocol 类的 sendCommand 方法的源码，可以发现其发 送命令时是直接操作 RedisOutputStream 写入字节。</p>
<p>我们在多线程环境下复用 Jedis 对象，其实就是在复用 RedisOutputStream。<strong>如果多个线 程在执行操作，那么既无法确保整条命令以一个原子操作写入 Socket，也无法确保写入 后、读取前没有其他数据写到远端</strong>:</p>
<p>Jedis最佳实践&amp;解决问题:</p>
<ul>
<li><p>修复方式是，<strong>使用 Jedis 提供的另一个线程安全的类 JedisPool 来获得 Jedis 的实例</strong>。 </p>
</li>
<li><p>JedisPool 可以声明为 static 在多个线程之间共享，扮演连接池的角色。使用时，按需使用 <strong>try-with-resources 模式从 JedisPool 获得和归还</strong> Jedis 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                String result = jedis.get(<span class="string">"a"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"1"</span>.equals(result)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Expect a to be 1 but found &#123;&#125;"</span>, result);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                String result = jedis.get(<span class="string">"b"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"2"</span>.equals(result)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Expect b to be 2 but found &#123;&#125;"</span>, result);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>线程池归还连接&amp;非线程池关闭TCP连接，源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">redis.clients.jedis.Jedis#close</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      JedisPoolAbstract pool = <span class="keyword">this</span>.dataSource;</span><br><span class="line">      <span class="keyword">this</span>.dataSource = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (client.isBroken()) &#123;</span><br><span class="line">        pool.returnBrokenResource(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pool.returnResource(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis.clients.jedis.Connection#close</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    disconnect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isConnected()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        socket.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        broken = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JedisConnectionException(ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IOUtils.closeQuietly(socket);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>JedisPool源码分析：</p>
<p>Jedis 可以独立使用，也可以配合连接池使用，这个连接池就是 JedisPool。</p>
<p>JedisPool 的 getResource 方法在拿到 Jedis 对象后，将自己设置为了连接池。连接池 JedisPool，继承了 JedisPoolAbstract，而后者继承了抽象类 Pool，Pool 内部维护了 Apache Common 的通用池 GenericObjectPool。JedisPool 的连接池就是基于 GenericObjectPool 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPool</span> <span class="keyword">extends</span> <span class="title">JedisPoolAbstract</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Jedis <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">super</span>.getResource();</span><br><span class="line">    jedis.setDataSource(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> jedis;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResource</span><span class="params">(<span class="keyword">final</span> Jedis resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        resource.resetState();</span><br><span class="line">        returnResourceObject(resource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        returnBrokenResource(resource);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JedisException(<span class="string">"Resource is returned to the pool as broken"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我们了解了，Jedis 的 API 实现是我们说的三种类型中的第一种，也就是连接池和 连接分离的 API，JedisPool 是线程安全的连接池，Jedis 是非线程安全的单一连接。知道 了原理之后，我们再使用 Jedis 就胸有成竹了。</p>
<h2 id="使用连接池务必确保复用"><a href="#使用连接池务必确保复用" class="headerlink" title="使用连接池务必确保复用"></a><strong>使用连接池务必确保复用</strong></h2><p><strong>池一定是用来复用的，否则其使用代价会比每次创建 单一对象更大。对连接池来说更是如此，原因如下</strong></p>
<ul>
<li>创建连接池的时候很可能一次性创建了多个连接，大多数连接池考虑到性能，会在初始 化的时候维护一定数量的最小连接(毕竟初始化连接池的过程一般是一次性的)，可以 直接使用。如果每次使用连接池都按需创建连接池，那么很可能你只用到一个连接，但 是创建了 N 个连接。</li>
<li>连接池一般会有一些管理模块，也就是连接池的结构示意图中的绿色部分。举个例子， 大多数的连接池都有闲置超时的概念。连接池会检测连接的闲置时间，定期回收闲置的 连接，把活跃连接数降到最低(闲置)连接的配置值，减轻服务端的压力。一般情况 下，闲置连接由独立线程管理，启动了空闲检测的连接池相当于还会启动一个线程。此 外，有些连接池还需要独立线程负责连接保活等功能。因此，启动一个连接池相当于启 动了 N 个线程。</li>
</ul>
<p>栗子源码</p>
<p>创建一个 CloseableHttpClient，设置使用 PoolingHttpClientConnectionManager 连接池并启用空闲连接驱逐策略，最大空闲时间 为 60 秒，然后使用这个连接来请求一个会返回 OK 字符串的服务端接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误栗子：每次都创建一个线程池&amp;&amp;只用一个线程</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">wrong1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      CloseableHttpClient client = HttpClients.custom()</span><br><span class="line">              .setConnectionManager(<span class="keyword">new</span> PoolingHttpClientConnectionManager())</span><br><span class="line">              .evictIdleConnections(<span class="number">60</span>, TimeUnit.SECONDS).build();</span><br><span class="line">      <span class="keyword">try</span> (CloseableHttpResponse response = client.execute(<span class="keyword">new</span> HttpGet(<span class="string">"http://127.0.0.1:45678/httpclientnotreuse/test"</span>))) &#123;</span><br><span class="line">          <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//OutOfMemoryError: unable to create new native thread</span></span><br></pre></td></tr></table></figure>

<p>jstack、wrk、lsof使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看16255线程名包含evictor的线程</span></span><br><span class="line">jstack 16255 | grep evictor</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">压测：1并发1个连接,30s</span></span><br><span class="line">wrk -t1 -c1 -d30s --latency  "http://127.0.0.1:45678/httpclientnotreuse/wrong1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看多少个TCP连接到45678端口</span></span><br><span class="line">lsof -nP -i4TCP:45678 | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看连接TCP端口的状态</span></span><br><span class="line">lsof -nP -i4TCP:45678</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#观察到：1、jstack大量evictor线程，2、45678端口有3000多个TCP连接，4、60 秒之后连接处于 CLOSE_WAIT 状态</span></span></span><br><span class="line">java    16255 codingprh 2089u  IPv6 0xe71404714e636b75      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59918 (CLOSE_WAIT)</span><br><span class="line">java    16255 codingprh 2091u  IPv6 0xe71404714e633455      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59919 (CLOSE_WAIT)</span><br><span class="line">java    16255 codingprh 2093u  IPv6 0xe71404714e637dd5      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59920 (CLOSE_WAIT)</span><br><span class="line">java    16255 codingprh 2095u  IPv6 0xe71404714e673f35      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59921 (CLOSE_WAIT)</span><br><span class="line">java    16255 codingprh 2097u  IPv6 0xe71404714e674555      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59922 (CLOSE_WAIT)</span><br><span class="line">java    16255 codingprh 2099u  IPv6 0xe71404714e675195      0t0  TCP 127.0.0.1:45678-&gt;127.0.0.1:59923 (CLOSE_WAIT)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这 2 点证明，CloseableHttpClient 属于第二种模式，即内部带有连接池的 API，其背后是 连接池，最佳实践一定是复用。</span></span><br></pre></td></tr></table></figure>

<p>HttpClient最佳实践&amp;栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient httpClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      httpClient = HttpClients.custom().setMaxConnPerRoute(<span class="number">1</span>).setMaxConnTotal(<span class="number">1</span>).evictIdleConnections(<span class="number">60</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">      Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              httpClient.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只创建一个线程池，复用线程</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> (CloseableHttpResponse response = httpClient.execute(<span class="keyword">new</span> HttpGet(<span class="string">"http://127.0.0.1:45678/httpclientnotreuse/test"</span>))) &#123;</span><br><span class="line">          <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这 2 点证明，CloseableHttpClient 属于第二种模式，即内部带有连接池的 API，其背后是 连接池，最佳实践一定是复用。</p>
<p>复用方式很简单，你可以把 CloseableHttpClient 声明为 static，只创建一次，并且在 JVM 关闭之前通过 addShutdownHook 钩子关闭连接池，在使用的时候直接使用 CloseableHttpClient 即可，无需每次都创建。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压测：每次新建立连接池，请求完成后释放连接池</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wrk -t1 -c1 -d30s --latency  <span class="string">"http://127.0.0.1:45678/httpclientnotreuse/wrong2"</span></span></span><br><span class="line">Running 30s test @ http://127.0.0.1:45678/httpclientnotreuse/wrong2</span><br><span class="line">  1 threads and 1 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     5.30ms   19.20ms 309.58ms   97.72%</span><br><span class="line">    Req/Sec   350.31     84.87   440.00     83.45%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.53ms</span><br><span class="line">     75%    2.89ms</span><br><span class="line">     90%    3.95ms</span><br><span class="line">     99%   88.32ms</span><br><span class="line">  10360 requests in 30.03s, 1.14MB read</span><br><span class="line">Requests/sec:    344.94</span><br><span class="line">Transfer/sec:     38.80KB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复用线程池</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wrk -t1 -c1 -d30s --latency  <span class="string">"http://127.0.0.1:45678/httpclientnotreuse/right"</span></span></span><br><span class="line">Running 30s test @ http://127.0.0.1:45678/httpclientnotreuse/right</span><br><span class="line">  1 threads and 1 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.54ms    7.51ms 162.08ms   98.36%</span><br><span class="line">    Req/Sec     1.30k   357.81     1.96k    73.24%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  682.00us</span><br><span class="line">     75%  841.00us</span><br><span class="line">     90%    1.17ms</span><br><span class="line">     99%   22.27ms</span><br><span class="line">  38652 requests in 30.04s, 4.25MB read</span><br><span class="line">Requests/sec:   1286.57</span><br><span class="line">Transfer/sec:    144.73KB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不走连接池直接访问地址的qps</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wrk -t1 -c1 -d30s --latency  <span class="string">"http://127.0.0.1:45678/httpclientnotreuse/test"</span></span></span><br><span class="line">Running 30s test @ http://127.0.0.1:45678/httpclientnotreuse/test</span><br><span class="line">  1 threads and 1 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   819.33us    6.43ms 154.12ms   98.78%</span><br><span class="line">    Req/Sec     3.74k     1.00k    5.12k    68.23%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  239.00us</span><br><span class="line">     75%  294.00us</span><br><span class="line">     90%  418.00us</span><br><span class="line">     99%   11.19ms</span><br><span class="line">  111391 requests in 30.09s, 12.24MB read</span><br><span class="line">Requests/sec:   3702.45</span><br><span class="line">Transfer/sec:    416.49KB</span><br></pre></td></tr></table></figure>

<p>如此大的性能差异显然是因为 TCP 连接的复用。你可能注意到了，刚才定义连接池时，我 将最大连接数设置为 1。所以，复用连接池方式复用的始终应该是同一个连接，而新建连接 池方式应该是每次都会创建新的 TCP 连接。</p>
<h3 id="Wireshark分析Http连接池"><a href="#Wireshark分析Http连接池" class="headerlink" title="Wireshark分析Http连接池"></a>Wireshark分析Http连接池</h3><p>如果调用 wrong2 接口每次创建新的连接池来发起 HTTP 请求，从 Wireshark 可以看到， 每次请求服务端 45678 的客户端端口都是新的。这里我发起了三次请求，程序通过</p>
<p><img alt="image-20200513064224058" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqfmdoqobj31d90u0qi6.jpg" class="lazyload"></p>
<p>使用wireshark分析TCP三次握手，四次挥手，设置窗口大小</p>
<p><img alt="image-20200513065350045" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqfy9pn60j31d90u04hh.jpg" class="lazyload"></p>
<ul>
<li>第一个框：三次握手</li>
<li>第二个框：设置窗口大小</li>
<li>第三个框：四次挥手</li>
</ul>
<p>而复用连接池方式的接口 right 的表现就完全不同了。端口复用，说明使用了连接池</p>
<p><img alt="image-20200513065921524" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqg3z6eo0j31d90u0anm.jpg" class="lazyload"></p>
<h2 id="连接池的配置不是一成不变的"><a href="#连接池的配置不是一成不变的" class="headerlink" title="连接池的配置不是一成不变的"></a>连接池的配置不是一成不变的</h2><p>为方便根据容量规划设置连接处的属性，连接池提供了许多参数，包括最小(闲置)连接、 最大连接、闲置连接生存时间、连接生存时间等。其中，最重要的参数是最大连接数，它决 定了连接池能使用的连接数量上限，达到上限后，新来的请求需要等待其他请求释放连接。</p>
<p>但，<strong>最大连接数不是设置得越大越好</strong>。如果设置得太大，不仅仅是客户端需要耗费过多的资 源维护连接，更重要的是由于服务端对应的是多个客户端，每一个客户端都保持大量的连接，会给服务端带来更大的压力。这个压力又不仅仅是内存压力，可以想一下如果服务端的 网络模型是一个 TCP 连接一个线程，那么几千个连接意味着几千个线程，如此多的线程会 造成大量的线程切换开销。</p>
<p>当然，<strong>连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量 低下，甚至超时无法获取连接</strong>。</p>
<p>栗子场景：模拟下压力增大导致数据库连接池打满的情况，来实践下如何确认连接池的 使用情况，以及有针对性地进行参数优化。</p>
<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用户注册方法，通过 <span class="doctag">@Transactional</span> 注解为方法开启事务。</span></span><br><span class="line"><span class="comment"> * 其中包含了 500 毫秒的休眠，一个数据库事务对应一个 TCP 连接，所以 500 多毫秒的时间都会占用数 据库连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"new-user-"</span> + System.currentTimeMillis());</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析默认hikari连接池最大值和最小值：<img alt="image-20200513071253077" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqgi1pjcdj31g60td42t.jpg" class="lazyload"></p>
<p>当我们使用wrk进行压测的时候，ActiveConnections立刻被打满，大量ThreadsAwaitingConnection。程序出现下面异常</p>
<p><code>java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30004ms.</code>连接获取不到，连接打满了。</p>
<p>解决方案，也很简单调整数据库最大连接池<code>spring.datasource.hikari.maximum-pool-size=50</code></p>
<p>在这个 Demo 里，我知道压测大概能对应使用 25 左右的并发连接，所以直接把连接池最 大连接设置为了 50。<strong>在真实情况下，只要数据库可以承受，你可以选择在遇到连接超限的 时候先设置一个足够大的连接数，然后观察最终应用的并发，再按照实际并发数留出一半的 余量来设置最终的最大连接。</strong></p>
<p>其实，看到错误日志后再调整已经有点儿晚了。更合适的做法是，<strong>对类似数据库连接池的重 要资源进行持续检测，并设置一半的使用量作为报警阈值，出现预警后及时扩容</strong>。</p>
<p><strong>这里要强调的是，修改配置参数务必验证是否生效，并且在监控系统中确认参数是否生效、 是否合理。之所以要“强调”，是因为这里有坑</strong>。</p>
<p>问题：有了连接池之后，获取连接是从连接池获取，没有足够连接时连接池会创建连接。这 时，获取连接操作往往有两个超时时间:</p>
<ul>
<li>一个是<strong>从连接池获取连接的最长等待时间</strong>，<strong>通 常叫作请求超时</strong> connectRequestTimeout 或等待超时 connectWaitTimeout;</li>
<li>一个是 连接池新建 TCP 连接三次握手的连接超时，<strong>通常叫作连接超时</strong> connectTimeout。针对 JedisPool、Apache HttpClient 和 Hikari 数据库连接池，你知道如何设置这 2 个参数 吗?</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"twotimeoutconfig"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTimeoutConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient httpClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        httpClient = HttpClients.createSystem();</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"mysql"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">mysql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//spring.datasource.hikari.connection-timeout=10000</span></span><br><span class="line">				<span class="comment">//spring.datasource.url=jdbc:mysql://localhost:6657/common_mistakes?connectTimeout=5000&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;rewriteBatchedStatements=true</span></span><br><span class="line">        <span class="comment">//调试StandardSocketFactory进行验证</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">"SELECT 'OK'"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"redis"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(<span class="number">1</span>);</span><br><span class="line">        config.setMaxWaitMillis(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">try</span> (JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>, <span class="number">5000</span>);</span><br><span class="line">             Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.set(<span class="string">"test"</span>, <span class="string">"test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"http"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">http</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">                .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">                .setConnectionRequestTimeout(<span class="number">10000</span>)</span><br><span class="line">                .build();</span><br><span class="line">        HttpGet httpGet = <span class="keyword">new</span> HttpGet(<span class="string">"http://127.0.0.1:45678/twotimeoutconfig/test"</span>);</span><br><span class="line">        httpGet.setConfig(requestConfig);</span><br><span class="line">        <span class="keyword">try</span> (CloseableHttpResponse response = httpClient.execute(httpGet)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>我以三种业务代码最常用的 Redis 连接池、HTTP 连接池、数据库连接池为例，和 你探讨了有关连接池实现方式、使用姿势和参数配置的三大问题。</p>
<ol>
<li>客户端 SDK 实现连接池的方式，包括池和连接分离、内部带有连接池和非连接池三种。要 正确使用连接池，就必须首先鉴别连接池的实现方式。比如，Jedis 的 API 实现的是池和连 接分离的方式，而 Apache HttpClient 是内置连接池的 API。</li>
<li>对于使用姿势其实就是两点，一是确保连接池是复用的，二是尽可能在程序退出之前显式关 闭连接池释放资源。连接池设计的初衷就是为了保持一定量的连接，这样连接可以随取随 用。从连接池获取连接虽然很快，但连接池的初始化会比较慢，需要做一些管理模块的初始 化以及初始最小闲置连接。一旦连接池不是复用的，那么其性能会比随时创建单一连接更 差。</li>
<li>最后，连接池参数配置中，最重要的是最大连接数，许多高并发应用往往因为最大连接数不 够导致性能问题。但，最大连接数不是设置得越大越好，够用就好。需要注意的是，针对数 据库连接池、HTTP 连接池、Redis 连接池等重要连接池，务必建立完善的监控和报警机 制，根据容量规划及时调整参数配置。</li>
</ol>
<h1 id="序列化-一来一回你还是原来的你吗"><a href="#序列化-一来一回你还是原来的你吗" class="headerlink" title="序列化:一来一回你还是原来的你吗?"></a><strong>序列化:一来一回你还是原来的你吗?</strong></h1><p>今天，我来和你聊聊序列化相关的坑和最佳实践。</p>
<p>序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流 转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过 程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序 列化算法制定规则。</p>
<p>关于序列化算法，几年前常用的有 JDK(Java)序列化、XML 序列化等，但前者不能跨语 言，后者性能较差(时间空间开销大);现在 RESTful 应用最常用的是 JSON 序列化，追 求性能的 RPC 框架(比如 gRPC)使用 protobuf 序列化，这 2 种方法都是跨语言的，而 且性能不错，应用广泛。</p>
<p>通常情况下，序列化问题常见的坑会集中在业务场景中，比如 Redis、 参数和响应序列化反序列化。</p>
<h2 id="序列化和反序列化需要确保算法一致"><a href="#序列化和反序列化需要确保算法一致" class="headerlink" title="序列化和反序列化需要确保算法一致"></a><strong>序列化和反序列化需要确保算法一致</strong></h2><p>业务代码中涉及序列化时，很重要的一点是要确保序列化和反序列化的算法一致性。</p>
<p>栗子场景：有一次要排查缓存命中率问题，需要运维同学帮忙拉取 Redis 中的 Key，结果他反馈 Redis 中 存的都是乱码，怀疑 Redis 被攻击了。其实呢，这个问题就是序列化算法导致的，我们来 看下吧。</p>
<p>使用 RedisTemplate 来操作 Redis 进行数据缓存。因为相比于 Jedis，使用 Spring 提供的 RedisTemplate 操作 Redis，除了无需考虑连接池、更方便 外，还可以与 Spring Cache 等其他组件无缝整合。如果使用 Spring Boot 的话，无需任 何配置就可以直接使用。</p>
<p>数据(包含 Key 和 Value)要保存到 Redis，需要经过序列化算法来序列化成字符串。虽 然 Redis 支持多种数据结构，比如 Hash，但其每一个 field 的 Value 还是字符串。如果 Value 本身也是字符串的话，能否有便捷的方式来使RedisTemplate，而无需考虑序列 化呢？答案：其实是有的，那就是 StringRedisTemplate。</p>
<p>那 StringRedisTemplate 和 RedisTemplate 的区别是什么呢?开头提到的乱码又是怎么 回事呢？</p>
<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在应用初始化完成后向 Redis 设置两组数据，</span></span><br><span class="line"><span class="comment"> * 第一次使用 RedisTemplate 设置 Key 为 redisTemplate、Value 为 User 对象，</span></span><br><span class="line"><span class="comment"> * 第二次使用 StringRedisTemplate 设置 Key 为 stringRedisTemplate、Value 为 JSON 序列化后的 User 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> JsonProcessingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"redisTemplate"</span>, <span class="keyword">new</span> User(<span class="string">"zhuye"</span>, <span class="number">36</span>));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"stringRedisTemplate"</span>, objectMapper.writeValueAsString(<span class="keyword">new</span> User(<span class="string">"zhuye"</span>, <span class="number">36</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * //运行结果：程序无法正确读取打印期望值</span></span><br><span class="line"><span class="comment"> * 通过 RedisTemplate 读取 Key 为 stringRedisTemplate 的 Value，</span></span><br><span class="line"><span class="comment"> * 使 用 StringRedisTemplate 读取 Key 为 redisTemplate 的 Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"redisTemplate get &#123;&#125;"</span>, redisTemplate.opsForValue().get(<span class="string">"stringRedisTemplate"</span>));</span><br><span class="line">    log.info(<span class="string">"stringRedisTemplate get &#123;&#125;"</span>, stringRedisTemplate.opsForValue().get(<span class="string">"redisTemplate"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RedisTemplate 读出的数据，由于是 Object 类型的，使用时可以先强制转换为 User 类型;</span></span><br><span class="line"><span class="comment"> * 使用 StringRedisTemplate 读取出的字符串，需要手动将 JSON 反序列化为 User 类 型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> JsonProcessingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    User userFromRedisTemplate = (User) redisTemplate.opsForValue().get(<span class="string">"redisTemplate"</span>);</span><br><span class="line">    log.info(<span class="string">"redisTemplate get &#123;&#125;"</span>, userFromRedisTemplate);</span><br><span class="line">    User userFromStringRedisTemplate = objectMapper.readValue(stringRedisTemplate.opsForValue().get(<span class="string">"stringRedisTemplate"</span>), User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    log.info(<span class="string">"stringRedisTemplate get &#123;&#125;"</span>, userFromStringRedisTemplate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.data.redis.core.RedisTemplate#afterPropertiesSet</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (non-Javadoc)</span></span><br><span class="line"><span class="comment">	 * @see org.springframework.data.redis.core.RedisAccessor#afterPropertiesSet()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</span><br><span class="line">					classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">				keySerializer = defaultSerializer;</span><br><span class="line">				defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">				valueSerializer = defaultSerializer;</span><br><span class="line">				defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">				hashKeySerializer = defaultSerializer;</span><br><span class="line">				defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">				hashValueSerializer = defaultSerializer;</span><br><span class="line">				defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">			Assert.notNull(defaultSerializer, <span class="string">"default serializer null and not all serializers initialized"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (scriptExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.scriptExecutor = <span class="keyword">new</span> DefaultScriptExecutor&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		initialized = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org.springframework.data.redis.core.StringRedisTemplate</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setKeySerializer(RedisSerializer.string());</span><br><span class="line">		setValueSerializer(RedisSerializer.string());</span><br><span class="line">		setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">		setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">org.springframework.data.redis.serializer.RedisSerializer</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Serialize the given object to binary data.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> t object to serialize. Can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the equivalent binary data. Can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> T t) <span class="keyword">throws</span> SerializationException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Deserialize an object from the given binary data.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes object binary representation. Can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the equivalent object instance. Can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a &#123;<span class="doctag">@link</span> RedisSerializer&#125; using java serialization.&lt;br /&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;strong&gt;Note:&lt;/strong&gt; Ensure that your domain objects are actually &#123;<span class="doctag">@link</span> java.io.Serializable serializable&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> RedisSerializer&lt;Object&gt; <span class="title">java</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> java(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a &#123;<span class="doctag">@link</span> RedisSerializer&#125; using java serialization with the given &#123;<span class="doctag">@link</span> ClassLoader&#125;.&lt;br /&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;strong&gt;Note:&lt;/strong&gt; Ensure that your domain objects are actually &#123;<span class="doctag">@link</span> java.io.Serializable serializable&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the &#123;<span class="doctag">@link</span> ClassLoader&#125; to use for deserialization. Can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> new instance of &#123;<span class="doctag">@link</span> RedisSerializer&#125;. Never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> RedisSerializer&lt;Object&gt; <span class="title">java</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkSerializationRedisSerializer(classLoader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a &#123;<span class="doctag">@link</span> RedisSerializer&#125; that can read and write JSON using</span></span><br><span class="line"><span class="comment">	 * &lt;a href="https://github.com/FasterXML/jackson-core"&gt;Jackson&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> RedisSerializer&lt;Object&gt; <span class="title">json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a simple &#123;<span class="doctag">@link</span> java.lang.String&#125; to &#123;<span class="doctag">@literal</span> byte[]&#125; (and back) serializer using</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> java.nio.charset.StandardCharsets#UTF_8 UTF-8&#125; as the default &#123;<span class="doctag">@link</span> java.nio.charset.Charset&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a &#123;<span class="doctag">@link</span> RedisSerializer&#125; that passes thru &#123;<span class="doctag">@code</span> byte[]&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> RedisSerializer&lt;<span class="keyword">byte</span>[]&gt; byteArray() &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteArrayRedisSerializer.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">canSerialize</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ClassUtils.isAssignable(getTargetType(), type);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> Class&lt;?&gt; getTargetType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>redis-cli 看到的类似一串乱码的”\xac\xed\x00\x05t\x00\rredisTemplate”字符串， 其实就是字符串 redisTemplate 经过 JDK 序列化后的结果</strong>。</p>
<p>看到这里你可能会说，使用 RedisTemplate 获取 Value 虽然方便，但是 Key 和 Value 不 易读;而使用 StringRedisTemplate 虽然 Key 是普通字符串，但是 Value 存取需要手动 序列化成字符串，有没有两全其美的方式呢?</p>
<p>当然有，自己定义 RedisTemplate 的 Key 和 Value 的序列化方式即可:Key 的序列化使 用 RedisSerializer.string()(也就是 StringRedisSerializer 方式)实现字符串序列化，而 Value 的序列化使用 Jackson2JsonRedisSerializer。</p>
<p>最佳实践源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">RedisTemplate&lt;String, T&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, T&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.enable(DeserializationFeature.USE_LONG_FOR_INTS);</span><br><span class="line">    <span class="comment">//把类型信息作为属性写入Value</span></span><br><span class="line">    objectMapper.activateDefaultTyping(objectMapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">    redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h1 id="分析定位Java问题，一定要用好这些工具（一）"><a href="#分析定位Java问题，一定要用好这些工具（一）" class="headerlink" title="分析定位Java问题，一定要用好这些工具（一）"></a>分析定位Java问题，一定要用好这些工具（一）</h1><p>在工作、学习过程中，你会发现我在介绍各种坑的时候，并不是直接给出问题的结论，而是通过工具来亲眼看到问题。</p>
<p>为什么这么做呢？因为我始终认为，遇到问题尽量不要去猜，一定要眼见为实。只有通过日志、监控或工具真正看到问题，然后再回到代码中进行比对确认，我们才能认为是找到了根本原因。</p>
<p>你可能一开始会比较畏惧使用复杂的工具去排查问题，又或者是打开了工具感觉无从下手，但是随着实践越来越多，对 Java 程序和各种框架的运作越来越熟悉，你会发现使用这些工具越来越顺手。其实呢，工具只是我们定位问题的手段，要用好工具主要还是得对程序本身的运作有大概的认识，这需要长期的积累。</p>
<p>今天分享四个栗子：</p>
<ol>
<li>展示使用 JDK 自带的工具来排查 JVM 参数配置问题</li>
<li>使用 Wireshark 来分析网络问题</li>
<li>通过 MAT 来分析内存问题</li>
<li>使用 Arthas 来分析 CPU 使用高的问题</li>
</ol>
<h2 id="使用-JDK-自带工具查看-JVM-情况"><a href="#使用-JDK-自带工具查看-JVM-情况" class="headerlink" title="使用 JDK 自带工具查看 JVM 情况"></a>使用 JDK 自带工具查看 JVM 情况</h2><p><img alt="image-20200518065439435" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gew82oozxoj313c0qokbl.jpg" class="lazyload"></p>
<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//wrong: java -jar common-mistakes-0.0.1-SNAPSHOT.jar -Xms1g -Xmx1g</span></span><br><span class="line">    <span class="comment">//right: java -Xms1g -Xmx1g -jar common-mistakes-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//wrong: java -XX:ThreadStackSize=256k common-mistakes-0.0.1-SNAPSHOT.jar</span></span><br><span class="line">    <span class="comment">//right: java -XX:ThreadStackSize=256 common-mistakes-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-Xms1g -Xmx1g -XX:NativeMemoryTracking=summary</span></span><br><span class="line">    System.out.println(<span class="string">"VM options"</span>);</span><br><span class="line">    System.out.println(ManagementFactory.getRuntimeMXBean().getInputArguments().stream().collect(Collectors.joining(System.lineSeparator())));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Program arguments"</span>);</span><br><span class="line">    System.out.println(Arrays.stream(args).collect(Collectors.joining(System.lineSeparator())));</span><br><span class="line"></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).mapToObj(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String payload = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">                    .mapToObj(__ -&gt; <span class="string">"a"</span>)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">""</span>)) + UUID.randomUUID().toString();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(payload.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).forEach(Thread::start);</span><br><span class="line"></span><br><span class="line">    TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">jinfo pid</span><br><span class="line"><span class="meta">#</span><span class="bash">图形化工具</span></span><br><span class="line">jconsole、visualVM</span><br><span class="line">jstat</span><br><span class="line"><span class="meta">#</span><span class="bash">-gcutil 输出 GC 和内存占用汇总信息，每隔 5 秒输出一次，输出 100 次</span></span><br><span class="line">jstat -gcutil 23940 5000 100</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 89.56   0.00  51.39  45.37  94.40  84.35    311    7.667    62    3.184   10.851</span><br><span class="line"> 68.70   0.00  58.66  56.54  94.40  84.35    313    7.688    62    3.184   10.872</span><br><span class="line"> 93.19   0.00  29.10  42.58  94.40  84.35    317    7.755    63    3.227   10.982</span><br><span class="line">  0.00  98.83  58.14  56.40  94.40  84.35    320    7.789    63    3.227   11.016</span><br><span class="line">  0.00  99.33  23.37  42.90  94.40  84.35    324    7.896    64    3.276   11.172</span><br><span class="line"> 56.35   0.00   3.56  64.94  94.40  84.35    327    7.944    64    3.276   11.220</span><br><span class="line"> 88.93   0.00  23.42  45.41  94.40  84.35    331    8.030    65    3.334   11.364</span><br><span class="line"> 87.91   0.00  97.23  59.07  94.40  84.35    333    8.057    65    3.334   11.390</span><br><span class="line">  0.00  89.98  23.29  45.34  94.40  84.35    338    8.127    66    3.412   11.539</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">查看线程状态  </span></span><br><span class="line">jstack pid</span><br><span class="line">jcmd pid VM.native_memory summary  </span><br><span class="line"><span class="meta">#</span><span class="bash">更改启动参数：开启 NMT 功能</span></span><br><span class="line">-Xms1g -Xmx1g -XX:ThreadStackSize=256k -XX:NativeMemoryTracking=detail</span><br><span class="line">jcmd pid VM.native_memory detail</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有jcmd的所有功能</span></span><br><span class="line">jcmd pid help</span><br><span class="line"><span class="meta">#</span><span class="bash">输出参数</span></span><br><span class="line">JFR.stop</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br></pre></td></tr></table></figure>

<blockquote>
<p>jstat命令解释</p>
<p>S0 表示 Survivor0 区占用百分比，S1 表示 Survivor1 区占用百分比，E 表示 Eden 区占用百分比，O 表示老年代占用百分比，M 表示元数据区占用百分比，YGC 表示年轻代回收次数，YGCT 表示年轻代回收耗时，FGC 表示老年代回收次数，FGCT 表示老年代回收耗时。</p>
</blockquote>
<h2 id="使用-Wireshark-分析-SQL-批量插入慢的问题"><a href="#使用-Wireshark-分析-SQL-批量插入慢的问题" class="headerlink" title="使用 Wireshark 分析 SQL 批量插入慢的问题"></a>使用 Wireshark 分析 SQL 批量插入慢的问题</h2><p>有一个数据导入程序需要导入大量的数据，开发同学就想到了使用 Spring JdbcTemplate 的批量操作功能进行数据批量导入，但是发现性能非常差，和普通的单条 SQL 执行性能差不多。</p>
<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchInsertApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BatchInsertApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.execute(<span class="string">"drop table IF EXISTS `testuser`;"</span>);</span><br><span class="line">        jdbcTemplate.execute(<span class="string">"create TABLE `testuser` (\n"</span> +</span><br><span class="line">                <span class="string">"  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n"</span> +</span><br><span class="line">                <span class="string">"  `name` varchar(255) NOT NULL,\n"</span> +</span><br><span class="line">                <span class="string">"  PRIMARY KEY (`id`)\n"</span> +</span><br><span class="line">                <span class="string">") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//没有优化之前：插入1w条数据耗时22s</span></span><br><span class="line">  	<span class="comment">//加上参数之后程序优化后，耗时为200ms</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        String sql = <span class="string">"INSERT INTO `testuser` (`name`) VALUES (?)"</span>;</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                preparedStatement.setString(<span class="number">1</span>, <span class="string">"usera"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"took : &#123;&#125; ms"</span>, System.currentTimeMillis() - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，对于批量操作，我们希望程序可以把多条 insert SQL 语句合并成一条，或至少是一次性提交多条语句到数据库，以减少和 MySQL 交互次数、提高性能。那么，我们的程序是这样运作的吗？</p>
<p>使用wireshark抓包工具分析是否真的批量执行了？<img alt="image-20200519074856273" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexf9gdchuj31g30td48b.jpg" class="lazyload"></p>
<p>源码分析：com.mysql.cj.jdbc.ClientPreparedStatement#executeBatchInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span>[] executeBatchInternal() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkClosed().getConnectionMutex()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.isReadOnly()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(Messages.getString(<span class="string">"PreparedStatement.25"</span>) + Messages.getString(<span class="string">"PreparedStatement.26"</span>),</span><br><span class="line">                    MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.query.getBatchedArgs() == <span class="keyword">null</span> || <span class="keyword">this</span>.query.getBatchedArgs().size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we timeout the entire batch, not individual statements</span></span><br><span class="line">        <span class="keyword">int</span> batchTimeout = getTimeoutInMillis();</span><br><span class="line">        setTimeoutInMillis(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        resetCancelledState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statementBegins();</span><br><span class="line"></span><br><span class="line">            clearWarnings();</span><br><span class="line">			 <span class="comment">//判断了 rewriteBatchedStatements 参数是否为 true，是才会开启批量的优化。</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.batchHasPlainStatements &amp;&amp; <span class="keyword">this</span>.rewriteBatchedStatements.getValue()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getParseInfo().canRewriteAsMultiValueInsertAtSqlLevel()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> executeBatchedInserts(batchTimeout);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.batchHasPlainStatements &amp;&amp; <span class="keyword">this</span>.query.getBatchedArgs() != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; <span class="keyword">this</span>.query.getBatchedArgs().size() &gt; <span class="number">3</span> <span class="comment">/* cost of option setting rt-wise */</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> executePreparedBatchAsMultiStatement(batchTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> executeBatchSerially(batchTimeout);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.query.getStatementExecuting().set(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            clearBatch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ul>
<li>如果有条件的话，优先把 insert 语句优化为一条语句，也就是 executeBatchedInserts 方法；</li>
<li>如果不行的话，再尝试把 insert 语句优化为多条语句一起提交，也就是 executePreparedBatchAsMultiStatement 方法。</li>
<li><code>spring.datasource.url=jdbc:mysql://localhost:6657/common_mistakes?characterEncoding=UTF-8&amp;useSSL=false&amp;rewriteBatchedStatements=true</code></li>
</ul>
<p>使用wireshark分析批量操作：</p>
<p><img alt="image-20200519081047295" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexfw57r8oj31g30td48g.jpg" class="lazyload"></p>
<ul>
<li>这次 insert SQL 语句被拼接成了一条语句</li>
<li>这个 TCP 包因为太大被分割成了 11 个片段传输，#852 请求是最后一个片段，其实际内容是 insert 语句的最后一部分内容。</li>
<li>查看最开始的握手数据包可以发现，TCP 的最大分段大小（MSS）是 16344 字节，而我们的 MySQL 超长 insert 的数据一共 138933 字节，因此被分成了 11 段传输，其中最大的一段是 16332 字节，低于 MSS 要求的 16344 字节。</li>
</ul>
<p><img alt="image-20200519082011720" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexg6160izj311o0sah08.jpg" class="lazyload"></p>
<p>问题分析：JDK 中还有一个 jmap 工具，我们会使用 jmap -dump 命令来进行堆转储。那么，这条命令和 jmap -dump:live 有什么区别呢？你能否设计一个实验，来证明下它们的区别呢？</p>
<ul>
<li>jmap -dump是会dump所有的对象，不关心是否可达；jmap -dump:live只会dump存活的对象，即可以从GcRoot可达的对象。测试是在循环中，一直创建对象，然后休眠1s，dump2次，发现创建对象的个数不同。</li>
<li>gc次数不是主要优化目标，gc优化目标一般是吞吐量(throughput) 或者暂停时间(pause times)，具体可以搜一下相关资料</li>
</ul>
<h1 id="分析定位Java问题，一定要用好这些工具-二"><a href="#分析定位Java问题，一定要用好这些工具-二" class="headerlink" title="分析定位Java问题，一定要用好这些工具(二)"></a><strong>分析定位</strong>Java问题，一定要用好这些工具(二)</h1><h2 id="使用MAT分析OOM问题"><a href="#使用MAT分析OOM问题" class="headerlink" title="使用MAT分析OOM问题"></a>使用MAT分析OOM问题</h2><p>对于排查 OOM 问题、分析程序堆内存使用情况，最好的方式就是分析堆转储。</p>
<p>堆转储，包含了堆现场全貌和线程栈信息(Java 6 Update 14 开始包含)。我们在上一篇中看到，使用 jstat 等工具虽然可以观察堆内存使用情况的变化，但是对程序内到底有 多少对象、哪些是大对象还一无所知，也就是说只能看到问题但无法定位问题。而堆转储， 就好似得到了病人在某个瞬间的全景核磁影像，可以拿着慢慢分析。</p>
<p>JVM参数一定要加上：<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=.</code></p>
<p>使用 MAT 分析 OOM 问题，一般可以按照以下思路进行:（直方图、支配树、线程栈、OQL）</p>
<ol>
<li>通过支配树功能或直方图功能查看消耗内存最大的类型，来分析内存泄露的大概原因;</li>
<li>查看那些消耗内存最大的类型、详细的对象明细列表，以及它们的引用链，来定位内存 泄露的具体点;</li>
<li>配合查看对象属性的功能，可以脱离源码看到对象的各种属性的值和依赖关系，帮助我 们理清程序逻辑和参数;</li>
<li>辅助使用查看线程栈来看 OOM 问题是否和过多线程有关，甚至可以在线程栈看到 OOM 最后一刻出现异常的线程。</li>
</ol>
<p>首先，用 MAT 打开后先进入的是概览信息界面，可以看到整个堆是 437.6MB：</p>
<p><img alt="image-20200520074534459" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyks9exqjj316a0qt45k.jpg" class="lazyload"></p>
<p>如图所示，工具栏的第二个按钮可以打开直方图，直方图按照类型进行分组，列出了每个类有多少个实例，以及占用的内存。可以看到，char[]字节数组占用内存最多，对象数量也很多，结合第二位的 String 类型对象数量也很多，大概可以猜出（String 使用 char[]作为实际数据存储）程序可能是被字符串占满了内存，导致 OOM。<img alt="image-20200520074635288" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyktacvraj30tp0qck96.jpg" class="lazyload"></p>
<p>我们继续分析下，到底是不是这样呢。</p>
<p>在 char[]上点击右键，选择 List objects-&gt;with incoming references，就可以列出所有的 char[]实例，以及每个 char[]的整个引用关系链：<img alt="image-20200520074805942" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geykuugf5gj318905oah3.jpg" class="lazyload"></p>
<p><img alt="image-20200520074909879" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geykvyvteuj31f20e7tq2.jpg" class="lazyload"></p>
<p>接下来，我们按照红色框中的引用链来查看，尝试找到这些大 char[]的来源：</p>
<ol>
<li>在①处看到，这些 char[]几乎都是 10000 个字符、占用 20000 字节左右（char 是 UTF-16，每一个字符占用 2 字节）；</li>
<li>在②处看到，char[]被 String 的 value 字段引用，说明 char[]来自字符串；</li>
<li>在③处看到，String 被 ArrayList 的 elementData 字段引用，说明这些字符串加入了一个 ArrayList 中；</li>
<li>在④处看到，ArrayList 又被 FooService 的 data 字段引用，这个 ArrayList 整个 RetainedHeap 列的值是 431MB。</li>
</ol>
<p>左侧的蓝色框可以查看每一个实例的内部属性，图中显示 FooService 有一个 data 属性，类型是 ArrayList。</p>
<p>Retained Heap（深堆）代表对象本身和对象关联的对象占用的内存，Shallow Heap（浅堆）代表对象本身占用的内存。比如，我们的 FooService 中的 data 这个 ArrayList 对象本身只有 16 字节，但是其所有关联的对象占用了 431MB 内存。这些就可以说明，肯定有哪里在不断向这个 List 中添加 String 数据，导致了 OOM。</p>
<p>如果我们希望看到字符串完整内容的话，可以右键选择 Copy-&gt;Value，把值复制到剪贴板或保存到文件中：</p>
<p><img alt="image-20200520075205221" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geykz04d9lj324i0s8hdu.jpg" class="lazyload"></p>
<p>其实，我们之前使用直方图定位 FooService，已经走了些弯路。你可以点击工具栏中第三个按钮（下图左上角的红框所示）进入支配树界面（有关支配树的具体概念参考这里）。这个界面会按照对象保留的 Retained Heap 倒序直接列出占用内存最大的对象。</p>
<p><img alt="image-20200520075353950" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyl0z0kgjj31ey0lrnn9.jpg" class="lazyload"></p>
<p>可以看到，第一位就是 FooService，整个路径是 FooSerice-&gt;ArrayList-&gt;Object[]-&gt;String-&gt;char[]（蓝色框部分），一共有 21523 个字符串（绿色方框部分）。</p>
<p>这样，我们就从内存角度定位到 FooService 是根源了。那么，OOM 的时候，FooService 是在执行什么逻辑呢？</p>
<p>为解决这个问题，我们可以点击工具栏的第五个按钮（下图红色框所示）。打开线程视图，首先看到的就是一个名为 main 的线程（Name 列），展开后果然发现了 FooService：</p>
<p><img alt="image-20200520080029131" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geyl7umbcwj31w60u0h07.jpg" class="lazyload"></p>
<ul>
<li>先执行的方法先入栈，所以线程栈最上面是线程当前执行的方法，逐一往下看能看到整个调用路径。因为我们希望了解 FooService.oom() 方法，看看是谁在调用它，它的内部又调用了谁，所以选择以 FooService.oom() 方法（蓝色框）为起点来分析这个调用栈。</li>
<li>往下看整个绿色框部分，oom() 方法被 OOMApplication 的 run 方法调用，而这个 run 方法又被 SpringAppliction.callRunner 方法调用。看到参数中的 CommandLineRunner 你应该能想到，OOMApplication 其实是实现了 CommandLineRunner 接口，所以是 SpringBoot 应用程序启动后执行的。</li>
<li>以 FooService 为起点往上看，从紫色框中的 Collectors 和 IntPipeline，你大概也可以猜出，这些字符串是由 Stream 操作产生的。再往上看，可以发现在 StringBuilder 的 append 操作的时候，出现了 OutOfMemoryError 异常（黑色框部分），说明这这个线程抛出了 OOM 异常。</li>
</ul>
<p>我们看到，整个程序是 Spring Boot 应用程序，那么 FooService 是不是 Spring 的 Bean 呢，又是不是单例呢？如果能分析出这点的话，就更能确认是因为反复调用同一个 FooService 的 oom 方法，然后导致其内部的 ArrayList 不断增加数据的。</p>
<p>点击工具栏的第四个按钮（如下图红框所示），来到 OQL 界面。在这个界面，我们可以使用类似 SQL 的语法，在 dump 中搜索数据（你可以直接在 MAT 帮助菜单搜索 OQL Syntax，来查看 OQL 的详细语法）。</p>
<p>比如，输入如下语句搜索 FooService 的实例：<code>SELECT * FROM org.geekbang.time.commonmistakes.troubleshootingtools.oom.FooService</code></p>
<p><img alt="image-20200520080435306" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geylc03oiej322x0u0dyt.jpg" class="lazyload"></p>
<p><img alt="image-20200520080522410" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geylctuo4ej31lm0jkwp4.jpg" class="lazyload"></p>
<p>可以看到，一共两处引用：</p>
<ul>
<li>第一处是，OOMApplication 使用了 FooService，这个我们已经知道了。</li>
<li>第二处是一个 ConcurrentHashMap。可以看到，这个 HashMap 是 DefaultListableBeanFactory 的 singletonObjects 字段，可以证实 FooService 是 Spring 容器管理的单例的 Bean。</li>
</ul>
<p>OOM源码栗子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FooService fooService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-Xmx512m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OOMApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            fooService.oom();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add(IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10_000</span>)</span><br><span class="line">                .mapToObj(__ -&gt; <span class="string">"a"</span>)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">""</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Arthas-分析高-CPU-问题"><a href="#使用-Arthas-分析高-CPU-问题" class="headerlink" title="使用 Arthas 分析高 CPU 问题"></a>使用 Arthas 分析高 CPU 问题</h2><p>Arthas是阿里开源的 Java 诊断工具，相比 JDK 内置的诊断工具，要更人性化，并且功能强大，可以实现许多问题的一键定位，而且可以一键反编译类查看源码，甚至是直接进行生产代码热修复，实现在一个工具内快速定位和修复问题的一站式服务。今天，我就带你使用 Arthas 定位一个 CPU 使用高的问题，系统学习下这个工具的使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@37806]$</span><span class="bash"> <span class="built_in">help</span></span></span><br><span class="line"> NAME         DESCRIPTION</span><br><span class="line"> help         Display Arthas Help</span><br><span class="line"> keymap       Display all the available keymap for the specified connection.</span><br><span class="line"> sc           Search all the classes loaded by JVM</span><br><span class="line"> sm           Search the method of classes loaded by JVM</span><br><span class="line"> classloader  Show classloader info</span><br><span class="line"> jad          Decompile class</span><br><span class="line"> getstatic    Show the static field of a class</span><br><span class="line"> monitor      Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc.</span><br><span class="line"> stack        Display the stack trace for the specified class and method</span><br><span class="line"> thread       Display thread info, thread stack</span><br><span class="line"> trace        Trace the execution time of specified method invocation.</span><br><span class="line"> watch        Display the input/output parameter, return object, and thrown exception of specified method invocation</span><br><span class="line"> tt           Time Tunnel</span><br><span class="line"> jvm          Display the target JVM information</span><br><span class="line"> ognl         Execute ognl expression.</span><br><span class="line"> mc           Memory compiler, compiles java files into bytecode and class files in memory.</span><br><span class="line"> redefine     Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...)</span><br><span class="line"> dashboard    Overview of target jvm's thread, memory, gc, vm, tomcat info.</span><br><span class="line"> dump         Dump class byte array from JVM</span><br><span class="line"> heapdump     Heap dump</span><br><span class="line"> options      View and change various Arthas options</span><br><span class="line"> cls          Clear the screen</span><br><span class="line"> reset        Reset all the enhanced classes</span><br><span class="line"> version      Display Arthas version</span><br><span class="line"> shutdown     Shutdown Arthas server and exit the console</span><br><span class="line"> stop         Stop/Shutdown Arthas server and exit the console. Alias for shutdown.</span><br><span class="line"> session      Display current session information</span><br><span class="line"> sysprop      Display, and change the system properties.</span><br><span class="line"> sysenv       Display the system env.</span><br><span class="line"> vmoption     Display, and update the vm diagnostic options.</span><br><span class="line"> logger       Print logger info, and update the logger level</span><br><span class="line"> history      Display command history</span><br><span class="line"> cat          Concatenate and print files</span><br><span class="line"> pwd          Return working directory name</span><br><span class="line"> mbean        Display the mbean information</span><br><span class="line"> grep         grep command for pipes.</span><br><span class="line"> profiler     Async Profiler. https://github.com/jvm-profiling-tools/async-profiler</span><br></pre></td></tr></table></figure>

<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighCPUApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] payload = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10_000</span>)</span><br><span class="line">            .mapToObj(__ -&gt; <span class="string">"a"</span>)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">""</span>)).getBytes();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        task();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            doTask(random.nextInt(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"r="</span> + atomicInteger.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == User.ADMIN_ID) &#123;</span><br><span class="line">            IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10000</span>).parallel().forEach(j -&gt; DigestUtils.md5DigestAsHex(payload));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arthas命令：dashboard用于整体展示进程所有线程、内存、GC 等情况</p>
<p><img alt="image-20200526073152986" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5i3yyzmbj317i0q9b29.jpg" class="lazyload"></p>
<p>可以看到，CPU 高并不是 GC 引起的，占用 CPU 较多的线程有 8 个，其中 7 个是 ForkJoinPool.commonPool。ForkJoinPool.commonPool 是并行流默认使用的线程池。所以，此次 CPU 高的问题，应 该出现在某段并行流的代码上。</p>
<p>接下来，要查看最繁忙的线程在执行的线程栈，可以使用 thread -n 命令。这里，我们查 看下最忙的 8 个线程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看最繁忙的n的线程</span></span><br><span class="line">thread -n</span><br><span class="line"><span class="meta">#</span><span class="bash">查看第n个线程正在执行的业务</span></span><br><span class="line">thread n</span><br></pre></td></tr></table></figure>

<p>可以看到，由于这些线程都在处理 MD5 的操作，所以占用了大量 CPU 资源。我们希望分 析出代码中哪些逻辑可能会执行这个操作，所以需要从方法栈上找出我们自己写的类，并重 点关注。</p>
<p>由于主线程也参与了 ForkJoinPool 的任务处理，因此我们可以通过主线程的栈看到需要重 点关注。</p>
<p>接下来，使用 jad 命令直接对 HighCPUApplication 类反编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad org.geekbang.time.commonmistakes.troubleshootingtools.arthas.HighCPUApplication</span><br></pre></td></tr></table></figure>

<p><img alt="arthas-jad" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5iu4bqfnj31780ra7wh.jpg" class="lazyload"></p>
<p>你可能想到了，通过 jad 命令继续查看 User 类即可。这里因为是 Demo，所以我没有给出 很复杂的逻辑。在业务逻辑很复杂的代码中，判断逻辑不可能这么直白，我们可能还需要分 析出 doTask 的“慢”会慢在什么入参上。</p>
<p>这时，我们可以使用 watch 命令来观察方法入参。如下命令，表示需要监控耗时超过 100 毫秒的 doTask 方法的入参，并且输出入参，展开 2 层入参参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch org.geekbang.time.commonmistakes.troubleshootingtools.arthas.HighCPUApplication doTask '&#123;params&#125;' '#cost&gt;100' -x 2</span><br></pre></td></tr></table></figure>

<p>可以看到，所有耗时较久的 doTask 方法的入参都是 0，意味着 User.ADMN_ID 常量应该 是 0。</p>
<p>最后，我们使用 ognl 命令来运行一个表达式，直接查询 User 类的 ADMIN_ID 静态字段 来验证是不是这样，得到的结果果然是 0:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">[arthas@31126]$</span><span class="bash"> ognl <span class="string">'@org.geekbang.time.commonmistakes.troubleshootingtools.highcpu.User@ADMIN_ID'</span></span></span><br><span class="line">@Integer[0]</span><br></pre></td></tr></table></figure>

<p>需要额外说明的是，由于 monitor、trace、watch 等命令是通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此诊断结束要执行 shutdown 来还原类或方法字节码，然后退出 Arthas。</p>
<p>对于应用故障分析，除了阿里 Arthas 之外，还可以关注去哪儿的Bistoury 工具，其提供 了可视化界面，并且可以针对多台机器进行管理，甚至提供了在线断点调试等功能，模拟 IDE 的调试体验。</p>
<h2 id="问题TODO"><a href="#问题TODO" class="headerlink" title="问题TODO"></a>问题TODO</h2><ol>
<li>在介绍线程池的时候，我们模拟了两种可能的 OOM 情况，一种是使用 Executors.newFixedThreadPool，一种是使用 Executors.newCachedThreadPool，你能回忆起 OOM 的原因吗？假设并不知道 OOM 的原因，拿到了这两种 OOM 后的堆转储，你能否尝试使用 MAT 分析堆转储来定位问题呢？</li>
<li>Arthas 还有一个强大的热修复功能。比如，遇到高 CPU 问题时，我们定位出是管理员用户会执行很多次 MD5，消耗大量 CPU 资源。这时，我们可以直接在服务器上进行热修复，步骤是：jad 命令反编译代码 -&gt; 使用文本编辑器（比如 Vim）直接修改代码 -&gt; 使用 sc 命令查找代码所在类的 ClassLoader-&gt; 使用 redefine 命令热更新代码。你可以尝试使用这个流程，直接修复程序（注释 doTask 方法中的相关代码）吗？</li>
</ol>
<h2 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>有一次开发同学遇到一个 OOM 问题，通过查监控、查日志、查调用链路排查了数小时也 无法定位问题，但我拿到堆转储文件后，直接打开支配树图一眼就看到了可疑点。Mybatis 每次查询都查询出了几百万条数据，通过查看线程栈马上可以定位到出现 Bug 的方法名， 然后来到代码果然发现因为参数条件为 null 导致了全表查询，整个定位过程不足 5 分钟。</p>
<p>从这个案例我们看到，使用正确的工具、正确的方法来分析问题，几乎可以在几分钟内定位 到问题根因。今天，我和你介绍的 MAT 正是分析 Java 堆内存问题的利器，而 Arthas 是 快速定位分析 Java 程序生产 Bug 的利器。利用好这两个工具，就可以帮助我们在分钟级 定位生产故障。</p>
<h1 id="当反射、注解和泛型遇到OOP时，会有哪些坑"><a href="#当反射、注解和泛型遇到OOP时，会有哪些坑" class="headerlink" title="当反射、注解和泛型遇到OOP时，会有哪些坑?"></a><strong>当反射、注解和泛型遇到</strong>OOP时，会有哪些坑?</h1><p>今天，我们聊聊 Java 高级特性的话题，看看反射、注解和泛型遇到重载 和继承时可能会产生的坑。</p>
<p>你可能说，业务项目中几乎都是增删改查，用到反射、注解和泛型这些高级特性的机会少之 又少，没啥好学的。但我要说的是，只有学好、用好这些高级特性，才能开发出更简洁易读 的代码，而且几乎所有的框架都使用了这三大高级特性。比如，要减少重复代码，就得用到 反射和注解()。</p>
<h2 id="反射调用方法不是以传参决定重载"><a href="#反射调用方法不是以传参决定重载" class="headerlink" title="反射调用方法不是以传参决定重载"></a>反射调用方法不是以传参决定重载</h2><p>反射的功能包括，在运行时动态获取类和类成员定义，以及动态读取属性调用方法。也就是 说，针对类动态调用方法，不管类中字段和方法怎么变动，我们都可以用相同的规则来读取 信息和执行方法。因此，几乎所有的 ORM(对象关系映射)、对象映射、MVC 框架都使 用了反射。</p>
<p>反射的起点是 Class 类，Class 类提供了各种方法帮我们查询它的信息。</p>
<p>栗子场景:我们先看一个反射调用方法遇到重载的坑:有两个叫 age 的方法，入参分别是基 本类型 int 和包装类型 Integer。</p>
<p>栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionIssueApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ReflectionIssueApplication application = <span class="keyword">new</span> ReflectionIssueApplication();</span><br><span class="line">        application.wrong();</span><br><span class="line">        application.right();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"int age = &#123;&#125;"</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">age</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Integer age = &#123;&#125;"</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 走int基本数据类型的重载方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        getClass().getDeclaredMethod(<span class="string">"age"</span>, Integer.TYPE).invoke(<span class="keyword">this</span>, Integer.valueOf(<span class="string">"36"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 都是走Integer包装类的重载方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        getClass().getDeclaredMethod("age", Integer.class).invoke(this, Integer.valueOf("36"));</span><br><span class="line">        getClass().getDeclaredMethod(<span class="string">"age"</span>, Integer<span class="class">.<span class="keyword">class</span>).<span class="title">invoke</span>(<span class="title">this</span>, 36)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但使用反射时的误区是，认为反射调用方法还是根据入参确定方法重载</strong>。现在我们非常清楚了，反射调用方法，是以反射获取方法时传入的方法名称和参数类型来确 定调用方法的。</p>
<h2 id="TODO：泛型经过类型擦除多出桥接方法的坑"><a href="#TODO：泛型经过类型擦除多出桥接方法的坑" class="headerlink" title="TODO：泛型经过类型擦除多出桥接方法的坑"></a>TODO：泛型经过类型擦除多出桥接方法的坑</h2><p>泛型是一种风格或范式，一般用于强类型程序设计语言，允许开发者使用类型参数替代明确 的类型，实例化时再指明具体的类型。它是代码重用的有效手段，允许把一套代码应用到多 种数据类型上，避免针对每一种数据类型实现重复的代码。</p>
<p>Java 编译器对泛型应用了强大的类型检测，如果代码违反了类型安全就会报错，可以在编 译时暴露大多数泛型的编码错误。但总有一部分编码错误，比如泛型类型擦除的坑，在运行 时才会暴露。接下来，我就和你分享一个案例吧。</p>
<p>正确姿势，栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问题：Child2 类其实有 2 个 setValue 方法，入参分别是 String 和 Object。其实，这就是泛型类型擦除导致的问题。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     * 1、通过 getDeclaredMethods 方法获取到所有方法后，必须同时根据方法名 setValue 和 非 isBridge 两个条件过滤，才能实现唯一过滤;</span></span><br><span class="line"><span class="comment">     * 2、使用 Stream 时，如果希望只匹配 0 或 1 项的话，可以考虑配合 ifPresent 来使用 findFirst 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Child2 child2 = <span class="keyword">new</span> Child2();</span><br><span class="line">        Arrays.stream(child2.getClass().getDeclaredMethods())</span><br><span class="line">                .filter(method -&gt; method.getName().equals(<span class="string">"setValue"</span>) &amp;&amp; !method.isBridge())</span><br><span class="line">                .findFirst().ifPresent(method -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method.invoke(child2, <span class="string">"test"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(child2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * todo：重写的方法是Object 类型的，还会有2个setValue的方法吗？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Child2.setValue called"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后小结下，使用反射查询类方法清单时，我们要注意两点</strong>:</p>
<ol>
<li>getMethods 和 getDeclaredMethods 是有区别的，前者可以查询到父类方法，后者只能查询到当前类。</li>
<li>反射进行方法调用要注意过滤桥接方法。</li>
</ol>
<h2 id="注解可以继承吗？"><a href="#注解可以继承吗？" class="headerlink" title="注解可以继承吗？"></a>注解可以继承吗？</h2><p>注解可以为 Java 代码提供元数据，各种框架也都会利用注解来暴露功能，比如 Spring 框 架中的 @Service、@Controller、@Bean 注解，Spring Boot 的 @SpringBootApplication 注解。</p>
<p>注解可以继承吗？栗子源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个注解作用在方法和类上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     * 在注解上面增加<span class="doctag">@Inherited</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Inherited</span> 只能实现类上的注解继承。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 要想实现方法上注解的继承，你可以通过反射在继承链上找到方法上的注解。但，这样实现起来很繁琐，而且需要考虑桥接方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">        log.info(<span class="string">"ParentClass:&#123;&#125;"</span>, getAnnotationValue(parent.getClass().getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line">        log.info(<span class="string">"ParentMethod:&#123;&#125;"</span>, getAnnotationValue(parent.getClass().getMethod(<span class="string">"foo"</span>).getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        log.info(<span class="string">"ChildClass:&#123;&#125;"</span>, getAnnotationValue(child.getClass().getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line">        log.info(<span class="string">"ChildMethod:&#123;&#125;"</span>, getAnnotationValue(child.getClass().getMethod(<span class="string">"foo"</span>).getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 提供了 AnnotatedElementUtils类，</span></span><br><span class="line"><span class="comment">     * 这个类的findMergedAnnotation工具方法，可以帮助我们找出父类和接口、父类方法和接口方法上的注解，并可以处理桥接方法，实现一键找到继承链的注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">        log.info(<span class="string">"ParentClass:&#123;&#125;"</span>, getAnnotationValue(parent.getClass().getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line">        log.info(<span class="string">"ParentMethod:&#123;&#125;"</span>, getAnnotationValue(parent.getClass().getMethod(<span class="string">"foo"</span>).getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line"></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        log.info(<span class="string">"ChildClass:&#123;&#125;"</span>, getAnnotationValue(AnnotatedElementUtils.findMergedAnnotation(child.getClass(), MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line">        log.info(<span class="string">"ChildMethod:&#123;&#125;"</span>, getAnnotationValue(AnnotatedElementUtils.findMergedAnnotation(child.getClass().getMethod(<span class="string">"foo"</span>), MyAnnotation<span class="class">.<span class="keyword">class</span>)))</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义带注解有父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value = <span class="string">"Class"</span>)</span><br><span class="line">    <span class="meta">@Slf</span>4j</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MyAnnotation</span>(value = <span class="string">"Method"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类（无注解）继承父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Slf</span>4j</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>todo：org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotation源码分析</p>
<p>问题思考</p>
<ol>
<li><p>泛型类型擦除后会生成一个 bridge 方法，这个方法同时又是 synthetic 方法。除了泛型 类型擦除，你知道还有什么情况编译器会生成 synthetic 方法吗?</p>
</li>
<li><p>关于注解继承问题，你觉得 Spring 的常用注解 @Service、@Controller 是否支持继承 呢?</p>
</li>
</ol>
<h2 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol>
<li>第一，反射调用方法并不是通过调用时的传参确定方法重载，而是在获取方法的时候通过方 法名和参数类型来确定的。遇到方法有包装类型和基本类型重载的时候，你需要特别注意这 一点。</li>
<li>第二，反射获取类成员，需要注意 getXXX 和 getDeclaredXXX 方法的区别，其中 XXX 包 括 Methods、Fields、Constructors、Annotations。这两类方法，针对不同的成员类型 XXX 和对象，在实现上都有一些细节差异，详情请查看官方文档。今天提到的 getDeclaredMethods 方法无法获得父类定义的方法，而 getMethods 方法可以，只是差 异之一，不能适用于所有的 XXX。</li>
<li>第三，泛型因为类型擦除会导致泛型方法 T 占位符被替换为 Object，子类如果使用具体类 型覆盖父类实现，编译器会生成桥接方法。这样既满足子类方法重写父类方法的定义，又满 足子类实现的方法有具体的类型。使用反射来获取方法清单时，你需要特别注意这一点。</li>
<li>第四，自定义注解可以通过标记元注解 @Inherited 实现注解的继承，不过这只适用于类。 如果要继承定义在接口或方法上的注解，可以使用 Spring 的工具类 AnnotatedElementUtils，并注意各种 getXXX 方法和 findXXX 方法的区别，详情查看spring的文档</li>
<li>编译后的代码和原始代码并不完全一致，编译器可能会做一些优化，加 上还有诸如 AspectJ 等编译时增强框架，使用反射动态获取类型的元数据可能会和我们编 写的源码有差异，这点需要特别注意。你可以在反射中多写断言，遇到非预期的情况直接抛 异常，避免通过反射实现的业务逻辑不符合预期。</li>
</ol>
<h1 id="Spring框架-IoC和AOP是扩展的核心"><a href="#Spring框架-IoC和AOP是扩展的核心" class="headerlink" title="Spring框架:IoC和AOP是扩展的核心"></a><strong>Spring</strong>框架:IoC和AOP是扩展的核心</h1><p>熟悉 Java 的同学都知道，Spring 的家族庞大，常用的模块就有 Spring Data、Spring Security、Spring Boot、Spring Cloud 等。其实呢，Spring 体系虽然庞大，但都是围绕 Spring Core 展开的，而 Spring Core 中最核心的就是 IoC(控制反转)和 AOP(面向切 面编程)。</p>
<p>概括地说，IoC 和 AOP 的初衷是解耦和扩展。理解这两个核心技术，就可以让你的代码变 得更灵活、可随时替换，以及业务组件间更解耦。</p>
<p>首先我们先科普一下IoC和AOP的基础知识：</p>
<ul>
<li>IoC，其实就是一种设计思想。使用 Spring 来实现 IoC，意味着将你设计好的对象交给 Spring 容器控制，而不是直接在对象内部控制。那，为什么要让容器来管理对象呢?或许 你能想到的是，使用 IoC 方便、可以实现解耦。但在我看来，相比于这两个原因，更重要 的是 IoC 带来了更多的可能性。<ul>
<li>如果以容器为依托来管理所有的框架、业务对象，我们不仅可以无侵入地调整对象的关系， 还可以无侵入地随时调整对象的属性，甚至是实现对象的替换。这就使得框架开发者在程序 背后实现一些扩展不再是问题，带来的可能性是无限的。比如我们要监控的对象如果是 Bean，实现就会非常简单。所以，这套容器体系，不仅被 Spring Core 和 Spring Boot 大 量依赖，还实现了一些外部框架和 Spring 的无缝整合。</li>
</ul>
</li>
<li>AOP，体现了松耦合、高内聚的精髓，在切面集中实现横切关注点(缓存、权限、日志 等)，然后通过切点配置把代码注入合适的地方。切面、切点、增强、连接点，是 AOP 中 非常重要的概念，也是我们会大量提及的。<ul>
<li>切面（Aspect）=切点（Pointcut）+增强（通知Advice）。Spring AOP 中默认使用 AspectJ 查询表达式，通过在连接点运行 查询表达式来匹配切入点。</li>
</ul>
</li>
</ul>
<h2 id="单例的Bean如何注入Prototype的Bean？"><a href="#单例的Bean如何注入Prototype的Bean？" class="headerlink" title="单例的Bean如何注入Prototype的Bean？"></a>单例的Bean如何注入Prototype的Bean？</h2><p>我们虽然知道 Spring 创建的 Bean 默认是单例的，但当 Bean 遇到继承的时候，可能会忽 略这一点。为什么呢?忽略这一点又会造成什么影响呢?接下来，我就和你分享一个由单例 引起内存泄露的案例。</p>
<p>栗子源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SayService 抽象类，有状态的[prototype]。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SayService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其中维护了一个类型是 ArrayList 的字 段 data，用于保存方法处理的中间数据。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 每次调用 say 方法都会往 data 加入新数据，可 以认为 SayService 是有状态。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果 SayService 是单例的话必然会 OOM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add(IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">                .mapToObj(__ -&gt; <span class="string">"a"</span>)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">""</span>)) + UUID.randomUUID().toString());</span><br><span class="line">        log.info(<span class="string">"I'm &#123;&#125; size:&#123;&#125;"</span>, <span class="keyword">this</span>, data.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正确姿势：单例bean注入有状态的bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> <span class="keyword">extends</span> <span class="title">SayService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">        log.info(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayBye</span> <span class="keyword">extends</span> <span class="title">SayService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">        log.info(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟单例的bean注入有状态的bean</span></span><br><span class="line"><span class="comment"> * Bean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"beansingletonandorder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanSingletonAndOrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在为类标记上 <span class="doctag">@Service</span> 注解把类型交由容器管理前，首先评估一下类是 否有状态，然后为 Bean 设置合适的 Scope。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;SayService&gt; sayServiceList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===================="</span>);</span><br><span class="line">        sayServiceList.forEach(SayService::say);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//当然，如果不希望走代理的话还有一种方式是，每次直接从 ApplicationContext 中获取 Bean.</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===================="</span>);</span><br><span class="line">        applicationContext.getBeansOfType(SayService.class).values().forEach(SayService::say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在为类标记上 @Service 注解把类型交由容器管理前，首先评估一下类是 否有状态，然后为 Bean 设置合适的 Scope</strong></li>
<li><strong>Bean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。</strong></li>
<li>修复方式是，让 Service 以代理方式注入。这样虽然 Controller 本身是单例的，但每次都 能从代理获取 Service。这样一来，prototype 范围的配置才能真正生效。</li>
<li>todo：如何实现先执行SayHello，在执行SayBye方法</li>
</ul>
<h2 id="监控切面因为顺序问题导致-Spring-事务失效"><a href="#监控切面因为顺序问题导致-Spring-事务失效" class="headerlink" title="监控切面因为顺序问题导致 Spring 事务失效"></a><strong>监控切面因为顺序问题导致</strong> <strong>Spring</strong> <strong>事务失效</strong></h2><p>实现横切关注点，是 AOP 非常常见的一个应用。我曾看到过一个不错的 AOP 实践，通过 AOP 实现了一个整合日志记录、异常处理和方法耗时打点为一体的统一切面。但后来发 现，使用了 AOP 切面后，这个应用的声明式事务处理居然都是无效的。</p>
<p>现在我们来看下这个案例，分析下 AOP 实现的监控组件和事务失效有什么关系，以及通过 AOP 实现监控组件是否还有其他坑。</p>
<p>栗子源码：生产级别的Aop级别日志、方法耗时、入参、返回值，异常处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Metrics注解定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> noah</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Metrics &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否在成功执行方法后打点，记录方法的执行时间发送到指标系统，默认开启</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recordSuccessMetrics</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否在执行方法出错时打点，记录方法的执行时间发送到指标系统，默认开启</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recordFailMetrics</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否记录请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">logParameters</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否记录返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">logReturn</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否记录异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">logException</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否屏蔽异常返回默认值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreException</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现一个返回Java基本类型默认值的工具。其实，你也可以逐一写很多if-else判断类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; DEFAULT_VALUES = Stream</span><br><span class="line">            .of(<span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>, <span class="title">byte</span>.<span class="title">class</span>, <span class="title">char</span>.<span class="title">class</span>, <span class="title">double</span>.<span class="title">class</span>, <span class="title">float</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">long</span>.<span class="title">class</span>, <span class="title">short</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">collect</span>(<span class="title">toMap</span>(<span class="title">clazz</span> -&gt; (<span class="title">Class</span>&lt;?&gt;) <span class="title">clazz</span>, <span class="title">clazz</span> -&gt; <span class="title">Array</span>.<span class="title">get</span>(<span class="title">Array</span>.<span class="title">newInstance</span>(<span class="title">clazz</span>, 1), 0)))</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 让Spring帮我们注入ObjectMapper，以方便通过JSON序列化来记录方法入参和出参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getDefaultValue</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) DEFAULT_VALUES.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@annotation</span>指示器实现对标记了Metrics注解的方法进行匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(@org.geekbang.time.commonmistakes.springpart1.aopmetrics.Metrics *)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withMetricsAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * within指示器实现了匹配那些类型上标记了<span class="doctag">@RestController</span>注解的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.web.bind.annotation.RestController *)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"controllerBean() || withMetricsAnnotation())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">metrics</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//尝试获取当前方法的类名和方法名</span></span><br><span class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</span><br><span class="line">        String name = String.format(<span class="string">"【%s】【%s】"</span>, signature.getDeclaringType().toString(), signature.toLongString());</span><br><span class="line"></span><br><span class="line">        Metrics metrics = signature.getMethod().getAnnotation(Metrics<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//我们要知道切入的连接点是方法，注解定义在类上是无法直接从方法上获取到注解的。</span></span><br><span class="line">            metrics = signature.getMethod().getDeclaringClass().getAnnotation(Metrics<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于Controller和Repository，我们需要初始化一个@Metrics注解出来</span></span><br><span class="line">        <span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@Metrics</span></span><br><span class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;</span><br><span class="line">            metrics = c<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Metrics</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于Web项目我们可以从上下文中获取到额外的一些信息来丰富我们的日志</span></span><br><span class="line">        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line">            <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">                name += String.format(<span class="string">"【%s】"</span>, request.getRequestURL().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现的是入参的日志输出</span></span><br><span class="line">        <span class="keyword">if</span> (metrics.logParameters()) &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"【入参日志】调用 %s 的参数是：【%s】"</span>, name, objectMapper.writeValueAsString(pjp.getArgs())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现连接点方法的执行，以及成功失败的打点，出现异常的时候还会记录日志</span></span><br><span class="line">        <span class="comment">//这里我们通过日志方式暂时替代了打点的实现，标准的实现是需要把信息对接打点服务，比如Micrometer</span></span><br><span class="line">        Object returnValue;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnValue = pjp.proceed();</span><br><span class="line">            <span class="keyword">if</span> (metrics.recordSuccessMetrics())</span><br><span class="line">                log.info(String.format(<span class="string">"【成功打点】调用 %s 成功，耗时：%d ms"</span>, name, Duration.between(start, Instant.now()).toMillis()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (metrics.recordFailMetrics())</span><br><span class="line">                log.info(String.format(<span class="string">"【失败打点】调用 %s 失败，耗时：%d ms"</span>, name, Duration.between(start, Instant.now()).toMillis()));</span><br><span class="line">            <span class="keyword">if</span> (metrics.logException())</span><br><span class="line">                log.error(String.format(<span class="string">"【异常日志】调用 %s 出现异常！"</span>, name), ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果忽略异常那么直接返回默认值</span></span><br><span class="line">            <span class="keyword">if</span> (metrics.ignoreException())</span><br><span class="line">                returnValue = getDefaultValue(signature.getReturnType());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现了返回值的日志输出</span></span><br><span class="line">        <span class="keyword">if</span> (metrics.logReturn())</span><br><span class="line">            log.info(String.format(<span class="string">"【出参日志】调用 %s 的返回是：【%s】"</span>, name, returnValue));</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试异常是否能够回滚</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Metrics</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(UserEntity entity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        userRepository.save(entity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entity.getName().contains(<span class="string">"test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"invalid username!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一段时间后，开发同学觉得默认的 @Metrics 配置有点不合适，希望进行两个调整:</p>
<ul>
<li>对于 Controller 的自动打点，不要自动记录入参和出参日志，否则日志量太大;<ul>
<li>MetricsController 手动加上了 @Metrics 注解，设置 logParameters 和 logReturn 为 false（无效）</li>
<li>解决方式，<strong>我们要知道切入的连接点是方法，注解定义在类上是无法直接从方法上获取到注解 的</strong>。修复方式是，改为优先从方法获取，如果获取不到再从类获取，如果还是获取不到再使 用默认的注解。</li>
</ul>
</li>
<li>对于 Service 中的方法，最好可以自动捕获异常。<ul>
<li>然后为 Service 中的 createUser 方法的 @Metrics 注解，设置了 ignoreException 属性为 true（导致异常回滚失效）</li>
<li>解决方式是，明确 MetricsAspect 的优先级，可以设置为最高优先级，也就是最先执行入 操作最后执行出操作。</li>
</ul>
</li>
</ul>
<p>我们分析了 Spring 通过 TransactionAspectSupport 类实现事 务。在 invokeWithinTransaction 方法中设置断点可以发现，在执行 Service 的 createUser 方法时，TransactionAspectSupport 并没有捕获到异常，所以自然无法回滚 事务。原因就是，<strong>异常被 MetricsAspect 吃掉了</strong>。</p>
<p>我们知道，切面本身是一个 Bean，Spring 对不同切面增强的执行顺序是由 Bean 优先级 决定的，具体规则是:</p>
<ul>
<li>入操作(Around(连接点执行前)、Before)，切面优先级越高，越先执行。一个切面 的入操作执行完，才轮到下一切面，所有切面入操作执行完，才开始执行连接点(方 法)。</li>
<li>出操作(Around(连接点执行后)、After、AfterReturning、AfterThrowing)，切 面优先级越低，越先执行。一个切面的出操作执行完，才轮到下一切面，直到返回到调 用点。</li>
<li>同一切面的 Around 比 After、Before 先执行。</li>
</ul>
<p>对于 Bean 可以通过 @Order 注解来设置优先级，查看 @Order 注解和 Ordered 接口源 码可以发现，默认情况下 Bean 的优先级为最低优先级，其值是 Integer 的最大值。其实， <strong>值越大优先级反而越低，这点比较反直觉</strong>:</p>
<p><img alt="image-20200609074710598" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gflp83h2phj30h90eqdhc.jpg" class="lazyload"></p>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><ol>
<li>第一，让 Spring 容器管理对象，要考虑对象默认的 Scope 单例是否适合，对于有状态的 类型，单例可能产生内存泄露问题。</li>
<li>第二，如果要为单例的 Bean 注入 Prototype 的 Bean，绝不是仅仅修改 Scope 属性这么 简单。由于单例的 Bean 在容器启动时就会完成一次性初始化。最简单的解决方案是，把 Prototype 的 Bean 设置为通过代理注入，也就是设置 proxyMode 属性为 TARGET_CLASS。</li>
<li>第三，如果一组相同类型的 Bean 是有顺序的，需要明确使用 @Order 注解来设置顺序。 你可以再回顾下，两个不同优先级切面中 @Before、@After 和 @Around 三种增强的执 行顺序，是什么样的。</li>
<li>最后我要说的是，文内第二个案例是一个完整的统一日志监控案例，继续修改就可以实现一 个完善的、生产级的方法调用监控平台。这些修改主要是两方面:把日志打点，改为对接 Metrics 监控系统;把各种功能的监控开关，从注解属性获取改为通过配置系统实时获取。</li>
</ol>
<h1 id="Spring框架-框架帮我们做了很多工作也带来了复杂度"><a href="#Spring框架-框架帮我们做了很多工作也带来了复杂度" class="headerlink" title="Spring框架:框架帮我们做了很多工作也带来了复杂度"></a><strong>Spring</strong>框架:框架帮我们做了很多工作也带来了复杂度</h1><p>Spring 框架内部的复杂度主要表现为三点：</p>
<ol>
<li>第一，Spring 框架借助 IoC 和 AOP 的功能，实现了修改、拦截 Bean 的定义和实例的 灵活性，因此真正执行的代码流程并不是串行的。</li>
<li>第二，Spring Boot 根据当前依赖情况实现了自动配置，虽然省去了手动配置的麻烦， 但也因此多了一些黑盒、提升了复杂度。</li>
<li>第三，Spring Cloud 模块多版本也多，Spring Boot 1.x 和 2.x 的区别也很大。如果要 对 Spring Cloud 或 Spring Boot 进行二次开发的话，考虑兼容性的成本会很高。</li>
</ol>
<h2 id="Feign-AOP-切不到的诡异案例"><a href="#Feign-AOP-切不到的诡异案例" class="headerlink" title="Feign AOP 切不到的诡异案例"></a>Feign AOP 切不到的诡异案例</h2><ul>
<li>曾遇到过这么一个案例:使用 Spring Cloud 做微服务调用，为方便统一处理 Feign，想到了用 AOP 实现，即使用 within 指示器匹配 feign.Client 接口的实现进行 AOP 切入。</li>
<li>栗子源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"feignaop"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignAopConntroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientWithUrl clientWithUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用feign请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"client"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.api();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟feign调用第二版</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"clientWithUrl"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clientWithUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientWithUrl.api();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * feign调用提供方</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"server"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正确切面定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行日志：within(feign.Client+) pjp execution(Response org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(Request,Options)), args:[GET http://client/feignaop/server HTTP/1.1</span></span><br><span class="line"><span class="comment">     * 切入点是：org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(Request,Options))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"within(feign.Client+)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"within(feign.Client+) pjp &#123;&#125;, args:&#123;&#125;"</span>, pjp, pjp.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过nginx负载均衡，替换ribbon负载均衡，AOP切面失效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"anotherClient"</span>, url = <span class="string">"http://localhost:45678"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClientWithUrl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/feignaop/server"</span>)</span><br><span class="line">    <span class="function">String <span class="title">api</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始项目使用Ribbon来负载均衡，代码没什么问题，后来因为后端服务通过 Nginx 实现服务端负载均衡，所以开发同学把 @FeignClient 的配置设置了 URL 属性，直接通过一个固定 URL 调用后端服务。</li>
</ul>
<ul>
<li><p>问题：导致原先定义的切面失效</p>
</li>
<li><p>源码分析Feign创建过程：org.springframework.cloud.openfeign.FeignClientFactoryBean</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//FactoryBean就是创建bean的工程，直接看getObject()方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getTarget();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment">	 * information</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		FeignContext context = <span class="keyword">this</span>.applicationContext.getBean(FeignContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Feign.Builder builder = feign(context);</span><br><span class="line">		<span class="comment">//当 URL 没有内容也就是为空或者不配置时调用 loadBalance 方法，在其内部通过 FeignContext 从容 器获取 feign.Client 的实例</span></span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">				<span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.url = <span class="keyword">this</span>.name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.url += cleanPath();</span><br><span class="line">			<span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line">					<span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, <span class="keyword">this</span>.url));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">		&#125;</span><br><span class="line">		String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">		Client client = getOptional(context, Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">				<span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">				<span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">				client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">			&#125;</span><br><span class="line">			builder.client(client);</span><br><span class="line">		&#125;</span><br><span class="line">		Targeter targeter = get(context, Targeter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context,</span><br><span class="line">				<span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LoadBalancerFeignClient bean对象，里面的httpClient是new出来的</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ApacheHttpClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">value</span> </span>= <span class="string">"feign.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(Client<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Client</span> <span class="title">feignClient</span>(<span class="title">CachingSpringLoadBalancerFactory</span> <span class="title">cachingFactory</span>,</span></span><br><span class="line"><span class="class">			<span class="title">SpringClientFactory</span> <span class="title">clientFactory</span>, <span class="title">HttpClient</span> <span class="title">httpClient</span>) </span>&#123;</span><br><span class="line">		ApacheHttpClient delegate = <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerFeignClient</span><span class="params">(Client delegate,</span></span></span><br><span class="line"><span class="function"><span class="params">			CachingSpringLoadBalancerFactory lbClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">			SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">		<span class="keyword">this</span>.lbClientFactory = lbClientFactory;</span><br><span class="line">		<span class="keyword">this</span>.clientFactory = clientFactory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 URL 没有内容也就是为空或者不配置时调用 loadBalance 方法，在其内部通过 FeignContext 从容 器获取 feign.Client 的实例。是spring容器管理的bean。</li>
<li>FactoryBean就是创建bean的工程，直接看getObject()方法</li>
<li>当 URL 不为空的时候，client 设置为了 LoadBalanceFeignClient 的 delegate 属性。其原因注释中有提到，因为有了 URL 就不需 要客户端负载均衡了，但因为 Ribbon 在 classpath 中，所以需要从 LoadBalanceFeignClient 提取出真正的 Client。断点调试下可以看到，这时 client 是一个 ApacheHttpClient。</li>
<li>表达式声明的是切入 feign.Client 的实现类（Spring 只能切入由自己管理的 Bean）</li>
<li><strong>虽然 LoadBalancerFeignClient 和 ApacheHttpClient 都是 feign.Client 接口的实 现，但是 HttpClientFeignLoadBalancedConfiguration 的自动配置只是把前者定义 为 Bean，后者是 new 出来的、作为了 LoadBalancerFeignClient 的 delegate，不 是 Bean</strong>。</li>
<li>在定义了 FeignClient 的 URL 属性后，我们获取的是 LoadBalancerFeignClient 的 delegate，它不是 Bean。</li>
</ul>
<p>改进方案1：更换为切面表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面：表达式，切带有<span class="doctag">@FeignClietn</span>注解的bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrong2Aspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@within</span>(org.springframework.cloud.openfeign.FeignClient) pjp execution(String org.geekbang.time.commonmistakes.springpart2.aopfeign.feign.ClientWithUrl.api()), args:[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@within(org.springframework.cloud.openfeign.FeignClient)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"@within(org.springframework.cloud.openfeign.FeignClient) pjp &#123;&#125;, args:&#123;&#125;"</span>, pjp, pjp.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>这次切入的是 ClientWithUrl 接口的 API 方法，并不是 client.Feign 接口的 execute 方法，显然不符合预期</strong>。</p>
<ul>
<li>没有弄清楚真正希望切的是什么对象。@FeignClient 注解标记在 Feign Client 接口上，所以切的是 Feign 定义的接口，也就是每一个实际的 API 接口。而 通过 feign.Client 接口切的是客户端实现类，切到的是通用的、执行所有 Feign 调用的 execute 方法。</li>
</ul>
</li>
<li><p>那么问题来了，ApacheHttpClient 不是 Bean 无法切入，切 Feign 接口本身又不符合要 求。怎么办呢?</p>
<ol>
<li><p>经过一番研究发现，ApacheHttpClient 其实有机会独立成为 Bean。查看 HttpClientFeignConfiguration 的源码可以发现，当没有 ILoadBalancer 类型的时候，自 动装配会把 ApacheHttpClient 设置为 Bean。</p>
</li>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(ApacheHttpClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	@ConditionalOnMissingClass("com.netflix.loadbalancer.ILoadBalancer")</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(CloseableHttpClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ConditionalOnProperty</span>(<span class="title">value</span> </span>= <span class="string">"feign.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignConfiguration</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span>(Client<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">		<span class="title">public</span> <span class="title">Client</span> <span class="title">feignClient</span>(<span class="title">HttpClient</span> <span class="title">httpClient</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除ribbon的pom依赖之后，<code>Could not generate CGLIB subclass of class feign.httpclient.ApacheHttpClient: Common causes of this problem include using a final class or a non-visible class; nested exception is java.lang.IllegalArgumentException: Cannot subclass final class feign.httpclient.ApacheHttpClient</code></p>
</li>
<li><p>spring实现动态代理的两种方式</p>
<ul>
<li>JDK 动态代理，通过反射实现，只支持对实现接口的类进行代理;</li>
<li>CGLIB 动态字节码注入方式，通过继承实现代理，没有这个限制。</li>
<li><strong>Spring Boot 2.x 默认使用 CGLIB 的方式，但通过继承实现代理有个问题是，无法继承 final 的类。因为，ApacheHttpClient 类就是定义为了 final</strong>。</li>
<li>解决方案：<code>spring.aop.proxy-target-class=false</code>,优先使用jdk代理，再使用CGLIB</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Spring程序配置的优先级问题"><a href="#Spring程序配置的优先级问题" class="headerlink" title="Spring程序配置的优先级问题"></a>Spring程序配置的优先级问题</h2><ul>
<li><p>我们来通过一个实际案例，研究下配置源以及配置源的优先级问题。</p>
</li>
<li><p>要想查询 Spring 中所有的配置，我们需要以环境 Environment 接口为入口。接下来，我 就与你说说 Spring 通过环境 Environment 抽象出的 Property 和 Profile</p>
<ol>
<li>针对 Property，又抽象出各种 PropertySource 类代表配置源。一个环境下可能有多个 配置源，每个配置源中有诸多配置项。在查询配置信息时，需要按照配置源优先级进行 查询</li>
<li>Profile 定义了场景的概念。通常，我们会定义类似 dev、test、stage 和 prod 等环境 作为不同的 Profile，用于按照场景对 Bean 进行逻辑归属。同时，Profile 和配置文件也 有关系，每个环境都有独立的配置文件，但我们只会激活某一个环境来生效特定环境的 配置文件</li>
</ol>
</li>
<li><p>图解说明Spring配置<img alt="spring配置" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8batayffj30ox0lkac1.jpg" class="lazyload"></p>
</li>
<li><p>源码分析spring配置优先级：<img alt="image-20200628212515298" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gg8bn4d1xoj31350r278i.jpg" class="lazyload"></p>
</li>
<li><p>配置文件优先级和顺序：</p>
<ol>
<li>ConfigurationPropertySourcesPropertySource {name=’configurationProperties’}</li>
<li>StubPropertySource {name=’servletConfigInitParams’}</li>
<li>ServletContextPropertySource {name=’servletContextInitParams’}</li>
<li>PropertiesPropertySource {name=’systemProperties’}（JVM系统配置）</li>
<li>OriginAwareSystemEnvironmentPropertySource {name=’systemEnvironment’}（环境变量配置）</li>
<li>RandomValuePropertySource {name=’random’}</li>
<li>OriginTrackedMapPropertySource {name=’applicationConfig: [classpath:/application.properties]’}（配置文件配置）</li>
<li>MapPropertySource {name=’springCloudClientHostInfo’}</li>
<li>MapPropertySource {name=’defaultProperties’}</li>
</ol>
</li>
<li><p>源码分析为什么<code>PropertySourcesPropertyResolver</code>的优先级最高？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 紫色框：StandardEnvironment，继承的是 AbstractEnvironment</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> <span class="keyword">implements</span> <span class="title">ConfigurableEnvironment</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *MutablePropertySources 类型的字段 propertySources，看起来代表了所有配置源; getProperty 方法，通过 		   *PropertySourcesPropertyResolver 类进行查询配置;</span></span><br><span class="line"><span class="comment">  *实例化 PropertySourcesPropertyResolver 的时候，传入了当前的 MutablePropertySources。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">			<span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.getProperty(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*蓝色框：MutablePropertySources 和 PropertySourcesPropertyResolver</span></span><br><span class="line"><span class="comment">*propertySourceList 字段用来真正保存 PropertySource 的 List，且这个 List 是一个 CopyOnWriteArrayList。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*类中定义了 addFirst、addLast、addBefore、addAfter 等方法，来精确控制 PropertySource 加入*propertySourceList 的顺序。这也说明了顺序的重要性。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertySources</span> <span class="keyword">implements</span> <span class="title">PropertySources</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add the given property source object with highest precedence.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">		removeIfPresent(propertySource);</span><br><span class="line">		<span class="keyword">this</span>.propertySourceList.add(<span class="number">0</span>, propertySource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add the given property source object with lowest precedence.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">		removeIfPresent(propertySource);</span><br><span class="line">		<span class="keyword">this</span>.propertySourceList.add(propertySource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add the given property source object with precedence immediately higher</span></span><br><span class="line"><span class="comment">	 * than the named relative property source.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">		assertLegalRelativeAddition(relativePropertySourceName, propertySource);</span><br><span class="line">		removeIfPresent(propertySource);</span><br><span class="line">		<span class="keyword">int</span> index = assertPresentAndGetIndex(relativePropertySourceName);</span><br><span class="line">		addAtIndex(index, propertySource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add the given property source object with precedence immediately lower</span></span><br><span class="line"><span class="comment">	 * than the named relative property source.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAfter</span><span class="params">(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">		assertLegalRelativeAddition(relativePropertySourceName, propertySource);</span><br><span class="line">		removeIfPresent(propertySource);</span><br><span class="line">		<span class="keyword">int</span> index = assertPresentAndGetIndex(relativePropertySourceName);</span><br><span class="line">		addAtIndex(index + <span class="number">1</span>, propertySource);</span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 绿色框：</span></span><br><span class="line"><span class="comment">* 遍历的 propertySources 是 PropertySourcesPropertyResolver 构造方法传入的，再结合 AbstractEnvironment ** 的源 码可以发现，这个 propertySources 正是 AbstractEnvironment 中的 MutablePropertySources 对象。遍历** 时，如果发现配置源中有对应的 Key 值，则使用这 个值。因此，MutablePropertySources 中配置源的次序尤为重要。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourcesPropertyResolver</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyResolver</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Searching for key '"</span> + key + <span class="string">"' in PropertySource '"</span> +</span><br><span class="line">							propertySource.getName() + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				Object value = propertySource.getProperty(key);</span><br><span class="line">				<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">						value = resolveNestedPlaceholders((String) value);</span><br><span class="line">					&#125;</span><br><span class="line">					logKeyFound(key, propertySource, value);</span><br><span class="line">					<span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Could not find key '"</span> + key + <span class="string">"' in any property source"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色框：回到之前的问题，在查询所有配置源的时候，我们注意到处在第一位的是**ConfigurationPropertySourcesPropertySource，这是什么呢?</span></span><br><span class="line"><span class="comment">**其实，它不是一个实际存在的配置源，扮演的是一个代理的角色。但通过调试你会发现，我 们获取的值竟然是由它提供并且返**回的，且没有循环遍历后面的 PropertySource。</span></span><br><span class="line"><span class="comment">**getProperty 方法其实是通过 findConfigurationProperty 方法查询配置的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertySourcesPropertySource</span> <span class="keyword">extends</span> <span class="title">PropertySource</span>&lt;<span class="title">Iterable</span>&lt;<span class="title">ConfigurationPropertySource</span>&gt;&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">OriginLookup</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	ConfigurationPropertySourcesPropertySource(String name, Iterable&lt;ConfigurationPropertySource&gt; source) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name, source);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		ConfigurationProperty configurationProperty = findConfigurationProperty(name);</span><br><span class="line">		<span class="keyword">return</span> (configurationProperty != <span class="keyword">null</span>) ? configurationProperty.getValue() : <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Origin <span class="title">getOrigin</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Origin.from(findConfigurationProperty(name));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ConfigurationProperty <span class="title">findConfigurationProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> findConfigurationProperty(ConfigurationPropertyName.of(name, <span class="keyword">true</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ConfigurationProperty <span class="title">findConfigurationProperty</span><span class="params">(ConfigurationPropertyName name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//调试可以发现，这个循环遍历(getSource() 的结果)的配置源，其实是 SpringConfigurationPropertySources(图中黄色类)，其中包含的配置源列表就是之前 看到的 9 个配置源，而第一个就是 ConfigurationPropertySourcesPropertySource。看 到这里，我们的第一感觉是会不会产生死循环，它在遍历的时候怎么排除自己呢?</span></span><br><span class="line">		<span class="keyword">for</span> (ConfigurationPropertySource configurationPropertySource : getSource()) &#123;</span><br><span class="line">			ConfigurationProperty configurationProperty = configurationPropertySource.getConfigurationProperty(name);</span><br><span class="line">			<span class="keyword">if</span> (configurationProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> configurationProperty;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**黄色框：</span></span><br><span class="line"><span class="comment">**看到这里，我们的第一感觉是会不会产生死循环，它在遍历的时候怎么排除自己呢?</span></span><br><span class="line"><span class="comment">**，它返回的迭代器是内部类 SourcesIterator，在 fetchNext 方法获取下一个项时，通过 isIgnored 方法排除了**ConfigurationPropertySourcesPropertySource</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringConfigurationPropertySources</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">ConfigurationPropertySource</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Iterable&lt;PropertySource&lt;?&gt;&gt; sources;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;PropertySource&lt;?&gt;, ConfigurationPropertySource&gt; cache = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(<span class="number">16</span>,</span><br><span class="line">			ReferenceType.SOFT);</span><br><span class="line"></span><br><span class="line">	SpringConfigurationPropertySources(Iterable&lt;PropertySource&lt;?&gt;&gt; sources) &#123;</span><br><span class="line">		Assert.notNull(sources, <span class="string">"Sources must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.sources = sources;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;ConfigurationPropertySource&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SourcesIterator(<span class="keyword">this</span>.sources.iterator(), <span class="keyword">this</span>::adapt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ConfigurationPropertySource <span class="title">adapt</span><span class="params">(PropertySource&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">		ConfigurationPropertySource result = <span class="keyword">this</span>.cache.get(source);</span><br><span class="line">		<span class="comment">// Most PropertySources test equality only using the source name, so we need to</span></span><br><span class="line">		<span class="comment">// check the actual source hasn't also changed.</span></span><br><span class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result.getUnderlyingSource() == source) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = SpringConfigurationPropertySource.from(source);</span><br><span class="line">		<span class="keyword">this</span>.cache.put(source, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SourcesIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">ConfigurationPropertySource</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Iterator&lt;PropertySource&lt;?&gt;&gt;&gt; iterators;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> ConfigurationPropertySource next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Function&lt;PropertySource&lt;?&gt;, ConfigurationPropertySource&gt; adapter;</span><br><span class="line"></span><br><span class="line">		SourcesIterator(Iterator&lt;PropertySource&lt;?&gt;&gt; iterator,</span><br><span class="line">				Function&lt;PropertySource&lt;?&gt;, ConfigurationPropertySource&gt; adapter) &#123;</span><br><span class="line">			<span class="keyword">this</span>.iterators = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">			<span class="keyword">this</span>.iterators.push(iterator);</span><br><span class="line">			<span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> fetchNext() != <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ConfigurationPropertySource <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ConfigurationPropertySource next = fetchNext();</span><br><span class="line">			<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> ConfigurationPropertySource <span class="title">fetchNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.iterators.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.iterators.peek().hasNext()) &#123;</span><br><span class="line">					<span class="keyword">this</span>.iterators.pop();</span><br><span class="line">					<span class="keyword">return</span> fetchNext();</span><br><span class="line">				&#125;</span><br><span class="line">				PropertySource&lt;?&gt; candidate = <span class="keyword">this</span>.iterators.peek().next();</span><br><span class="line">				<span class="keyword">if</span> (candidate.getSource() <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">					push((ConfigurableEnvironment) candidate.getSource());</span><br><span class="line">					<span class="keyword">return</span> fetchNext();</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">//细节</span></span><br><span class="line">				<span class="keyword">if</span> (isIgnored(candidate)) &#123;</span><br><span class="line">					<span class="keyword">return</span> fetchNext();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.next = <span class="keyword">this</span>.adapter.apply(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.iterators.push(environment.getPropertySources().iterator());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIgnored</span><span class="params">(PropertySource&lt;?&gt; candidate)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (candidate <span class="keyword">instanceof</span> StubPropertySource</span><br><span class="line">					|| candidate <span class="keyword">instanceof</span> ConfigurationPropertySourcesPropertySource);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**最后一个问题是，ConfigurationPropertySourcesPropertySource它如何让自己成为第一个配置源呢?</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertySources</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">		Assert.isInstanceOf(ConfigurableEnvironment<span class="class">.<span class="keyword">class</span>, <span class="title">environment</span>)</span>;</span><br><span class="line">		MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();</span><br><span class="line">		PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">		<span class="keyword">if</span> (attached != <span class="keyword">null</span> &amp;&amp; attached.getSource() != sources) &#123;</span><br><span class="line">			sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">			attached = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (attached == <span class="keyword">null</span>) &#123;</span><br><span class="line">			sources.addFirst(<span class="keyword">new</span> ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,</span><br><span class="line">					<span class="keyword">new</span> SpringConfigurationPropertySources(sources)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">			ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Create and configure the environment</span></span><br><span class="line">		ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">		configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">    <span class="comment">//调用attach方法</span></span><br><span class="line">		ConfigurationPropertySources.attach(environment);</span><br><span class="line">		listeners.environmentPrepared(environment);</span><br><span class="line">		bindToSpringApplication(environment);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">			environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">					deduceEnvironmentClass());</span><br><span class="line">		&#125;</span><br><span class="line">		ConfigurationPropertySources.attach(environment);</span><br><span class="line">		<span class="keyword">return</span> environment;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//SpringApplication#run()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">//调用prepareEnviroment方法</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">					new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="思考和讨论"><a href="#思考和讨论" class="headerlink" title="思考和讨论"></a>思考和讨论</h2><p>Spring 的 Environment 中的 PropertySources 属性可以包含多个 PropertySource， 越往前优先级越高。那，我们能否利用这个特点实现配置文件中属性值的自动赋值呢? 比如，我们可以定义 %%MYSQL.URL%%、%%MYSQL.USERNAME%% 和 %%MYSQL.PASSWORD%%，分别代表数据库连接字符串、用户名和密码。在配置数 据源时，我们只要设置其值为占位符，框架就可以自动根据当前应用程序名 application.name，统一把占位符替换为真实的数据库信息。这样，生产的数据库信息 就不需要放在配置文件中了，会更安全。（换句话：如何实现配置数据库等bootstart的配置不写死，这样也解决了bootstart每次都重启的问题）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**最佳实践：启动配置放在apollo下，而不需要重启配置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMistakesApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_URL_PLACEHOLDER = <span class="string">"%%MYSQL.URL%%"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_USERNAME_PLACEHOLDER = <span class="string">"%%MYSQL.USERNAME%%"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_PASSWORD_PLACEHOLDER = <span class="string">"%%MYSQL.PASSWORD%%"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Utils.loadPropertySource(CommonMistakesApplication.class, "db.properties");</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">                .sources(CommonMistakesApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">initializers</span>(<span class="title">context</span> -&gt; <span class="title">initDbUrl</span>(<span class="title">context</span>.<span class="title">getEnvironment</span>()))</span></span><br><span class="line"><span class="class">                .<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDbUrl</span><span class="params">(ConfigurableEnvironment env)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String dataSourceUrl = env.getProperty(<span class="string">"spring.datasource.url"</span>);</span><br><span class="line">        String username = env.getProperty(<span class="string">"spring.datasource.username"</span>);</span><br><span class="line">        String password = env.getProperty(<span class="string">"spring.datasource.password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSourceUrl != <span class="keyword">null</span> &amp;&amp; !dataSourceUrl.contains(MYSQL_URL_PLACEHOLDER))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"请使用占位符"</span> + MYSQL_URL_PLACEHOLDER + <span class="string">"来替换数据库URL配置！"</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; !username.contains(MYSQL_USERNAME_PLACEHOLDER))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"请使用占位符"</span> + MYSQL_USERNAME_PLACEHOLDER + <span class="string">"来替换数据库账号配置！"</span>);</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !password.contains(MYSQL_PASSWORD_PLACEHOLDER))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"请使用占位符"</span> + MYSQL_PASSWORD_PLACEHOLDER + <span class="string">"来替换数据库密码配置！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里我把值写死了，实际应用中可以从外部服务来获取</span></span><br><span class="line">        Map&lt;String, String&gt; property = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        property.put(MYSQL_URL_PLACEHOLDER, <span class="string">"jdbc:mysql://localhost:6657/common_mistakes?characterEncoding=UTF-8&amp;useSSL=false"</span>);</span><br><span class="line">        property.put(MYSQL_USERNAME_PLACEHOLDER, <span class="string">"root"</span>);</span><br><span class="line">        property.put(MYSQL_PASSWORD_PLACEHOLDER, <span class="string">"kIo9u7Oi0eg"</span>);</span><br><span class="line"></span><br><span class="line">        Properties modifiedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">        StreamSupport.stream(env.getPropertySources().spliterator(), <span class="keyword">false</span>)</span><br><span class="line">                .filter(ps -&gt; ps <span class="keyword">instanceof</span> EnumerablePropertySource)</span><br><span class="line">                .map(ps -&gt; ((EnumerablePropertySource) ps).getPropertyNames())</span><br><span class="line">                .flatMap(Arrays::stream)</span><br><span class="line">                .forEach(propKey -&gt; &#123;</span><br><span class="line">                    String propValue = env.getProperty(propKey);</span><br><span class="line">                    property.entrySet().forEach(item -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (propValue.contains(item.getKey())) &#123;</span><br><span class="line">                            modifiedProps.put(propKey, propValue.replaceAll(item.getKey(), item.getValue()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!modifiedProps.isEmpty()) &#123;</span><br><span class="line">            log.info(<span class="string">"modifiedProps: &#123;&#125;"</span>, modifiedProps);</span><br><span class="line">            env.getPropertySources().addFirst(<span class="keyword">new</span> PropertiesPropertySource(<span class="string">"mysql"</span>, modifiedProps));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">checkDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"result &#123;&#125;"</span>, jdbcTemplate.queryForObject(<span class="string">"SELECT NOW()"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/">http://yoursite.com/2020/04/12/2020-04-12-Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Noah%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/">Noah最佳实践与踩坑    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwrhsmsvj312o0ljab7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/27/2020-06-27-Spring%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwzhusdfj318n0p0myx.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>SpringFramework5.2.0源码阅读</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx22jv93j318k0p03zl.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>剑指Offer（完整版）</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/29/2020-06-29-Noah最佳实践与踩坑（续）/" title="Noah最佳实践与踩坑（续）"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzwrhsmsvj312o0ljab7.jpg"><div class="relatedPosts_title">Noah最佳实践与踩坑（续）</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>