<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>剑指JavaOffer | Noah</title><meta name="description" content="阅读《剑指JavaOffer》笔记"><meta name="keywords" content="offer"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="剑指JavaOffer"><meta name="twitter:description" content="阅读《剑指JavaOffer》笔记"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><meta property="og:type" content="article"><meta property="og:title" content="剑指JavaOffer"><meta property="og:url" content="http://yoursite.com/2018/12/17/2018-12-17-%E5%89%91%E6%8C%87JavaOffer/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="阅读《剑指JavaOffer》笔记"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2018/12/17/2018-12-17-%E5%89%91%E6%8C%87JavaOffer/"><link rel="prev" title="SpringAop实战" href="http://yoursite.com/2018/12/20/2018-12-20-SpringAop%E5%AE%9E%E6%88%98/"><link rel="next" title="2018-03-26-Linux命令大全" href="http://yoursite.com/2018/11/17/2018-03-26-Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#剑指Java-Offer"><span class="toc_mobile_items-text">剑指Java Offer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#网络知识"><span class="toc_mobile_items-text">网络知识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#图解：应用层"><span class="toc_mobile_items-text">图解：应用层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#图解：传输层、会话层、表示层"><span class="toc_mobile_items-text">图解：传输层、会话层、表示层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#图解：物理层、数据链路层、网络层"><span class="toc_mobile_items-text">图解：物理层、数据链路层、网络层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#OSI开放7层模型"><span class="toc_mobile_items-text">OSI开放7层模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#OSI的”实现”：TCP-IP协议族"><span class="toc_mobile_items-text">OSI的”实现”：TCP/IP协议族</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP-IP协议族模型"><span class="toc_mobile_items-text">TCP/IP协议族模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP的三次握手"><span class="toc_mobile_items-text">TCP的三次握手</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#TCP报文和理解套接字"><span class="toc_mobile_items-text">TCP报文和理解套接字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#图解TCP三次握手"><span class="toc_mobile_items-text">图解TCP三次握手</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP的四次挥手"><span class="toc_mobile_items-text">TCP的四次挥手</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#图解TCP的四次挥手"><span class="toc_mobile_items-text">图解TCP的四次挥手</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#UDP全解"><span class="toc_mobile_items-text">UDP全解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#旧版本资料"><span class="toc_mobile_items-text">旧版本资料</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#集合"><span class="toc_mobile_items-text">集合</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#求集合的交集、并集、差集"><span class="toc_mobile_items-text">求集合的交集、并集、差集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#源代码解析"><span class="toc_mobile_items-text">源代码解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#排序算法"><span class="toc_mobile_items-text">排序算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#复杂度总结"><span class="toc_mobile_items-text">复杂度总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#直接选择排序"><span class="toc_mobile_items-text">直接选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#冒泡排序"><span class="toc_mobile_items-text">冒泡排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#插入排序"><span class="toc_mobile_items-text">插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二分查找（折半）"><span class="toc_mobile_items-text">二分查找（折半）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#快速排序"><span class="toc_mobile_items-text">快速排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#归并排序"><span class="toc_mobile_items-text">归并排序</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#设计模式"><span class="toc_mobile_items-text">设计模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设计模式五大原则（SOLID）"><span class="toc_mobile_items-text">设计模式五大原则（SOLID）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基本数据类型"><span class="toc_mobile_items-text">基本数据类型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#图解大全"><span class="toc_mobile_items-text">图解大全</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Http知识点："><span class="toc_mobile_items-text">Http知识点：</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#request中getParameter和getAttribute的区别"><span class="toc_mobile_items-text">request中getParameter和getAttribute的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#get和post区别"><span class="toc_mobile_items-text">get和post区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#事务"><span class="toc_mobile_items-text">事务</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#事务特性"><span class="toc_mobile_items-text">事务特性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程"><span class="toc_mobile_items-text">线程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#wait和sleep的区别"><span class="toc_mobile_items-text">wait和sleep的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#线程状态"><span class="toc_mobile_items-text">线程状态</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程同步"><span class="toc_mobile_items-text">线程同步</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#非线程安全异步导致的问题"><span class="toc_mobile_items-text">非线程安全异步导致的问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#线程异步导致结果"><span class="toc_mobile_items-text">线程异步导致结果</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为何要线程同步？"><span class="toc_mobile_items-text">为何要线程同步？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式一：使用synchronized同步方法"><span class="toc_mobile_items-text">同步方式一：使用synchronized同步方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式二：使用synchronized同步代码块"><span class="toc_mobile_items-text">同步方式二：使用synchronized同步代码块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式三：使用volatile关键字"><span class="toc_mobile_items-text">同步方式三：使用volatile关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式四：使用ReentrantLock重入锁关键字"><span class="toc_mobile_items-text">同步方式四：使用ReentrantLock重入锁关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式五：使用ThreadLocal局部变量实现线程同步"><span class="toc_mobile_items-text">同步方式五：使用ThreadLocal局部变量实现线程同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式六：使用阻塞队列实现线程同步"><span class="toc_mobile_items-text">同步方式六：使用阻塞队列实现线程同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#同步方式七：使用原子变量实现线程同步"><span class="toc_mobile_items-text">同步方式七：使用原子变量实现线程同步</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP-IP协议族分层"><span class="toc_mobile_items-text">TCP/IP协议族分层</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#什么是tcp-ip协议族？"><span class="toc_mobile_items-text">什么是tcp/ip协议族？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#tcp-ip分层管理"><span class="toc_mobile_items-text">tcp/ip分层管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#传输层：TCP三次握手"><span class="toc_mobile_items-text">传输层：TCP三次握手</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#各种协议与HTTP协议的关系"><span class="toc_mobile_items-text">各种协议与HTTP协议的关系</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java随笔"><span class="toc_mobile_items-text">Java随笔</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#异常"><span class="toc_mobile_items-text">异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#泛型"><span class="toc_mobile_items-text">泛型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#如何理解回调函数"><span class="toc_mobile_items-text">如何理解回调函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#如何理解java语法糖？"><span class="toc_mobile_items-text">如何理解java语法糖？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#如何使用Guava-Cache和redis比较"><span class="toc_mobile_items-text">如何使用Guava Cache和redis比较</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#JetCache神器用法"><span class="toc_mobile_items-text">JetCache神器用法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#java线程池的理解"><span class="toc_mobile_items-text">java线程池的理解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#springBoot异步执行代码-amp-amp-springBoot单例线程池"><span class="toc_mobile_items-text">springBoot异步执行代码&amp;&amp;springBoot单例线程池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Map中的JAVA8流式处理"><span class="toc_mobile_items-text">Map中的JAVA8流式处理</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#剑指Java-Offer"><span class="toc-text">剑指Java Offer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网络知识"><span class="toc-text">网络知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图解：应用层"><span class="toc-text">图解：应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解：传输层、会话层、表示层"><span class="toc-text">图解：传输层、会话层、表示层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解：物理层、数据链路层、网络层"><span class="toc-text">图解：物理层、数据链路层、网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI开放7层模型"><span class="toc-text">OSI开放7层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI的”实现”：TCP-IP协议族"><span class="toc-text">OSI的”实现”：TCP/IP协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP协议族模型"><span class="toc-text">TCP/IP协议族模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的三次握手"><span class="toc-text">TCP的三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP报文和理解套接字"><span class="toc-text">TCP报文和理解套接字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图解TCP三次握手"><span class="toc-text">图解TCP三次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的四次挥手"><span class="toc-text">TCP的四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图解TCP的四次挥手"><span class="toc-text">图解TCP的四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP全解"><span class="toc-text">UDP全解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#旧版本资料"><span class="toc-text">旧版本资料</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求集合的交集、并集、差集"><span class="toc-text">求集合的交集、并集、差集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源代码解析"><span class="toc-text">源代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序算法"><span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度总结"><span class="toc-text">复杂度总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接选择排序"><span class="toc-text">直接选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二分查找（折半）"><span class="toc-text">二分查找（折半）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设计模式五大原则（SOLID）"><span class="toc-text">设计模式五大原则（SOLID）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型"><span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图解大全"><span class="toc-text">图解大全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http知识点："><span class="toc-text">Http知识点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request中getParameter和getAttribute的区别"><span class="toc-text">request中getParameter和getAttribute的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get和post区别"><span class="toc-text">get和post区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事务特性"><span class="toc-text">事务特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait和sleep的区别"><span class="toc-text">wait和sleep的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程状态"><span class="toc-text">线程状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非线程安全异步导致的问题"><span class="toc-text">非线程安全异步导致的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程异步导致结果"><span class="toc-text">线程异步导致结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为何要线程同步？"><span class="toc-text">为何要线程同步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式一：使用synchronized同步方法"><span class="toc-text">同步方式一：使用synchronized同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式二：使用synchronized同步代码块"><span class="toc-text">同步方式二：使用synchronized同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式三：使用volatile关键字"><span class="toc-text">同步方式三：使用volatile关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式四：使用ReentrantLock重入锁关键字"><span class="toc-text">同步方式四：使用ReentrantLock重入锁关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式五：使用ThreadLocal局部变量实现线程同步"><span class="toc-text">同步方式五：使用ThreadLocal局部变量实现线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式六：使用阻塞队列实现线程同步"><span class="toc-text">同步方式六：使用阻塞队列实现线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式七：使用原子变量实现线程同步"><span class="toc-text">同步方式七：使用原子变量实现线程同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP协议族分层"><span class="toc-text">TCP/IP协议族分层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是tcp-ip协议族？"><span class="toc-text">什么是tcp/ip协议族？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-ip分层管理"><span class="toc-text">tcp/ip分层管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传输层：TCP三次握手"><span class="toc-text">传输层：TCP三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#各种协议与HTTP协议的关系"><span class="toc-text">各种协议与HTTP协议的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java随笔"><span class="toc-text">Java随笔</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何理解回调函数"><span class="toc-text">如何理解回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何理解java语法糖？"><span class="toc-text">如何理解java语法糖？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何使用Guava-Cache和redis比较"><span class="toc-text">如何使用Guava Cache和redis比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JetCache神器用法"><span class="toc-text">JetCache神器用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java线程池的理解"><span class="toc-text">java线程池的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springBoot异步执行代码-amp-amp-springBoot单例线程池"><span class="toc-text">springBoot异步执行代码&amp;&amp;springBoot单例线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map中的JAVA8流式处理"><span class="toc-text">Map中的JAVA8流式处理</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指JavaOffer</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-12-17<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-23</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/offer/">offer</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">6.7k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 26 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="剑指Java-Offer"><a href="#剑指Java-Offer" class="headerlink" title="剑指Java Offer"></a>剑指Java Offer</h1><p>todo：总结概述</p>
<h2 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h2><h3 id="图解：应用层"><a href="#图解：应用层" class="headerlink" title="图解：应用层"></a>图解：应用层</h3><p><img alt="image-20190509203830122" data-src="https://ws2.sinaimg.cn/large/006tNc79ly1g2vcjlbxl0j323g0k0kds.jpg" class="lazyload"></p>
<h3 id="图解：传输层、会话层、表示层"><a href="#图解：传输层、会话层、表示层" class="headerlink" title="图解：传输层、会话层、表示层"></a>图解：传输层、会话层、表示层</h3><p><img alt="image-20190509203536904" data-src="https://ws3.sinaimg.cn/large/006tNc79ly1g2vcfdte4fj31p90u0u0x.jpg" class="lazyload"></p>
<h3 id="图解：物理层、数据链路层、网络层"><a href="#图解：物理层、数据链路层、网络层" class="headerlink" title="图解：物理层、数据链路层、网络层"></a>图解：物理层、数据链路层、网络层<img alt="image-20190509202807696" data-src="https://ws2.sinaimg.cn/large/006tNc79ly1g2vc7idcicj31qi0u04qq.jpg" class="lazyload"></h3><h3 id="OSI开放7层模型"><a href="#OSI开放7层模型" class="headerlink" title="OSI开放7层模型"></a>OSI开放7层模型</h3><p><img alt="image-20190509204233614" data-src="https://ws3.sinaimg.cn/large/006tNc79ly1g2vcmhszr6j31l30u04le.jpg" class="lazyload"></p>
<h3 id="OSI的”实现”：TCP-IP协议族"><a href="#OSI的”实现”：TCP-IP协议族" class="headerlink" title="OSI的”实现”：TCP/IP协议族"></a>OSI的”实现”：TCP/IP协议族</h3><p><img alt="image-20190509204557392" data-src="https://ws3.sinaimg.cn/large/006tNc79ly1g2vcq0bs50j31dc0k60yf.jpg" class="lazyload"></p>
<h3 id="TCP-IP协议族模型"><a href="#TCP-IP协议族模型" class="headerlink" title="TCP/IP协议族模型"></a>TCP/IP协议族模型</h3><p><img alt="image-20190509204828767" data-src="https://ws3.sinaimg.cn/large/006tNc79ly1g2vcsmyhtlj31bt0u07fe.jpg" class="lazyload"></p>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>因为在网络层中ip协议负责寻址操作，并不能保证数据传输的可靠性，因此ip协议是不可靠的协议。需要依赖于上层传输层的tcp协议，对数据进行分段。</p>
<h4 id="TCP报文和理解套接字"><a href="#TCP报文和理解套接字" class="headerlink" title="TCP报文和理解套接字"></a>TCP报文和理解套接字</h4><p><img alt="image-20190509210211751" data-src="https://ws2.sinaimg.cn/large/006tNc79ly1g2vd6x5q5kj31kh0u0du7.jpg" class="lazyload"></p>
<p>什么是套接字：就是网络中传输层的端口号和网络层中的ip地址，唯一不同机器中唯一确定一个进程。<strong>三次握手，所做的一切都是为了初始化Sequence Number的初始值，保证应用层接收到的数据不乱序</strong>。</p>
<h4 id="图解TCP三次握手"><a href="#图解TCP三次握手" class="headerlink" title="图解TCP三次握手"></a>图解TCP三次握手</h4><p><img alt="image-20190515074605125" data-src="https://ws2.sinaimg.cn/large/006tNc79gy1g31nwhom3hj314e0seb29.jpg" class="lazyload"></p>
<p><img alt="image-20190515080636084" data-src="https://ws2.sinaimg.cn/large/006tNc79gy1g31ohraahuj318o0rsat5.jpg" class="lazyload"></p>
<h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>todo：总结的话语</p>
<h4 id="图解TCP的四次挥手"><a href="#图解TCP的四次挥手" class="headerlink" title="图解TCP的四次挥手"></a>图解TCP的四次挥手</h4><p><img alt="image-20190515081705248" data-src="https://ws3.sinaimg.cn/large/006tNc79gy1g31oso823rj30zo0rs7wh.jpg" class="lazyload"></p>
<p><img alt="image-20190515082154534" data-src="https://ws4.sinaimg.cn/large/006tNc79gy1g31oxoxgclj313e0sg1kx.jpg" class="lazyload"></p>
<p><a href="https://blog.tanteng.me/2017/04/netstat-tcp-state/" target="_blank" rel="noopener">关于三次握手和四次挥手的各种问题分析和实践</a></p>
<h3 id="UDP全解"><a href="#UDP全解" class="headerlink" title="UDP全解"></a>UDP全解</h3><p><strong>UDP的报文结构：</strong><img alt="image-20190521201252284" data-src="https://ws1.sinaimg.cn/large/006tNc79ly1g3977codj6j31tk0m443d.jpg" class="lazyload"></p>
<h2 id="旧版本资料"><a href="#旧版本资料" class="headerlink" title="旧版本资料"></a>旧版本资料</h2><p>RPC和Http请求的区别？</p>
<p><a href="https://www.zhihu.com/question/41609070" target="_blank" rel="noopener">知乎：既然有 HTTP 请求，为什么还要用 RPC 调用？</a></p>
<p>java创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OrderForm orderForm = <span class="keyword">null</span>;</span><br><span class="line">OrderForm orderForm;</span><br><span class="line">OrderForm orderForm=<span class="keyword">new</span> OrderForm();</span><br><span class="line"></span><br><span class="line">第一个是<span class="keyword">null</span>对象，空引用。</span><br><span class="line">第二个没有引用（具体区分成员变量、局部变量）。</span><br><span class="line">第三个是OrderForm对象，具体引用到了对象。</span><br><span class="line"></span><br><span class="line">成员变量：默认不写，=<span class="keyword">null</span>。</span><br><span class="line">局部变量：则必须初始化，也就是=<span class="keyword">null</span>或者<span class="keyword">new</span>，因为为了保证java的安全性；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderDetail detail;</span><br><span class="line"><span class="keyword">private</span> OrderMaster orderMaster = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> OrderMaster orderMaster_v2 = <span class="keyword">new</span> OrderMaster(); <span class="comment">//在堆创建对象并且默认初始化成员变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestConsuter testConsuter = <span class="keyword">new</span> TestConsuter();</span><br><span class="line">    <span class="comment">//OrderMaster orderMasterMain; //not initiallized</span></span><br><span class="line">    <span class="comment">//OrderMaster orderMasterMain = null;//java.lang.IllegalArgumentException: Target must not be null</span></span><br><span class="line">    OrderMaster orderMasterMain = <span class="keyword">new</span> OrderMaster(); <span class="comment">//print null</span></span><br><span class="line">    <span class="comment">//testConsuter.detail.getProductQuantity();//NPE</span></span><br><span class="line">    <span class="comment">//testConsuter.orderMaster.getBuyerAddress();//NPE</span></span><br><span class="line">    System.out.println(testConsuter.orderMaster_v2.getBuyerAddress());<span class="comment">//print null</span></span><br><span class="line">    BeanUtils.copyProperties(testConsuter.orderMaster_v2, orderMasterMain);</span><br><span class="line">    System.out.println(orderMasterMain.getBuyerAddress());<span class="comment">//print null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的a++和++a的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> aa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = aa++;</span><br><span class="line">        <span class="keyword">int</span> b = ++bb;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b + <span class="string">",aa="</span> + aa + <span class="string">",bb="</span> + bb);</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">a=<span class="number">0</span>,b=<span class="number">1</span>,aa=<span class="number">1</span>,bb=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="求集合的交集、并集、差集"><a href="#求集合的交集、并集、差集" class="headerlink" title="求集合的交集、并集、差集"></a>求集合的交集、并集、差集</h4><ul>
<li>交集：retainAll(Collection&lt;?&gt; c)</li>
<li>并集：addAll(Collection&lt;?&gt; c)</li>
<li>差集：removeAll(Collection&lt;?&gt; c)</li>
</ul>
<h4 id="源代码解析"><a href="#源代码解析" class="headerlink" title="源代码解析"></a>源代码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   #源码解析：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(c);</span><br><span class="line">       <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">               <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                   elementData[w++] = elementData[r];</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">           <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">           <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">               System.arraycopy(elementData, r,</span><br><span class="line">                                elementData, w,</span><br><span class="line">                                size - r);</span><br><span class="line">               w += size - r;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">               <span class="comment">// clear to let GC do its work</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                   elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">               modCount += size - w;</span><br><span class="line">               size = w;</span><br><span class="line">               modified = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> modified;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a>复杂度总结</h4><p><img alt="image-20181112092135573" data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fx50n4kchoj30i70dt4c6.jpg" class="lazyload"></p>
<h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><p>a) 原理：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有<a href="http://baike.so.com/doc/5992150-6205119.html" target="_blank" rel="noopener">简单选择排序</a>、树型选择排序和<a href="http://baike.so.com/doc/1008529-1066354.html" target="_blank" rel="noopener">堆排序</a>。（这里只介绍常用的简单选择排序）</p>
<p>b) 简单选择排序的基本思想：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]<del>arr[n]中选出最小的数据，将它与arrr[1]交换；第2趟，在待排序数据arr[2]</del>arr[n]中选出最小的数据，将它与r[2]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">33</span>,<span class="number">12</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"交换之前："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            System.out.print(num+<span class="string">" "</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//选择排序的优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">// 做第i趟排序</span></span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k + <span class="number">1</span>; j &lt; arr.length; j++)&#123;<span class="comment">// 选最小的记录</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[k])&#123; </span><br><span class="line">                    k = j; <span class="comment">//记下目前找到的最小值所在的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != k)&#123;  <span class="comment">//交换a[i]和a[k]</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                arr[k] = temp;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            System.out.print(num+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>有2种思路，第一种，score[j] 和 score[j+1] 比较 如果 前者比后者小，把前者和后者调换顺序，两两调换后一轮下来 最小的会被排到最后去。每一轮j都从0开始，当i轮排序，就有最后面的i个数字因为他是最小的，所以后面的每轮都不用理他了，也就是 score.length-1-i  往后的数不用管了，如上，第一轮有4个数字 i为0 ，那么score.length-1-i  为3，也就是下标是3以后的可以不用管，3往后没有数字，所以第一轮所有的数字都要参加比较，第二轮I=1  score.length-1-i  为2 也就是说 下标2后面的 下标为3的数字不用比了，因为两两比较厚，67会到 score[3],实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score[] = &#123;<span class="number">67</span>, <span class="number">69</span>, <span class="number">75</span>, <span class="number">88</span>&#125;; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; score.length - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;  score.length - <span class="number">1</span>-i;j++)<span class="comment">// j开始等于0，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(score[j] &lt; score[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = score[j];</span><br><span class="line">                    score[j] = score[j+<span class="number">1</span>];</span><br><span class="line">                    score[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。</p>
<p>具体算法描述如下：</p>
<p>从第一个元素开始，该元素可以认为已经被排序<br>取出下一个元素，在已经排序的元素序列中从后向前扫描<br>如果该元素（已排序）大于新元素，将该元素移到下一位置<br>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置<br>将新元素插入到该位置后<br>重复步骤 2~5<br>如果比较操作的代价比交换操作大的话，<strong>可以采用二分查找法来减少比较操作的数目</strong>。该算法可以认为是插入排序的一个变种，称为二分查找排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(T[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; a.length; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            T tmp = a[p];<span class="comment">//保存当前位置p的元素，其中[0,p-1]已经有序</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = p; j &gt; <span class="number">0</span> &amp;&amp; tmp.compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];<span class="comment">//后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = tmp;<span class="comment">//插入到合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for test purpose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">34</span>,<span class="number">8</span>,<span class="number">64</span>,<span class="number">51</span>,<span class="number">32</span>,<span class="number">21</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分查找（折半）"><a href="#二分查找（折半）" class="headerlink" title="二分查找（折半）"></a>二分查找（折半）</h4><p><strong>有序的序列</strong>，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归方式</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用递归的二分查找</span></span><br><span class="line"><span class="comment">	 *title:recursionBinarySearch</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> arr 有序数组</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@return</span> 找到的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursionBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;			<span class="comment">//初始中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">			<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">			<span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">			<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">			<span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> middle;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//while循环</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 不使用递归的二分查找</span></span><br><span class="line"><span class="comment">	 *title:commonBinarySearch</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 *<span class="doctag">@return</span> 关键字位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> middle = <span class="number">0</span>;			<span class="comment">//定义middle</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">			middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">				<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">				high = middle - <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">				<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">				low = middle + <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> middle;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;		<span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是一种非常高效的排序算法，它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动次数。同时采用<strong>“分而治之”的思想</strong>，把大的拆分为小的，小的拆分为更小的，其原理如下：对于给定的一组记录，选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分，直到序列中的所有记录均有序为止。</p>
<p>图解说明：</p>
<p><img alt="image-20181112105007755" data-src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx5378e3k7j30g50hbtep.jpg" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, index;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        index = a[i]; <span class="comment">// 用子表的第一个记录做基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= index)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                a[i++] = a[j];<span class="comment">// 用比基准小的记录替换低位记录</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="comment">// 用比基准大的记录替换高位记录</span></span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = index;<span class="comment">// 将基准数值替换回 a[i]</span></span><br><span class="line">        sort(a, low, i - <span class="number">1</span>); <span class="comment">// 对低子表进行递归排序</span></span><br><span class="line">        sort(a, i + <span class="number">1</span>, hight); <span class="comment">// 对高子表进行递归排序</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a[] = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span> &#125;;</span><br><span class="line">        quickSort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/12/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="设计模式五大原则（SOLID）"><a href="#设计模式五大原则（SOLID）" class="headerlink" title="设计模式五大原则（SOLID）"></a>设计模式五大原则（SOLID）</h4><ol>
<li>S：单一职责原则（SRP：SingleResponsibilityPrinciple）</li>
<li>O：开闭原则（OCP:Open-Close Priciple）</li>
<li>L:里氏代换（LSP:The Liskov Substitution Principle）</li>
<li>I:接口隔离原则（ISP:The Interface Segregation priciple）</li>
<li>D:依赖倒转(DIP:The Dependency InVersion Principle)</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="图解大全"><a href="#图解大全" class="headerlink" title="图解大全"></a>图解大全</h4><table>
<thead>
<tr>
<th>数据类型名称</th>
<th>占用字节数</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte(字节型)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>short(短整型)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>int（整型）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Long（长整型）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>float(浮点型)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Double(双精度浮点型)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Char（字符型）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Http知识点："><a href="#Http知识点：" class="headerlink" title="Http知识点："></a>Http知识点：</h3><h4 id="request中getParameter和getAttribute的区别"><a href="#request中getParameter和getAttribute的区别" class="headerlink" title="request中getParameter和getAttribute的区别"></a>request中getParameter和getAttribute的区别</h4><p>其实getParameter()和getAttribute()最简单的两点区别就是</p>
<p>1）赋值方式不一样，前者是客户端如浏览器端将请求参数值送给服务器端，而后者则是在请求到达服务器端之后，在服务器进行存放进去</p>
<p>2）两者的返回值类型不一样，前者永远返回字符串，后者返回任意对象</p>
<h4 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h4><p><img alt="image-20181130084727239" data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxpst81sxpj30iu0ehta5.jpg" class="lazyload"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p><img alt="image-20181130085724204" data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxpt3gpjwxj30r507b0tu.jpg" class="lazyload"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h4><p>Java中wait、sleep的区别或者Java中sleep、yield的区别是Java面试或者多线程面试中最常问的问题之一。在这3个在Java中能够用来暂停线程的方法中，sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的， 这也是面试中常问的一个问题。</p>
<p>wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。</p>
<p>回到yield()方法上来，与wait()和sleep()方法有一些区别，它仅仅释放线程所占有的CPU资源，从而让其他线程有机会运行，但是并不能保证某个特定的线程能够获得CPU资源。谁能获得CPU完全取决于调度器，在有些情况下调用yield方法的线程甚至会再次得到CPU资源。所以，依赖于yield方法是不可靠的，它只能尽力而为。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img alt="image-20181130100239151" data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxpuzf00x3j30rb0do3zr.jpg" class="lazyload"> </p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol>
<li>引出线程异步（不安全）导致的问题</li>
<li>为何要线程同步？</li>
<li>同步方式一：使用synchronized同步方法</li>
<li>同步方式二：使用synchronized同步代码块</li>
<li>同步方式三：使用volatile关键字</li>
<li>同步方式四：使用ReentrantLock重入锁关键字</li>
<li>同步方式五：使用ThreadLocal局部变量实现线程同步</li>
<li>同步方式六：使用阻塞队列实现线程同步</li>
<li>同步方式七：使用原子变量实现线程同步</li>
</ol>
<h4 id="非线程安全异步导致的问题"><a href="#非线程安全异步导致的问题" class="headerlink" title="非线程安全异步导致的问题"></a>非线程安全异步导致的问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#异步非线程安全加钱</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank();</span><br><span class="line">        Integer num = <span class="number">10</span>;</span><br><span class="line">        Integer result = <span class="number">0</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="comment">//异步线程</span></span><br><span class="line">            result += num;</span><br><span class="line"></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    Integer account = bank.addAccount(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程名="</span> + Thread.currentThread().getName() + <span class="string">",当前用户余额="</span> + account);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"用户最终余额="</span> + bank.getAccount());</span><br><span class="line">        System.out.println(<span class="string">"正确用户余额="</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程异步导致结果"><a href="#线程异步导致结果" class="headerlink" title="线程异步导致结果"></a>线程异步导致结果</h5><p><img alt="image-20181218164622078" data-src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyazt0pbxhj30yr085aby.jpg" class="lazyload"></p>
<p>程序未能按照我们的预期跑起来。</p>
<h4 id="为何要线程同步？"><a href="#为何要线程同步？" class="headerlink" title="为何要线程同步？"></a>为何要线程同步？</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 从而保证了该变量的唯一性和准确性。</p>
<h4 id="同步方式一：使用synchronized同步方法"><a href="#同步方式一：使用synchronized同步方法" class="headerlink" title="同步方式一：使用synchronized同步方法"></a>同步方式一：使用synchronized同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 线程同步1：synchronized同步方法，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> codingprh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-12-18 5:08 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethodBank</span> <span class="keyword">extends</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title">addAccount</span><span class="params">(Integer money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用synchronized同步方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.account += money;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注：</p>
<ul>
<li>synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</li>
</ul>
<p><img alt="image-20181218173124647" data-src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyb13tvi0ij30z709w0v1.jpg" class="lazyload"></p>
<h4 id="同步方式二：使用synchronized同步代码块"><a href="#同步方式二：使用synchronized同步代码块" class="headerlink" title="同步方式二：使用synchronized同步代码块"></a>同步方式二：使用synchronized同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank();</span><br><span class="line">        Integer num = <span class="number">10</span>;</span><br><span class="line">        Integer result = <span class="number">0</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="comment">//异步线程</span></span><br><span class="line">            result += num;</span><br><span class="line"></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//synchronized (bank) &#123;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (bank) &#123;</span><br><span class="line">                        Integer account = bank.addAccount(<span class="number">10</span>);</span><br><span class="line">                        System.out.println(<span class="string">"线程名="</span> + Thread.currentThread().getName() + <span class="string">",当前用户余额="</span> + account);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"用户最终余额="</span> + bank.getAccount());</span><br><span class="line">        System.out.println(<span class="string">"正确用户余额="</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 注：</p>
<ul>
<li>同步是一种高开销的操作，因此应该尽量减少同步的内容。 </li>
<li>通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</li>
</ul>
<h4 id="同步方式三：使用volatile关键字"><a href="#同步方式三：使用volatile关键字" class="headerlink" title="同步方式三：使用volatile关键字"></a>同步方式三：使用volatile关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Integer account = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注：<strong>但是不推荐使用</strong></p>
<ol>
<li>因为volatile不能保证原子操作导致的，因此volatile不能代替synchronized</li>
<li>此外volatile会组织编译器对代码优化，因此能不使用它就不使用它吧</li>
<li><strong>原理：</strong>它的原理是每次要线程要访问volatile修饰的变量时都是从内存中读取，而不是存缓存当中读取，因此每个线程访问到的变量值都是一样的。这样就保证了同步。</li>
<li>建议：volatile+fianl搭配使用：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。 </li>
</ol>
<h4 id="同步方式四：使用ReentrantLock重入锁关键字"><a href="#同步方式四：使用ReentrantLock重入锁关键字" class="headerlink" title="同步方式四：使用ReentrantLock重入锁关键字"></a>同步方式四：使用ReentrantLock重入锁关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 重入锁bank</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> codingprh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-12-18 6:03 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockBank</span> <span class="keyword">extends</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">addAccount</span><span class="params">(Integer money)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.account += money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：关于Lock对象和synchronized关键字的选择： </p>
<ul>
<li>最好两个都不用，使用一种java.util.concurrent包提供的机制， 能够帮助用户处理所有与锁相关的代码。 </li>
<li>如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 </li>
<li>如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 </li>
</ul>
<h4 id="同步方式五：使用ThreadLocal局部变量实现线程同步"><a href="#同步方式五：使用ThreadLocal局部变量实现线程同步" class="headerlink" title="同步方式五：使用ThreadLocal局部变量实现线程同步"></a>同步方式五：使用ThreadLocal局部变量实现线程同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadSynchronization.synchronous;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * ThreadLocal局部变量实现线程同步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> codingprh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-12-19 10:30 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalBank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">addAccount</span><span class="params">(Integer money)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        account.set(account.get() + money);</span><br><span class="line">        <span class="keyword">return</span> account.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> account.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>原理：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
<li>ThreadLocal与同步机制 <ol>
<li>a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。</li>
<li>b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式</li>
</ol>
</li>
</ul>
<p>运行结果：</p>
<p><img alt="image-20181219105522977" data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fybva2lpusj310608amz0.jpg" class="lazyload"></p>
<p>正是因为每个线程都复制了一份，因此每个线程的值都等于10，但是主线程的account值没有改变。提现了采用空间换时间。</p>
<h4 id="同步方式六：使用阻塞队列实现线程同步"><a href="#同步方式六：使用阻塞队列实现线程同步" class="headerlink" title="同步方式六：使用阻塞队列实现线程同步"></a>同步方式六：使用阻塞队列实现线程同步</h4><p><strong>推荐使用阻塞队列实现线程同步</strong>，前面的五种实现都是基于底层框架实现的。我们可以直接使用java.util.concurrent包下面各种同步工具类、集合等来简化我们开发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadSynchronization.synchronous.queuePackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threadSynchronization.Bank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 采用阻塞队列实现同步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> codingprh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-12-19 11:16 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueThreadMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank();</span><br><span class="line">        Integer num = <span class="number">10</span>;</span><br><span class="line">        Integer result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//消费线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer money = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((money = queue1.take()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Integer account = bank.addAccount(money);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">",用户余额="</span> + account + <span class="string">",queue长度="</span> + queue1.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成线程</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="comment">//异步线程</span></span><br><span class="line">            result += num;</span><br><span class="line"></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    queue1.put(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">",队列长度="</span> + queue1.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        queue1.put(-<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户最终余额="</span> + bank.getAccount());</span><br><span class="line">        System.out.println(<span class="string">"正确用户余额="</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<strong>推荐使用阻塞队列实现线程同步</strong></p>
<p>运行结果：</p>
<p><img alt="image-20181220074431063" data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fycvdsp4rqj30yr0bytax.jpg" class="lazyload"></p>
<h4 id="同步方式七：使用原子变量实现线程同步"><a href="#同步方式七：使用原子变量实现线程同步" class="headerlink" title="同步方式七：使用原子变量实现线程同步"></a>同步方式七：使用原子变量实现线程同步</h4><p>原子变量有什么优势？</p>
<p>使用线程同步的根本原因在于对普通变量的操作不是原子的，而原子变量是原子操作。</p>
<p>原子操作是什么？<br>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作<br>即-这几种行为要么同时完成，要么都不完成。</p>
<p>在java.utils.concurrent.atomic包提供了那些原子变量？</p>
<p><img alt="image-20181220075318454" data-src="https://ws4.sinaimg.cn/large/006tNbRwgy1fycvmxndi7j30aw0aidgf.jpg" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger account = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="TCP-IP协议族分层"><a href="#TCP-IP协议族分层" class="headerlink" title="TCP/IP协议族分层"></a>TCP/IP协议族分层</h3><h4 id="什么是tcp-ip协议族？"><a href="#什么是tcp-ip协议族？" class="headerlink" title="什么是tcp/ip协议族？"></a>什么是tcp/ip协议族？</h4><p>tcp/ip是互联网相关各类协议族的总称。包括我们日常听到的协议：http协议，ip协议，dns协议，tcp协议等。</p>
<p><img alt="image-20181219082523911" data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fybqy0kk6ej30fd095acf.jpg" class="lazyload"></p>
<h4 id="tcp-ip分层管理"><a href="#tcp-ip分层管理" class="headerlink" title="tcp/ip分层管理"></a>tcp/ip分层管理</h4><p>tcp/ip分层管理，自顶向下分别是：应用层，传输层，网络层，数据链路层。</p>
<p>具体介绍，如下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>常见协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>提供应用服务时的通信活动。</td>
<td>HTTP、FTP、DNS、</td>
</tr>
<tr>
<td>传输层</td>
<td>提供处于网络连接中的两台计算机之间的<strong>数据传输</strong>。提供字节流服务。</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>处理网络上流动的数据包，通过<strong>怎么样的路径达到对方的计算机</strong>。利用IP协议和ARP协议找到对方的Mac地址。</td>
<td>IP、ARP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>处理网络连接的硬件部分。</td>
<td></td>
</tr>
</tbody></table>
<p>图文描述：</p>
<p><img alt="image-20181219084207907" data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fybrfhc7jjj30u40qq48x.jpg" class="lazyload"></p>
<h4 id="传输层：TCP三次握手"><a href="#传输层：TCP三次握手" class="headerlink" title="传输层：TCP三次握手"></a>传输层：TCP三次握手</h4><p>TCP协议是可靠的传输层协议，是因为它采用的是三次握手策略，能够确保数据达到目的地。</p>
<ol>
<li>客户端向服务器端发起带有SYN标志的数据包</li>
<li>服务器响应客户端，发回带有SYN和ACK标志的数据包。</li>
<li>客户端响应服务器端发送带有ACK标志的数据包，三次握手完成。</li>
</ol>
<p>图文描述：</p>
<p><img alt="image-20181219084741961" data-src="https://ws3.sinaimg.cn/large/006tNbRwgy1fybrl7za2tj30v00hgjxx.jpg" class="lazyload"></p>
<h4 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h4><p>图文概述tcp/ip协议族在分层后，各个层的工作职责是什么，并且各个层是如何通信。</p>
<p><img alt="image-20181219085247817" data-src="https://ws2.sinaimg.cn/large/006tNbRwgy1fybrqjhwmtj30u018ctrd.jpg" class="lazyload"></p>
<h3 id="Java随笔"><a href="#Java随笔" class="headerlink" title="Java随笔"></a>Java随笔</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p> Java里面异常分为两大类:</p>
<ul>
<li><p>checked exception(检查异常)：对checked exception(检查异常)要求你必须要在方法里面或者捕获或者继续抛出。</p>
<p>Java.lang.ClassNotFoundException<br>Java.lang.NoSuchMetodException<br>java.io.IOException</p>
</li>
<li><p>unchecked exception(未检查异常)：对于未检查异常也叫RuntimeException(运行时异常),对于运行时异常，java编译器不要求你一定要把它捕获或者一定要继续抛出。</p>
<p>Java.lang.ArithmeticException<br>Java.lang.ArrayStoreExcetpion<br>Java.lang.ClassCastException<br>Java.lang.IndexOutOfBoundsException<br>Java.lang.NullPointerException</p>
</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><a href="https://www.jianshu.com/p/ff5f5b7e8b93?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=weixin" target="_blank" rel="noopener">Java 泛型解惑之&lt;? extends T&gt;和&lt;? super T&gt;：</a></p>
<p>PECS（Producer Extends Consumer Super）原则：</p>
<ol>
<li>频繁往外读取内容的，适合用上界Extends</li>
<li>经常往里插入的，适合用下界Super</li>
</ol>
<h4 id="如何理解回调函数"><a href="#如何理解回调函数" class="headerlink" title="如何理解回调函数"></a>如何理解回调函数</h4><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p>
<p><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="noopener">知乎：回调函数</a></p>
<h4 id="如何理解java语法糖？"><a href="#如何理解java语法糖？" class="headerlink" title="如何理解java语法糖？"></a>如何理解java语法糖？</h4><p>可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p>
<h4 id="如何使用Guava-Cache和redis比较"><a href="#如何使用Guava-Cache和redis比较" class="headerlink" title="如何使用Guava Cache和redis比较"></a>如何使用Guava Cache和redis比较</h4><p><a href="https://www.jianshu.com/p/afe7b2dccee0" target="_blank" rel="noopener">官网介绍Guava Cache基本用法</a></p>
<p><a href="https://segmentfault.com/a/1190000011105644" target="_blank" rel="noopener">Guava Cache参数进阶配置</a></p>
<p><a href="https://blog.wangqi.love/articles/Java/Guava%20Cache%E4%B8%8ERedis%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.html" target="_blank" rel="noopener">Guava Cache和redis的性能比较</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LoadingCache&lt;Integer, Object&gt; modelCache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">//限制缓存大小，防止OOM</span></span><br><span class="line">            .maximumSize(<span class="number">1000</span>)</span><br><span class="line">            <span class="comment">//提供过期策略</span></span><br><span class="line">            .expireAfterAccess(<span class="number">100</span>, TimeUnit.MINUTES)</span><br><span class="line">            <span class="comment">//数据统计开关</span></span><br><span class="line">            .recordStats()</span><br><span class="line">            <span class="comment">//元素被移除后的回调</span></span><br><span class="line">            .removalListener((RemovalListener&lt;Integer, Object&gt;) notification -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"remove taskbot from guava cache: key[&#123;&#125;], cause[&#123;&#125;]"</span>, notification.getKey(), notification.getCause());</span><br><span class="line">                <span class="keyword">final</span> RemovalCause cause = notification.getCause();</span><br><span class="line">                <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EXPIRED:</span><br><span class="line">                        log.info(<span class="string">"model evicted because of expiration in guava cache: &#123;&#125;"</span>, notification.getKey());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SIZE:</span><br><span class="line">                        log.info(<span class="string">"model evicted because of size in guava cache: &#123;&#125;"</span>, notification.getKey());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> COLLECTED:</span><br><span class="line">                        <span class="comment">//如果是缓存到期等原因被删除，则需要通知分布式环境下的其他机器也要删除</span></span><br><span class="line">                        log.info(<span class="string">"model evicted because of gc in guava cache: &#123;&#125;"</span>, notification.getKey());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EXPLICIT:</span><br><span class="line">                        log.info(<span class="string">"model evicted because of explicit in guava cache: &#123;&#125;"</span>, notification.getKey());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> REPLACED:</span><br><span class="line">                        log.info(<span class="string">"model updated because of replaced in guava cache: &#123;&#125;"</span>, notification.getKey());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        log.error(<span class="string">"there should not be [&#123;&#125;]"</span>, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//缓存不存在的时候，自动加载</span></span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;Integer, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(@Nonnull Integer key)</span> </span>&#123;</span><br><span class="line">                    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">                    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//guava不支持null，会抛出异常InvalidCacheLoadException，最佳办法是抛出自定义异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="JetCache神器用法"><a href="#JetCache神器用法" class="headerlink" title="JetCache神器用法"></a>JetCache神器用法</h4><h4 id="java线程池的理解"><a href="#java线程池的理解" class="headerlink" title="java线程池的理解"></a>java线程池的理解</h4><p><a href="http://calvin1978.blogcn.com/articles/java-threadpool.html" target="_blank" rel="noopener">如何创建线程池</a><br><a href="https://blog.cayzlh.com/2019/01/18/2019011801/" target="_blank" rel="noopener">BlockingQueue理解</a></p>
<h4 id="springBoot异步执行代码-amp-amp-springBoot单例线程池"><a href="#springBoot异步执行代码-amp-amp-springBoot单例线程池" class="headerlink" title="springBoot异步执行代码&amp;&amp;springBoot单例线程池"></a>springBoot异步执行代码&amp;&amp;springBoot单例线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加上这两个注解</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Async</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/0170d71dc502" target="_blank" rel="noopener">修改springBoot默认线程池</a></p>
<h4 id="Map中的JAVA8流式处理"><a href="#Map中的JAVA8流式处理" class="headerlink" title="Map中的JAVA8流式处理"></a>Map中的JAVA8流式处理</h4><p><a href="https://juejin.im/post/5c944f866fb9a070bd599fea" target="_blank" rel="noopener">java中Mergy的使用</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.forEach(erpProduct -&gt; &#123;</span><br><span class="line">   <span class="comment">//productCategoryEnumMap.computeIfPresent(ProductCategoryEnum.getEnumByKey(erpProduct.getCategoryId()),</span></span><br><span class="line">   <span class="comment">//        (key, value) -&gt; &#123;</span></span><br><span class="line">   <span class="comment">//            List&lt;Integer&gt; resultTemp = value;</span></span><br><span class="line">   <span class="comment">//            resultTemp.add(erpProduct.getId());</span></span><br><span class="line">   <span class="comment">//            return resultTemp;</span></span><br><span class="line">   <span class="comment">//        &#125;);</span></span><br><span class="line">   <span class="comment">//productCategoryEnumMap.computeIfAbsent(ProductCategoryEnum.getEnumByKey(erpProduct.getCategoryId()),</span></span><br><span class="line">   <span class="comment">//        key -&gt; &#123;</span></span><br><span class="line">   <span class="comment">//            return Arrays.asList(erpProduct.getId());</span></span><br><span class="line">   <span class="comment">//        &#125;</span></span><br><span class="line">   <span class="comment">//);</span></span><br><span class="line">   productCategoryEnumMap.merge(ProductCategoryEnum.getEnumByKey(erpProduct.getCategoryId()), Arrays.asList(erpProduct.getId()),</span><br><span class="line">           (oldValue, newValue) -&gt; &#123;</span><br><span class="line">               List&lt;Integer&gt; resultTemp = Lists.newArrayList();</span><br><span class="line">               resultTemp.addAll(oldValue);</span><br><span class="line">               resultTemp.addAll(newValue);</span><br><span class="line">               <span class="keyword">return</span> resultTemp;</span><br><span class="line">           &#125;</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/5b2ddbcef265da59a76c92a4#heading-16" target="_blank" rel="noopener">高质量讲解springBoot中的Listener, Servlet, Filter和Interceptor</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/12/17/2018-12-17-%E5%89%91%E6%8C%87JavaOffer/">http://yoursite.com/2018/12/17/2018-12-17-%E5%89%91%E6%8C%87JavaOffer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/offer/">offer    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/12/20/2018-12-20-SpringAop%E5%AE%9E%E6%88%98/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97p2mnavfj31hc0u07et.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>SpringAop实战</span></div></a></div><div class="next-post pull_right"><a href="/2018/11/17/2018-03-26-Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97rx8rnuaj31hc0u0jz3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>2018-03-26-Linux命令大全</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/23/2020-02-23-剑指Offer（完整版）/" title="剑指Offer（完整版）"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzuv0v76mj31fj0oyqc3.jpg"><div class="relatedPosts_title">剑指Offer（完整版）</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>