<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java并发编程实战①-并发理论基础 | Noah</title><meta name="description" content="Java并发编程实战是学习《并发编程实战》和极客时间《Java并发编程》的记录。"><meta name="keywords" content="Java并发"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java并发编程实战①-并发理论基础"><meta name="twitter:description" content="Java并发编程实战是学习《并发编程实战》和极客时间《Java并发编程》的记录。"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java并发编程实战①-并发理论基础"><meta property="og:url" content="http://yoursite.com/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="Java并发编程实战是学习《并发编程实战》和极客时间《Java并发编程》的记录。"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"><link rel="prev" title="Java并发编程实战②-并发工具类" href="http://yoursite.com/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A1-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"><link rel="next" title="Spring与boot源码④-MVC核心" href="http://yoursite.com/2019/09/09/2019-09-09-spring%E4%B8%8Eboot%E6%BA%90%E7%A0%81%E2%91%A3-mvc%E6%A0%B8%E5%BF%83/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java并发编程实战-并发理论基础"><span class="toc_mobile_items-text">Java并发编程实战-并发理论基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发理论基础-总览"><span class="toc_mobile_items-text">并发理论基础-总览</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发编程的三个核心问题：分工、同步和互斥"><span class="toc_mobile_items-text">并发编程的三个核心问题：分工、同步和互斥</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分工"><span class="toc_mobile_items-text">分工</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#同步"><span class="toc_mobile_items-text">同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#互斥"><span class="toc_mobile_items-text">互斥</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分工、同步和互斥全景图"><span class="toc_mobile_items-text">分工、同步和互斥全景图</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#可见性、原子性、有序性问题：并发编程Bug的源头"><span class="toc_mobile_items-text">可见性、原子性、有序性问题：并发编程Bug的源头</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#并发程序硬件优化导致的问题"><span class="toc_mobile_items-text">并发程序硬件优化导致的问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可见性：缓存导致的可见性问题"><span class="toc_mobile_items-text">可见性：缓存导致的可见性问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原子性：线程切换带来原子性问题"><span class="toc_mobile_items-text">原子性：线程切换带来原子性问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#有序性：编译优化带来的有序性问题"><span class="toc_mobile_items-text">有序性：编译优化带来的有序性问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Java双重检查创建单例对象"><span class="toc_mobile_items-text">Java双重检查创建单例对象</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java内存模型：看Java如何解决可见性和有序性问题"><span class="toc_mobile_items-text">Java内存模型：看Java如何解决可见性和有序性问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是Java内存模型"><span class="toc_mobile_items-text">什么是Java内存模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么Volatile关键字"><span class="toc_mobile_items-text">什么Volatile关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Happens-Before六项规则：前面一个操作的结果对后续操作是可见的"><span class="toc_mobile_items-text">Happens-Before六项规则：前面一个操作的结果对后续操作是可见的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是管程"><span class="toc_mobile_items-text">什么是管程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#理解final"><span class="toc_mobile_items-text">理解final</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#互斥锁（上）：解决原子性问题"><span class="toc_mobile_items-text">互斥锁（上）：解决原子性问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁的模型"><span class="toc_mobile_items-text">锁的模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁技术：Synchronized"><span class="toc_mobile_items-text">锁技术：Synchronized</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#互斥锁（下）：如何用一把锁保护多个资源"><span class="toc_mobile_items-text">互斥锁（下）：如何用一把锁保护多个资源</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#保护没有关联关系的多个资源"><span class="toc_mobile_items-text">保护没有关联关系的多个资源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#保护有关联关系的多个资源"><span class="toc_mobile_items-text">保护有关联关系的多个资源</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一不小心就死锁了，怎么办？"><span class="toc_mobile_items-text">一不小心就死锁了，怎么办？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#优化转账类级别锁"><span class="toc_mobile_items-text">优化转账类级别锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#破坏”不可抢占条件”"><span class="toc_mobile_items-text">破坏”不可抢占条件”</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#破坏”循环等待条件”"><span class="toc_mobile_items-text">破坏”循环等待条件”</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#用”等待-通知”机制优化占有且等待（循环等待）"><span class="toc_mobile_items-text">用”等待-通知”机制优化占有且等待（循环等待）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#利用现实世界的模型来构思程序"><span class="toc_mobile_items-text">利用现实世界的模型来构思程序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#用Synchronized实现等待-通知机制"><span class="toc_mobile_items-text">用Synchronized实现等待-通知机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#更好的资源分配器"><span class="toc_mobile_items-text">更好的资源分配器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java线程（上）：Java线程的生命周期"><span class="toc_mobile_items-text">Java线程（上）：Java线程的生命周期</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#通用的线程生命周期"><span class="toc_mobile_items-text">通用的线程生命周期</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java中线程的生命周期"><span class="toc_mobile_items-text">Java中线程的生命周期</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java线程（中）：创建多少线程才是适合的？"><span class="toc_mobile_items-text">Java线程（中）：创建多少线程才是适合的？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么要使用多线程？"><span class="toc_mobile_items-text">为什么要使用多线程？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多线程的应用场景"><span class="toc_mobile_items-text">多线程的应用场景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建多少线程适合？"><span class="toc_mobile_items-text">创建多少线程适合？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java线程（下）：为什么局部变量是线程安全的？"><span class="toc_mobile_items-text">Java线程（下）：为什么局部变量是线程安全的？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何用面向对象思想写好并发程序"><span class="toc_mobile_items-text">如何用面向对象思想写好并发程序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#封装共享变量"><span class="toc_mobile_items-text">封装共享变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别共享变量间的约束条件"><span class="toc_mobile_items-text">识别共享变量间的约束条件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#指定并发访问策略"><span class="toc_mobile_items-text">指定并发访问策略</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发理论总结"><span class="toc_mobile_items-text">并发理论总结</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发编程实战-并发理论基础"><span class="toc-text">Java并发编程实战-并发理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发理论基础-总览"><span class="toc-text">并发理论基础-总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程的三个核心问题：分工、同步和互斥"><span class="toc-text">并发编程的三个核心问题：分工、同步和互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分工"><span class="toc-text">分工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步"><span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥"><span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分工、同步和互斥全景图"><span class="toc-text">分工、同步和互斥全景图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可见性、原子性、有序性问题：并发编程Bug的源头"><span class="toc-text">可见性、原子性、有序性问题：并发编程Bug的源头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发程序硬件优化导致的问题"><span class="toc-text">并发程序硬件优化导致的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性：缓存导致的可见性问题"><span class="toc-text">可见性：缓存导致的可见性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性：线程切换带来原子性问题"><span class="toc-text">原子性：线程切换带来原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序性：编译优化带来的有序性问题"><span class="toc-text">有序性：编译优化带来的有序性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java双重检查创建单例对象"><span class="toc-text">Java双重检查创建单例对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型：看Java如何解决可见性和有序性问题"><span class="toc-text">Java内存模型：看Java如何解决可见性和有序性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java内存模型"><span class="toc-text">什么是Java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么Volatile关键字"><span class="toc-text">什么Volatile关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happens-Before六项规则：前面一个操作的结果对后续操作是可见的"><span class="toc-text">Happens-Before六项规则：前面一个操作的结果对后续操作是可见的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是管程"><span class="toc-text">什么是管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解final"><span class="toc-text">理解final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥锁（上）：解决原子性问题"><span class="toc-text">互斥锁（上）：解决原子性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的模型"><span class="toc-text">锁的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁技术：Synchronized"><span class="toc-text">锁技术：Synchronized</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥锁（下）：如何用一把锁保护多个资源"><span class="toc-text">互斥锁（下）：如何用一把锁保护多个资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#保护没有关联关系的多个资源"><span class="toc-text">保护没有关联关系的多个资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保护有关联关系的多个资源"><span class="toc-text">保护有关联关系的多个资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一不小心就死锁了，怎么办？"><span class="toc-text">一不小心就死锁了，怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化转账类级别锁"><span class="toc-text">优化转账类级别锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#破坏”不可抢占条件”"><span class="toc-text">破坏”不可抢占条件”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#破坏”循环等待条件”"><span class="toc-text">破坏”循环等待条件”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用”等待-通知”机制优化占有且等待（循环等待）"><span class="toc-text">用”等待-通知”机制优化占有且等待（循环等待）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用现实世界的模型来构思程序"><span class="toc-text">利用现实世界的模型来构思程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用Synchronized实现等待-通知机制"><span class="toc-text">用Synchronized实现等待-通知机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更好的资源分配器"><span class="toc-text">更好的资源分配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java线程（上）：Java线程的生命周期"><span class="toc-text">Java线程（上）：Java线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用的线程生命周期"><span class="toc-text">通用的线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中线程的生命周期"><span class="toc-text">Java中线程的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java线程（中）：创建多少线程才是适合的？"><span class="toc-text">Java线程（中）：创建多少线程才是适合的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用多线程？"><span class="toc-text">为什么要使用多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的应用场景"><span class="toc-text">多线程的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建多少线程适合？"><span class="toc-text">创建多少线程适合？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java线程（下）：为什么局部变量是线程安全的？"><span class="toc-text">Java线程（下）：为什么局部变量是线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何用面向对象思想写好并发程序"><span class="toc-text">如何用面向对象思想写好并发程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装共享变量"><span class="toc-text">封装共享变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别共享变量间的约束条件"><span class="toc-text">识别共享变量间的约束条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定并发访问策略"><span class="toc-text">指定并发访问策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发理论总结"><span class="toc-text">并发理论总结</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java并发编程实战①-并发理论基础</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-09-22<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-23</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">6.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="Java并发编程实战-并发理论基础"><a href="#Java并发编程实战-并发理论基础" class="headerlink" title="Java并发编程实战-并发理论基础"></a>Java并发编程实战-并发理论基础</h1><blockquote>
<p>Java并发编程实战是学习《并发编程实战》和极客时间《Java并发编程》的记录。</p>
</blockquote>
<h2 id="并发理论基础-总览"><a href="#并发理论基础-总览" class="headerlink" title="并发理论基础-总览"></a>并发理论基础-总览</h2><blockquote>
<p>第一部分：并发理论基础</p>
<ol>
<li>并发编程的三个核心问题：分工、同步和互斥</li>
<li>可见性、原子性、有序性问题：并发编程Bug的源头</li>
<li>Java内存模型：看Java如何解决可见性和有序性问题</li>
<li>互斥锁（上）：解决原子性问题</li>
<li>互斥锁（下）：如何用一把锁保护多个资源</li>
<li>一不小心就死锁了，怎么办？</li>
<li>用”等待-通知”机制优化循环等待</li>
<li>安全性、活跃性以及性能问题</li>
<li>管程：并发编程的万能钥匙</li>
<li>Java线程（上）：Java线程的生命周期</li>
<li>Java线程（中）：创建多少线程才是适合的？</li>
<li>Java线程（下）：为什么局部变量是线程安全的？</li>
<li>如何用面向对象思想写好并发程序</li>
<li>并发理论总结</li>
</ol>
</blockquote>
<h2 id="并发编程的三个核心问题：分工、同步和互斥"><a href="#并发编程的三个核心问题：分工、同步和互斥" class="headerlink" title="并发编程的三个核心问题：分工、同步和互斥"></a>并发编程的三个核心问题：分工、同步和互斥</h2><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><ul>
<li><p>分工就是把一个大问题，拆分为多个任务。</p>
</li>
<li><p>代码领域实现</p>
<blockquote>
<p>Java SDK 并发包里的 Executor、Fork/Join、 Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本 上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。</p>
</blockquote>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><blockquote>
<p>同步是在分好工之后，在具体执行任务时，任务之间是有依赖关系的，也就是任务之间需要沟通。</p>
<p><strong>在并发编程领域里的同步，主要指的就是线程之间的协作</strong>。本质是一个线程执行完了一个任务，如何通知执行后续任务的线程开工。</p>
</blockquote>
<ul>
<li>协作一般是和分工相关的。<ul>
<li>例如，用 Future 可以发起一个异步调 用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时， get() 方法就自动返回了。</li>
<li>除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、 Exchanger 也都是用来解决线程协作问题的。</li>
</ul>
</li>
<li>自己来处理线程之间的协作：<strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行</strong>。<ul>
<li>例如，在生产者 - 消费者 模型里，也有类似的描述，“当队列满时，生产者线程等待，当队列不满时，生产者线程 需要被唤醒执行;当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒 执行。”</li>
</ul>
</li>
<li>管程是一种解决并发问题的通用模型，除了能解决线程协作问 题，还能解决下面我们将要介绍的互斥问题。可以这么说，<strong>管程是解决并发问题的万能钥 匙</strong>。</li>
</ul>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><blockquote>
<p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语 叫“<strong>线程安全</strong>”。所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</p>
</blockquote>
<ul>
<li>并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确 定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要 源头是可见性问题、有序性问题和原子性问题。<ul>
<li>为了解决这三个问题，Java 语言引入了内 存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序 性问题。</li>
<li>但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。</li>
</ul>
</li>
<li>实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决 互斥问题。<ul>
<li>那如何保证安全性的同 时又尽量提高性能呢?<ul>
<li>可以分场景优化，Java SDK 里提供的 ReadWriteLock、 StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。</li>
<li>原理是不共享变量或者变量只允许读。这方面，Java 提 供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分工、同步和互斥全景图"><a href="#分工、同步和互斥全景图" class="headerlink" title="分工、同步和互斥全景图"></a>分工、同步和互斥全景图</h3><p><img alt="image-20190922213345476" data-src="http://ww1.sinaimg.cn/large/006y8mN6ly1g78mdvk9msj31i80u0qe9.jpg" class="lazyload"></p>
<h2 id="可见性、原子性、有序性问题：并发编程Bug的源头"><a href="#可见性、原子性、有序性问题：并发编程Bug的源头" class="headerlink" title="可见性、原子性、有序性问题：并发编程Bug的源头"></a>可见性、原子性、有序性问题：并发编程Bug的源头</h2><h3 id="并发程序硬件优化导致的问题"><a href="#并发程序硬件优化导致的问题" class="headerlink" title="并发程序硬件优化导致的问题"></a>并发程序硬件优化导致的问题</h3><blockquote>
<p>cpu、内存、I/O设备三者都在不断迭代，但是这三者的速度差异是非常大的。根据木桶理论原理，程序整体的性能取决于最慢的操作—读写I/O设备，也就是说单方面提高CPU的性能是无效的。</p>
</blockquote>
<ul>
<li>为了合理利用CPU的高性能，平衡这三者的速度差异，有下面手段。<ol>
<li>CPU增加了缓存，以均衡与内存的速度差异</li>
<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异。</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>
</ol>
</li>
</ul>
<h3 id="可见性：缓存导致的可见性问题"><a href="#可见性：缓存导致的可见性问题" class="headerlink" title="可见性：缓存导致的可见性问题"></a>可见性：缓存导致的可见性问题</h3><blockquote>
<p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到，我们成为可见性。</p>
</blockquote>
<ul>
<li>在单核时期，采用cpu缓存机制在多个线程修改和访问共享变量是没问题的。但是在多核时期，每个CPU都有自己的缓存，这导致cpu缓存和内存的数据一致性就有问题了。</li>
</ul>
<h3 id="原子性：线程切换带来原子性问题"><a href="#原子性：线程切换带来原子性问题" class="headerlink" title="原子性：线程切换带来原子性问题"></a>原子性：线程切换带来原子性问题</h3><blockquote>
<p>原子性：我们把一个或者多个操作在cpu执行的过程中不被中断的特性。</p>
<p>时间片：操作系统允许某个进程执行一小段时间（占用cpu），例如 50 毫秒，过了 50 毫秒操作系统就会重新选 择一个进程来执行(我们称为“任务切换”)，这个 50 毫秒称为“<strong>时间片</strong>”。</p>
</blockquote>
<ul>
<li><p>线程切换示意图（任务切换=线程切换）</p>
<p><img alt="image-20190923091804113" data-src="http://ww2.sinaimg.cn/large/006y8mN6gy1g796qnqm6tj30h7096aas.jpg" class="lazyload"></p>
</li>
<li><p>任务切换带来的并发问题：我们在高级语言里一条语句往往需要多条CPU指令完成，如何没执行完cpu指令，就发生任务切换。如执行<code>count+=1;</code>至少需要三条cpu指令</p>
<ul>
<li>指令1：首先，需要把变量count从内存加载到cpu寄存器</li>
<li>指令2：之后，在寄存器中执行+1操作</li>
<li>指令3：最后，将结果写入内存（缓存机制可能写入的是cpu缓存而不是内存）</li>
</ul>
</li>
</ul>
<h3 id="有序性：编译优化带来的有序性问题"><a href="#有序性：编译优化带来的有序性问题" class="headerlink" title="有序性：编译优化带来的有序性问题"></a>有序性：编译优化带来的有序性问题</h3><blockquote>
<p>有序性：编译器和解析器自动为我们程序自动做的优化，带来的问题。</p>
</blockquote>
<h4 id="Java双重检查创建单例对象"><a href="#Java双重检查创建单例对象" class="headerlink" title="Java双重检查创建单例对象"></a>Java双重检查创建单例对象</h4><blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 有序性：导致的并发问题，双重检查举例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-09-23 09:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_1_Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _1_Order instace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">_1_Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _1_Order <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instace == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (_1_Order<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instace = <span class="keyword">new</span> _1_Order();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>理论上是没什么问题，这段程序。但是new 操作上面却有问题。如何new操作（优化后），在第二步发生了线程切换，在另外一个线程获取到instace时没有完成初始化的，在该线程获取成员变量的时候，就会发生空指针异常。</p>
<ul>
<li>new操作（去掉优化）<ol>
<li>分配一块内存M</li>
<li>在内存M上初始化Singleton对象</li>
<li>然后M地址赋值给instance对象</li>
</ol>
</li>
<li>程序new操作（优化后）<ol>
<li>分配一块内存M</li>
<li>将M的地址赋值给instance变量</li>
<li>最后在内存M上初始化Singleton对象</li>
</ol>
</li>
</ul>
<p><img alt="image-20190923094951999" data-src="http://ww2.sinaimg.cn/large/006y8mN6gy1g797nr3g9ij30hr0c8tar.jpg" class="lazyload"></p>
</blockquote>
<h2 id="Java内存模型：看Java如何解决可见性和有序性问题"><a href="#Java内存模型：看Java如何解决可见性和有序性问题" class="headerlink" title="Java内存模型：看Java如何解决可见性和有序性问题"></a>Java内存模型：看Java如何解决可见性和有序性问题</h2><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><blockquote>
<p>定义：Java内存模型是个很复杂的规范，站在程序员的视角：本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。</p>
<p>具体：这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六 项 <strong>Happens-Before 规则</strong>。</p>
<p>任何一门语言，在解决并发问题的时候都是围绕着可见性、原子性、有序性去解决的。可见性、有序性二者解决方案：按需的禁用缓存以及编译优化。</p>
</blockquote>
<h3 id="什么Volatile关键字"><a href="#什么Volatile关键字" class="headerlink" title="什么Volatile关键字"></a>什么Volatile关键字</h3><blockquote>
<p>volatile关键字的含义就是禁用cpu缓存，读写数据都是在内存上面操作。解决的问题是：可见性、有序性。在JDK1.5才加上的特性。</p>
</blockquote>
<h3 id="Happens-Before六项规则：前面一个操作的结果对后续操作是可见的"><a href="#Happens-Before六项规则：前面一个操作的结果对后续操作是可见的" class="headerlink" title="Happens-Before六项规则：前面一个操作的结果对后续操作是可见的"></a>Happens-Before六项规则：前面一个操作的结果对后续操作是可见的</h3><blockquote>
<p>什么是Happens-Before：<strong>前面一个操作的结果对后续操作是可见的</strong>。解决的问题是：可见性、有序性。比较正式的说法是:Happens-Before 约束 了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens- Before 规则。</p>
</blockquote>
<ol>
<li>程序的顺序性规则<ul>
<li>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意 操作。</li>
</ul>
</li>
<li>volatile变量规则<ul>
<li>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile变量的读操作。</li>
</ul>
</li>
<li>传递性<ul>
<li>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
</ul>
</li>
<li>管程中锁的规则<ul>
<li>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</li>
</ul>
</li>
<li>线程start()规则<ul>
<li>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</li>
</ul>
</li>
<li>线程join()规则</li>
</ol>
<h3 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h3><blockquote>
<p><strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p>
</blockquote>
<h3 id="理解final"><a href="#理解final" class="headerlink" title="理解final"></a>理解final</h3><blockquote>
<p><strong>final 修饰变量时，初衷是告诉编译器:这个变量生而不变，可以可劲儿优化。</strong></p>
</blockquote>
<p>使用final修饰要注意逃逸问题</p>
<h2 id="互斥锁（上）：解决原子性问题"><a href="#互斥锁（上）：解决原子性问题" class="headerlink" title="互斥锁（上）：解决原子性问题"></a>互斥锁（上）：解决原子性问题</h2><blockquote>
<p>原子性问题的源头就是线程切换，禁用线程切换等价于禁用CPU中断。</p>
<p><strong>互斥：同一时刻只有一个线程执行。</strong></p>
<p>保证对共享变量的修改是互斥的，无论是单核还是多核CPU，都能保证原子性。</p>
</blockquote>
<h3 id="锁的模型"><a href="#锁的模型" class="headerlink" title="锁的模型"></a>锁的模型</h3><p><img alt="image-20190924222004304" data-src="http://ww3.sinaimg.cn/large/006y8mN6gy1g7ayyifl86j30bo09k3zo.jpg" class="lazyload"></p>
<blockquote>
<p>注意点：</p>
<ol>
<li>在锁LR和受保护资源之间，用一条线关联。保证我们不会用锁去保护其他资源的情况。</li>
<li><strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong></li>
<li>并发领域：不能用多把锁来保护同一资源。（错误！！）</li>
<li>但是可以使用同一把锁来保护多个资源，对应到现实世界就是”包场”。</li>
</ol>
</blockquote>
<h3 id="锁技术：Synchronized"><a href="#锁技术：Synchronized" class="headerlink" title="锁技术：Synchronized"></a>锁技术：Synchronized</h3><blockquote>
<p>Synchronized的隐式规则：</p>
<ol>
<li>当修饰静态方法时候，锁定的是当前类的Class对象。</li>
<li>当修饰是非静态方法的时候，锁定的是当前实例对象this。</li>
</ol>
</blockquote>
<h2 id="互斥锁（下）：如何用一把锁保护多个资源"><a href="#互斥锁（下）：如何用一把锁保护多个资源" class="headerlink" title="互斥锁（下）：如何用一把锁保护多个资源"></a>互斥锁（下）：如何用一把锁保护多个资源</h2><h3 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h3><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer balance;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁：保护余额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object balLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁：保护密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object pwLock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p><strong>用不同的锁对受 保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p>
<p>同一把锁保护多个资源，可能会导致所有的操作都是串行化的。性能很差。</p>
</blockquote>
<h3 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h3><blockquote>
<p>最经典的场景就是：转账场景。假设A给B转账，B给C转账。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(UnSalfeAccount target, Integer amt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例代码，并不能解决转账并发问题。因为锁的细粒度太小，出现了用自家的锁保护他人资源的情况。</p>
<p>我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两 个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗?我们期望是，但实际上并不是。 因为线程 1 锁定的是账户 A 的实例(A.this)，而线程 2 锁定的是账户 B 的实例 (B.this)，所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什 么呢?线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300(线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖)，可能 是 100(线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖)， 就是不可能是 200。</p>
</blockquote>
<ul>
<li><strong>锁能覆盖所有受保护资源</strong></li>
<li>使用类级别的锁，能够解决上面的这个问题。但是性能较差，所有的转账操作都是串行化的。</li>
<li>锁的细粒度大，才能同时保护这个两个资源。</li>
</ul>
<h2 id="一不小心就死锁了，怎么办？"><a href="#一不小心就死锁了，怎么办？" class="headerlink" title="一不小心就死锁了，怎么办？"></a>一不小心就死锁了，怎么办？</h2><h3 id="优化转账类级别锁"><a href="#优化转账类级别锁" class="headerlink" title="优化转账类级别锁"></a>优化转账类级别锁</h3><blockquote>
<p>前面举例子：转账操作：A-&gt;B,B-&gt;C；因为我们使用的类级别的锁，导致所有的转账操作都是串行的，性能非常差。</p>
<p>如果优化呢？我们对所有并发问题，都可以在现实中找到对应的场景来解决问题（建模）。</p>
</blockquote>
<ul>
<li>转账：使用细粒度更小的锁</li>
</ul>
<p>  <img alt="image-20190926085459535" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cmxgb9wmj30el0btwgf.jpg" class="lazyload"></p>
<ul>
<li><pre><code class="java">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(UnSalfeAccount target, Integer amt)</span> </span>{
        <span class="comment">//锁定转出账号</span>
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="comment">//锁定转入账号</span>
            <span class="keyword">synchronized</span> (target) {

                <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) {
                    <span class="keyword">this</span>.balance -= amt;
                    target.balance += amt;
                }
            }
        }
    }

&lt;!--￼<span class="number">3</span>--&gt;
&gt;
&gt; 资源分配器：单例模式，一次申请多个资源。
&gt;
&gt; 但是性能不好，死循环获取资源。
</code></pre>
</li>
</ul>
<h4 id="破坏”不可抢占条件”"><a href="#破坏”不可抢占条件”" class="headerlink" title="破坏”不可抢占条件”"></a>破坏”不可抢占条件”</h4><blockquote>
<p><code>Synchronized</code>关键字无法坐到释放资源，但是Lock关键字可以。</p>
</blockquote>
<h4 id="破坏”循环等待条件”"><a href="#破坏”循环等待条件”" class="headerlink" title="破坏”循环等待条件”"></a>破坏”循环等待条件”</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决死锁：破坏循环等待</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 通过业务实现逻辑控制：对资源进行排序，按序申请资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">D_CycleWaiting_Transfer</span><span class="params">(UnSalfeAccount target, Integer amt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UnSalfeAccount left = <span class="keyword">this</span>;</span><br><span class="line">    UnSalfeAccount right = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left.id &gt; right.id) &#123;</span><br><span class="line">        left = target;</span><br><span class="line">        right = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                target.balance += amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="用”等待-通知”机制优化占有且等待（循环等待）"><a href="#用”等待-通知”机制优化占有且等待（循环等待）" class="headerlink" title="用”等待-通知”机制优化占有且等待（循环等待）"></a>用”等待-通知”机制优化占有且等待（循环等待）</h2><blockquote>
<p>在我们解决死锁问题：采用破坏”占有且等待”条件的时候，写了个死循环同时去获取两把锁。</p>
<p>如果该方法耗时长和程序并发量大的时候，不适用。采用Java等待-通知机制来解决该问题更好。</p>
</blockquote>
<h3 id="利用现实世界的模型来构思程序"><a href="#利用现实世界的模型来构思程序" class="headerlink" title="利用现实世界的模型来构思程序"></a>利用现实世界的模型来构思程序</h3><blockquote>
<p>java等待-通知机制类比现实世界的就医流程很适合。</p>
<p>一个完整的等待-通知机制：线程首先获取到互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态。当要求的条件满足时，通知等待的线程，重新获取互斥锁。</p>
</blockquote>
<h3 id="用Synchronized实现等待-通知机制"><a href="#用Synchronized实现等待-通知机制" class="headerlink" title="用Synchronized实现等待-通知机制"></a>用Synchronized实现等待-通知机制</h3><blockquote>
<p>实现等待-通知机制有多种方式，方式一：Java语言内置的Synchronized配合wati()、notify()、notufyAll()这三个方法。</p>
</blockquote>
<ul>
<li><p>wait()：这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己的独立等待队列。</p>
<ul>
<li><img alt="image-20190929083714820" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7g39x4b6ej30e20ahac7.jpg" class="lazyload"></li>
<li>调用了wait()方法之后，当前线程会被阻塞，释放持有的互斥锁。</li>
</ul>
</li>
<li><p>notify():通知等待队列中的线程，告诉它条件曾经满足过。</p>
<ul>
<li><img alt="image-20190929084003066" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7g3csn9ovj30cz0czq58.jpg" class="lazyload"></li>
</ul>
</li>
<li><blockquote>
<p>需要强调的是调用wait()、notify()、notifyAll()方法操作的是互斥锁的等待队列。如果synchronized锁定的是this，就不能调用target对应这三个方法，并且这三个方法的调用是在synchronized内部被调用，否则jvm会抛出一个异常：java.lang.IllegalMonitorStateException。</p>
</blockquote>
</li>
</ul>
<h3 id="更好的资源分配器"><a href="#更好的资源分配器" class="headerlink" title="更好的资源分配器"></a>更好的资源分配器</h3><ul>
<li><p>使用范式来编写代码：解决条件曾经满足过。</p>
<ul>
<li><pre><code class="java"><span class="keyword">while</span>(条件不满足){
    wait();
}
&lt;!--￼<span class="number">5</span>--&gt;
&gt;
&gt; 上面的编程范式：是mesa管程特有的。
&gt;
&gt; 三个模型的核心区别就是条件满足的时候，如果通知相关线程（管程要求同一时刻只允许一个线程执行）。
&gt;
&gt; <span class="number">1</span>. MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变 量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也 没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的 条件，现在已经不满足了，所以需要以循环方式检验条件变量。</code></pre>
</li>
</ul>
</li>
<li><p>notify()正确使用：</p>
<blockquote>
<p><strong>除非 经过深思熟虑，否则尽量使用 notifyAll()</strong></p>
<p>满足下面三个条件才能使用：</p>
<ol>
<li>所有等待线程拥有相同的等待条件;</li>
<li>所有等待线程被唤醒后，执行相同的操作;</li>
<li>只需要唤醒一个线程。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Java线程（上）：Java线程的生命周期"><a href="#Java线程（上）：Java线程的生命周期" class="headerlink" title="Java线程（上）：Java线程的生命周期"></a>Java线程（上）：Java线程的生命周期</h2><h3 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h3><blockquote>
<p>五种状态：初始状态、可运行状态、运行状态、休眠状态、终止状态。</p>
<p><img alt="image-20190930092008976" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ha4teit2j309q0ctq3o.jpg" class="lazyload"></p>
</blockquote>
<h3 id="Java中线程的生命周期"><a href="#Java中线程的生命周期" class="headerlink" title="Java中线程的生命周期"></a>Java中线程的生命周期</h3><blockquote>
<p>六种状态：NEW(初始化状态)、RUNNABLE(可运行/运行状态)、BLOCKED（阻塞状态）、WAITING(无时限等待)、TIME_WAITING(有时限等待)、TERMINATED(终止状态)</p>
<p><img alt="image-20190930092819935" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hadblpskj30ca0cs759.jpg" class="lazyload"></p>
<ul>
<li>RUNNABLE与BLOCKED的状态转换<ul>
<li>只有一种场景会触发这种转换，等待synchronized的隐式锁。</li>
<li>线程调用阻塞式API时，是否会转换到BLOCKED状态？<ul>
<li>操作系统层面：线程会转换到休眠状态。</li>
<li>JVM层面：线程还是依然保持RUNNABLE状态，JVM层面并不关心操作系统相关的调度。</li>
<li>总结：等待CPU使用权（操作系统：可执行状态）与等待I/O（操作系统：休眠状态），在JVM层面看来没有区别的，都是在等待某个资源都归为RUNNABLE状态</li>
</ul>
</li>
</ul>
</li>
<li>RUNNABLE与WAITING的状态转换<ul>
<li>场景一：在synchronized隐式锁的线程中，调用无参数的Object.wait()方法。</li>
<li>场景二：调用无参数的Thread.join()线程同步的时候。</li>
<li>场景三：调用LockSupport.park()方法，会从runnable到waiting状态。调用LockSupport.unpark(Thread thread)唤醒。</li>
</ul>
</li>
<li>RUNNABLE与TIMED_WAITING的状态转换<ul>
<li>场景一：调用带有超时参数的Thread.sleep(long millis)方法</li>
<li>场景二：在synchronized隐式锁的线程，调用带有超时参数的Object.wait(long timeout)方法</li>
<li>场景三：调用带有超时参数的Thread.join(long mills)方法</li>
<li>场景四：调用带有超时参数的LockSupport.parkNanos(Object blocker,long deadline)</li>
<li>场景五：调用带有超时参数的LockSupport.parkUntil(long deadline)</li>
</ul>
</li>
<li>NEW到RUNNABLE状态<ul>
<li>new就是创建一个线程的方式，常见的有两种方式，一个是extends Thread，另外一个是implements Runable</li>
<li>从new到runnable的状态，调用start()方法</li>
</ul>
</li>
<li>RUNNABLE到TERMINATED状态<ul>
<li>线程执行完run()方法之后，会自动转换到terminated状态。</li>
<li>但是在执行run()方法的时候抛出异常，也会导致线程终止。</li>
<li>我们可以强制中断run()方法，调用interrupt()方法，stop()不建议使用。</li>
<li>stop()和interrupt()方法的区别<ul>
<li>stop()方法是真的杀死线程，不给线程喘息的机会，如果持有synchronized隐式锁也不会释放。类似的方法还有suspend()和resume()方法。都不建议使用了。</li>
<li>interrupt()方法仅仅是通知线程，线程有机会执行一些后续操作，同事也可以无视这个通知。被interrupt的线程，是怎么收到通知的呢？<ul>
<li>一种是异常</li>
<li>另外是主动检测</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Java线程（中）：创建多少线程才是适合的？"><a href="#Java线程（中）：创建多少线程才是适合的？" class="headerlink" title="Java线程（中）：创建多少线程才是适合的？"></a>Java线程（中）：创建多少线程才是适合的？</h2><blockquote>
<p>要回答创建多少线程才是适合的？</p>
<p>首先要分析两个问题：</p>
<ol>
<li>为什么要使用多线程？</li>
<li>多线程的应用场景？</li>
</ol>
</blockquote>
<h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><ul>
<li>多线程实现并发程序的主要手段，能够提升程序性能</li>
<li>度量程序性能指标：延迟和吞吐量<ul>
<li>延迟（时间维度）：发出请求到收到响应这个过程的时间。</li>
<li>吞吐量（空间维度）：单位时间内处理请求的数量。</li>
<li>降低延迟，提高吞吐量。</li>
</ul>
</li>
</ul>
<h3 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h3><ul>
<li><p>如何实现”降低延迟，提高吞吐量”？</p>
<ol>
<li>优化算法</li>
<li>将硬件的性能发挥到极致</li>
<li>总结：在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来讲，就是提升I/O的利用率和cup的利用率。</li>
<li>操作系统层面帮我们解决了单一硬件设备的硬件利用率问题，但是cpu和I/O设备综合利用率的问题，需要我们自己解决，操作系统提供了方案：多线程。</li>
</ol>
</li>
</ul>
<blockquote>
<p><img alt="image-20191009090711272" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7roc528stj30el0a1wez.jpg" class="lazyload"></p>
<p>上面示意图：单线程，I/O设备利用率和cpu利用率只有50%。</p>
<p><img alt="image-20191009091021597" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7rofe8mmkj30fx09paao.jpg" class="lazyload"></p>
<p>多线程，把I/O设备和cpu的利用率都提升到了100%。</p>
<p><strong>如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来 提高吞吐量</strong>。</p>
</blockquote>
<h3 id="创建多少线程适合？"><a href="#创建多少线程适合？" class="headerlink" title="创建多少线程适合？"></a>创建多少线程适合？</h3><blockquote>
<p>需要看应用场景：I/O密集型计算和CPU密集型计算。</p>
<ul>
<li><strong>对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的</strong>。不过在工 程上，<strong>线程的数量一般会设置为“CPU 核数 +1”</strong></li>
<li>对于I/O密集型计算场景：<ul>
<li>单核：最佳线程数 =1 +(I/O 耗时 / CPU 耗时)</li>
<li>多核：最佳线程数 =CPU 核数 * [ 1 +(I/O 耗时 / CPU 耗时)]</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Java线程（下）：为什么局部变量是线程安全的？"><a href="#Java线程（下）：为什么局部变量是线程安全的？" class="headerlink" title="Java线程（下）：为什么局部变量是线程安全的？"></a>Java线程（下）：为什么局部变量是线程安全的？</h2><blockquote>
<p>多个线程同时访问共享变量的时候，会导致并发问题。但是局部变量不共享，因此是线程安全的。没有共享，就没有伤害。</p>
<p>cpu通过cpu的堆栈寄存器的调用栈（里面是栈帧）：来找到方法的参数和返回地址。</p>
<p>栈帧和方法是同生共死。局部变量是放在调用栈里的。一个变量如果想跨越方法的边界， 就必须创建在堆里。</p>
<p>每个线程都有自己独立的调用栈</p>
<p>线程封闭：仅在单线程内访问数据。数据库连接池获取connection就是使用这种解决方案。</p>
</blockquote>
<h2 id="如何用面向对象思想写好并发程序"><a href="#如何用面向对象思想写好并发程序" class="headerlink" title="如何用面向对象思想写好并发程序"></a>如何用面向对象思想写好并发程序</h2><blockquote>
<p>面向对象思想和并发编程本来是没有关系的，是两个领域。但是在java语言里，面向对象思想能够让并发编程变得更简单。从三个方面：</p>
<ol>
<li>封装共享变量</li>
<li>识别共享变量间的约束条件</li>
<li>指定并发访问策略</li>
</ol>
</blockquote>
<h3 id="封装共享变量"><a href="#封装共享变量" class="headerlink" title="封装共享变量"></a>封装共享变量</h3><ul>
<li>面向对象思想里面有一个很重要的特性是<strong>封装</strong>，封装的通俗解释就是<strong>将属性和实现细节封装在对 象内部</strong>，外界对象<strong>只能通过</strong>目标对象提供的<strong>公共方法来间接访问</strong>这些内部属性。</li>
<li><strong>将共享变量作为对象属性封装在内部， 对所有公共方法制定并发访问策略</strong>。</li>
<li><strong>对于 这些不会发生变化的共享变量，建议你用 final 关键字来修饰</strong>。</li>
</ul>
<h3 id="识别共享变量间的约束条件"><a href="#识别共享变量间的约束条件" class="headerlink" title="识别共享变量间的约束条件"></a>识别共享变量间的约束条件</h3><ul>
<li><strong>这些约束条件，决定了并发访问策略</strong></li>
<li><strong>一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定 的并发访问策略南辕北辙</strong>。</li>
<li>基本上都会有 if 语句，所以，一定要特别注意竞态条 件。</li>
</ul>
<h3 id="指定并发访问策略"><a href="#指定并发访问策略" class="headerlink" title="指定并发访问策略"></a>指定并发访问策略</h3><ul>
<li><p>宏观并发访问策略</p>
<ol>
<li>优先使用成熟的工具类:Java SDK 并发包里提供了丰富的工具类，基本上能满足你日常的需 要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便 就能发明成功的。</li>
<li>迫不得已时才使用低级的同步原语:低级的同步原语主要指的是 synchronized、Lock、 Semaphore 等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。</li>
<li>避免过早优化:安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开 发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是:性能 瓶颈不是你想预估就能预估的。</li>
</ol>
</li>
<li><p>Java并发访问策略”三件事”</p>
<ol>
<li><p>避免共享:避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。</p>
</li>
<li><p>不变模式:这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模</p>
<p>式、CSP 模式以及函数式编程的基础都是不变模式。</p>
</li>
<li><p>管程及其他同步工具:Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java</p>
<p>并发包提供的读写锁、并发容器等同步工具会更好。</p>
</li>
</ol>
</li>
</ul>
<h2 id="并发理论总结"><a href="#并发理论总结" class="headerlink" title="并发理论总结"></a>并发理论总结</h2><p>todo</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">http://yoursite.com/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/09/22/2019-09-22-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A1-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java并发编程实战②-并发工具类</span></div></a></div><div class="next-post pull_right"><a href="/2019/09/09/2019-09-09-spring%E4%B8%8Eboot%E6%BA%90%E7%A0%81%E2%91%A3-mvc%E6%A0%B8%E5%BF%83/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Spring与boot源码④-MVC核心</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/17/2019-10-17-java并发编程实战③-并发设计模式/" title="Java并发编程实战③-并发设计模式"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg"><div class="relatedPosts_title">Java并发编程实战③-并发设计模式</div></a></div><div class="relatedPosts_item"><a href="/2019/10/17/2019-10-17-java并发编程实战④-实战分析/" title="Java并发编程实战④-实战分析"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg"><div class="relatedPosts_title">Java并发编程实战④-实战分析</div></a></div><div class="relatedPosts_item"><a href="/2019/09/22/2019-09-22-java并发编程实战②-并发工具类/" title="Java并发编程实战②-并发工具类"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg"><div class="relatedPosts_title">Java并发编程实战②-并发工具类</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2019 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>