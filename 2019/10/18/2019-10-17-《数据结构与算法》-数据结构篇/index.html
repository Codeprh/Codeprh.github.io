<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>《数据结构与算法》-数据结构篇 | Noah</title><meta name="description" content="阅读《数据结构与算法》-数据结构篇"><meta name="keywords" content="数据结构与算法"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="《数据结构与算法》-数据结构篇"><meta name="twitter:description" content="阅读《数据结构与算法》-数据结构篇"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《数据结构与算法》-数据结构篇"><meta property="og:url" content="http://yoursite.com/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="阅读《数据结构与算法》-数据结构篇"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"><link rel="prev" title="《数据结构与算法》-算法篇" href="http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><link rel="next" title="Java并发编程实战③-并发设计模式" href="http://yoursite.com/2019/10/17/2019-10-17-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A2-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#《数据结构与算法》-数据结构篇"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">《数据结构与算法》-数据结构篇</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#总览-数据结构"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">总览-数据结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数学科普"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">数学科普</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#科普内存存储数据大小"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">科普内存存储数据大小</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#取余和求模"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">取余和求模</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#时间复杂度科普"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">时间复杂度科普</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#素数"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">素数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#题目汇总"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">题目汇总</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#链表："><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">链表：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#栈："><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">栈：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#队列："><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">队列：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#递归"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">递归</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#哨兵"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">哨兵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#快速排序"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">快速排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线性排序"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">线性排序</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲数组：为什么很多编程语言中数组都从0开始编号"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">讲数组：为什么很多编程语言中数组都从0开始编号</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组：如何实现随机访问"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">数组：如何实现随机访问</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组：如何解决数组”插入”和”删除”低效"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">数组：如何解决数组”插入”和”删除”低效</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数据总览"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">数据总览</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲链表（上）：如何实现LRU缓存淘汰算法"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">讲链表（上）：如何实现LRU缓存淘汰算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#链表"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组、容器、链表的区别"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">数组、容器、链表的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-1"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲链表（下）：如何轻松写出正确的链表代码"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">讲链表（下）：如何轻松写出正确的链表代码</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#技巧三-利用哨兵简化实现难度"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">技巧三:利用哨兵简化实现难度</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲栈：如何实现浏览器的前进和后退功能"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">讲栈：如何实现浏览器的前进和后退功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲队列：队列在线程池等有限资源池中的应用"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">讲队列：队列在线程池等有限资源池中的应用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#循环队列"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">循环队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#阻塞队列和并发队列"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">阻塞队列和并发队列</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲递归：如何用三行代码找到“最终推荐人”"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">讲递归：如何用三行代码找到“最终推荐人”</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解递归"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">如何理解递归</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#怎么将递归代码改写为非递归代码"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">怎么将递归代码改写为非递归代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-2"><span class="toc_mobile_items-number">10.3.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-1"><span class="toc_mobile_items-number">10.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲排序（上）：为什么插入排序比冒泡排序更受欢迎"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">讲排序（上）：为什么插入排序比冒泡排序更受欢迎</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何分析一个”排序算法”？"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">如何分析一个”排序算法”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#冒泡排序"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">冒泡排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#插入排序"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#选择排序"><span class="toc_mobile_items-number">11.4.</span> <span class="toc_mobile_items-text">选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-3"><span class="toc_mobile_items-number">11.5.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-2"><span class="toc_mobile_items-number">11.6.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲排序（下）：如何用快排思想在O-n-内查找第K大元素"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">讲排序（下）：如何用快排思想在O(n)内查找第K大元素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#归并排序"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">归并排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#快速排序（快排）"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">快速排序（快排）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#归并和快排区别"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">归并和快排区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-4"><span class="toc_mobile_items-number">12.4.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲线性排序：如何根据年龄给100万用户数据排序"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">讲线性排序：如何根据年龄给100万用户数据排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#桶排序-Bucket-sort"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text">桶排序(Bucket sort)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？"><span class="toc_mobile_items-number">13.1.1.</span> <span class="toc_mobile_items-text">桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#计数排序-Counting-Sort"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text">计数排序(Counting Sort)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基数排序-Radix-sort"><span class="toc_mobile_items-number">13.3.</span> <span class="toc_mobile_items-text">基数排序(Radix sort )</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-3"><span class="toc_mobile_items-number">13.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲排序优化：如何实现一个通用的、高性能的排序函数"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">讲排序优化：如何实现一个通用的、高性能的排序函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何选择合适的排序算法"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text">如何选择合适的排序算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何优化快速排序？"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text">如何优化快速排序？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#举例分析排序函数qsort"><span class="toc_mobile_items-number">14.3.</span> <span class="toc_mobile_items-text">举例分析排序函数qsort()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲二分查找（上）：如何用最省内存的方式实现快速查找功能"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">讲二分查找（上）：如何用最省内存的方式实现快速查找功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二分查找思想"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">二分查找思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二分查找算法惊人O-logn"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text">二分查找算法惊人O(logn)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二分查找的递归与非递归实现"><span class="toc_mobile_items-number">15.3.</span> <span class="toc_mobile_items-text">二分查找的递归与非递归实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二分查找应用场景的局限性"><span class="toc_mobile_items-number">15.4.</span> <span class="toc_mobile_items-text">二分查找应用场景的局限性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲二分查找（下）：如何快速定位IP对应的省份地址"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">讲二分查找（下）：如何快速定位IP对应的省份地址</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#变体1：查找第一个值等于给定值的元素"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text">变体1：查找第一个值等于给定值的元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#变体2：查找最后一个值等于给定值的元素"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text">变体2：查找最后一个值等于给定值的元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#变体3：查找第一个大于等于给定值的元素"><span class="toc_mobile_items-number">16.3.</span> <span class="toc_mobile_items-text">变体3：查找第一个大于等于给定值的元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#变体4：查找最后一个小于等于给定值的元素"><span class="toc_mobile_items-number">16.4.</span> <span class="toc_mobile_items-text">变体4：查找最后一个小于等于给定值的元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-5"><span class="toc_mobile_items-number">16.5.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内容总结"><span class="toc_mobile_items-number">16.6.</span> <span class="toc_mobile_items-text">内容总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲跳表：为什么Redis一定要用跳表来实现有序集合"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">讲跳表：为什么Redis一定要用跳表来实现有序集合</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解”跳表”？"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text">如何理解”跳表”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实际开发：空间换时间思想"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text">实际开发：空间换时间思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#跳表：高效的动态插入和删除O-logn"><span class="toc_mobile_items-number">17.3.</span> <span class="toc_mobile_items-text">跳表：高效的动态插入和删除O(logn)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#跳表：索引动态更新"><span class="toc_mobile_items-number">17.4.</span> <span class="toc_mobile_items-text">跳表：索引动态更新</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-6"><span class="toc_mobile_items-number">17.5.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#散列思想"><span class="toc_mobile_items-number">18.1.</span> <span class="toc_mobile_items-text">散列思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#散列函数"><span class="toc_mobile_items-number">18.2.</span> <span class="toc_mobile_items-text">散列函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#散列冲突"><span class="toc_mobile_items-number">18.3.</span> <span class="toc_mobile_items-text">散列冲突</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#开放寻址法"><span class="toc_mobile_items-number">18.4.</span> <span class="toc_mobile_items-text">开放寻址法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#链表法"><span class="toc_mobile_items-number">18.5.</span> <span class="toc_mobile_items-text">链表法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解决"><span class="toc_mobile_items-number">18.6.</span> <span class="toc_mobile_items-text">问题解决</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲散列表（中）：如何打造一个工业级水平的散列表"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">讲散列表（中）：如何打造一个工业级水平的散列表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何设计散列函数？"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text">如何设计散列函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#装载因子过大了怎么办？"><span class="toc_mobile_items-number">19.2.</span> <span class="toc_mobile_items-text">装载因子过大了怎么办？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何避免低效地扩容？"><span class="toc_mobile_items-number">19.3.</span> <span class="toc_mobile_items-text">如何避免低效地扩容？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何选择冲突解决办法？"><span class="toc_mobile_items-number">19.4.</span> <span class="toc_mobile_items-text">如何选择冲突解决办法？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#开放寻址法-1"><span class="toc_mobile_items-number">19.4.1.</span> <span class="toc_mobile_items-text">开放寻址法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#链表法-1"><span class="toc_mobile_items-number">19.4.2.</span> <span class="toc_mobile_items-text">链表法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java中的HashMap分析"><span class="toc_mobile_items-number">19.5.</span> <span class="toc_mobile_items-text">Java中的HashMap分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-4"><span class="toc_mobile_items-number">19.6.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲散列表（下）：为什么散列表和链表经常会一起使用"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">讲散列表（下）：为什么散列表和链表经常会一起使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#栗子1：LRU缓存淘汰算法"><span class="toc_mobile_items-number">20.1.</span> <span class="toc_mobile_items-text">栗子1：LRU缓存淘汰算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#栗子2：Redis有序集合"><span class="toc_mobile_items-number">20.2.</span> <span class="toc_mobile_items-text">栗子2：Redis有序集合</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#栗子3：Java-LinkedHashMap"><span class="toc_mobile_items-number">20.3.</span> <span class="toc_mobile_items-text">栗子3：Java LinkedHashMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内容总结-1"><span class="toc_mobile_items-number">20.4.</span> <span class="toc_mobile_items-text">内容总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲哈希算法（上）：如何防止数据库中的用户信息被脱库"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text">讲哈希算法（上）：如何防止数据库中的用户信息被脱库</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是哈希算法？"><span class="toc_mobile_items-number">21.1.</span> <span class="toc_mobile_items-text">什么是哈希算法？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用一：安全加密"><span class="toc_mobile_items-number">21.2.</span> <span class="toc_mobile_items-text">应用一：安全加密</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用二：唯一标识"><span class="toc_mobile_items-number">21.3.</span> <span class="toc_mobile_items-text">应用二：唯一标识</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用三：数据校验"><span class="toc_mobile_items-number">21.4.</span> <span class="toc_mobile_items-text">应用三：数据校验</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用四：散列函数"><span class="toc_mobile_items-number">21.5.</span> <span class="toc_mobile_items-text">应用四：散列函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲哈希算法（下）：哈希算法在分布式系统中有哪些应用"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text">讲哈希算法（下）：哈希算法在分布式系统中有哪些应用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用五：负载均衡"><span class="toc_mobile_items-number">22.1.</span> <span class="toc_mobile_items-text">应用五：负载均衡</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用六：数据分片"><span class="toc_mobile_items-number">22.2.</span> <span class="toc_mobile_items-text">应用六：数据分片</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何统计大文件”搜索关键词”出现的次数？"><span class="toc_mobile_items-number">22.2.1.</span> <span class="toc_mobile_items-text">如何统计大文件”搜索关键词”出现的次数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何快速判断图片是否存在图库中？"><span class="toc_mobile_items-number">22.2.2.</span> <span class="toc_mobile_items-text">如何快速判断图片是否存在图库中？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#应用七：分布式存储"><span class="toc_mobile_items-number">22.3.</span> <span class="toc_mobile_items-text">应用七：分布式存储</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲二叉树基础（上）：什么样的二叉树适合用数组来存储"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text">讲二叉树基础（上）：什么样的二叉树适合用数组来存储</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#树（Tree）"><span class="toc_mobile_items-number">23.1.</span> <span class="toc_mobile_items-text">树（Tree）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#树相关的概念"><span class="toc_mobile_items-number">23.1.1.</span> <span class="toc_mobile_items-text">树相关的概念</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二叉树（Binary-Tree）"><span class="toc_mobile_items-number">23.2.</span> <span class="toc_mobile_items-text">二叉树（Binary Tree）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉树的概念"><span class="toc_mobile_items-number">23.2.1.</span> <span class="toc_mobile_items-text">二叉树的概念</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何表示（存储）一棵二叉树？"><span class="toc_mobile_items-number">23.3.</span> <span class="toc_mobile_items-text">如何表示（存储）一棵二叉树？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二叉树的遍历"><span class="toc_mobile_items-number">23.4.</span> <span class="toc_mobile_items-text">二叉树的遍历</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text">讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二叉查找树（Binary-Search-Tree）"><span class="toc_mobile_items-number">24.1.</span> <span class="toc_mobile_items-text">二叉查找树（Binary Search Tree）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉查找树的概念"><span class="toc_mobile_items-number">24.1.1.</span> <span class="toc_mobile_items-text">二叉查找树的概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉查找树的查找"><span class="toc_mobile_items-number">24.1.2.</span> <span class="toc_mobile_items-text">二叉查找树的查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉查找树的插入"><span class="toc_mobile_items-number">24.1.3.</span> <span class="toc_mobile_items-text">二叉查找树的插入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉查找树的删除"><span class="toc_mobile_items-number">24.1.4.</span> <span class="toc_mobile_items-text">二叉查找树的删除</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二叉查找树的其他操作"><span class="toc_mobile_items-number">24.1.5.</span> <span class="toc_mobile_items-text">二叉查找树的其他操作</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#支持重复数据的二叉查找树"><span class="toc_mobile_items-number">24.2.</span> <span class="toc_mobile_items-text">支持重复数据的二叉查找树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二叉查找树的时间复杂度分析"><span class="toc_mobile_items-number">24.3.</span> <span class="toc_mobile_items-text">二叉查找树的时间复杂度分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-7"><span class="toc_mobile_items-number">24.4.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲红黑树（上）：为什么工程中都用红黑树这种二叉树"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text">讲红黑树（上）：为什么工程中都用红黑树这种二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是”平衡二叉查找树”？"><span class="toc_mobile_items-number">25.1.</span> <span class="toc_mobile_items-text">什么是”平衡二叉查找树”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何定义一棵”红黑树”？"><span class="toc_mobile_items-number">25.2.</span> <span class="toc_mobile_items-text">如何定义一棵”红黑树”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-8"><span class="toc_mobile_items-number">25.3.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text">Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-5"><span class="toc_mobile_items-number">26.1.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲堆和堆排序：为什么说堆排序没有快速排序快"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text">讲堆和堆排序：为什么说堆排序没有快速排序快</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解”堆”"><span class="toc_mobile_items-number">27.1.</span> <span class="toc_mobile_items-text">如何理解”堆”?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何实现一个堆？"><span class="toc_mobile_items-number">27.2.</span> <span class="toc_mobile_items-text">如何实现一个堆？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#往堆中插入一个元素"><span class="toc_mobile_items-number">27.2.1.</span> <span class="toc_mobile_items-text">往堆中插入一个元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#删除堆顶元素"><span class="toc_mobile_items-number">27.2.2.</span> <span class="toc_mobile_items-text">删除堆顶元素</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何基于堆实现排序"><span class="toc_mobile_items-number">27.3.</span> <span class="toc_mobile_items-text">如何基于堆实现排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#建堆"><span class="toc_mobile_items-number">27.3.1.</span> <span class="toc_mobile_items-text">建堆</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#排序"><span class="toc_mobile_items-number">27.3.2.</span> <span class="toc_mobile_items-text">排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分析"><span class="toc_mobile_items-number">27.3.3.</span> <span class="toc_mobile_items-text">分析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解析"><span class="toc_mobile_items-number">27.4.</span> <span class="toc_mobile_items-text">问题解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-6"><span class="toc_mobile_items-number">27.5.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲堆的应用：如何快速获取到Top10最热门的搜索关键词"><span class="toc_mobile_items-number">28.</span> <span class="toc_mobile_items-text">讲堆的应用：如何快速获取到Top10最热门的搜索关键词</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆的应用一：优先级队列"><span class="toc_mobile_items-number">28.1.</span> <span class="toc_mobile_items-text">堆的应用一：优先级队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#合并有序小文件"><span class="toc_mobile_items-number">28.1.1.</span> <span class="toc_mobile_items-text">合并有序小文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#高性能定时器"><span class="toc_mobile_items-number">28.1.2.</span> <span class="toc_mobile_items-text">高性能定时器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆的应用二：利用堆求Top-K"><span class="toc_mobile_items-number">28.2.</span> <span class="toc_mobile_items-text">堆的应用二：利用堆求Top K</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆的应用三：利用堆求中位数"><span class="toc_mobile_items-number">28.3.</span> <span class="toc_mobile_items-text">堆的应用三：利用堆求中位数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何快速求接口的99-响应时间？"><span class="toc_mobile_items-number">28.3.1.</span> <span class="toc_mobile_items-text">如何快速求接口的99%响应时间？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-9"><span class="toc_mobile_items-number">28.4.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-7"><span class="toc_mobile_items-number">28.5.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系"><span class="toc_mobile_items-number">29.</span> <span class="toc_mobile_items-text">Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情"><span class="toc_mobile_items-number">29.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系"><span class="toc_mobile_items-number">30.</span> <span class="toc_mobile_items-text">Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情-1"><span class="toc_mobile_items-number">30.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲字符串匹配基础-上-如何借助哈希算法实现高效字符串匹配"><span class="toc_mobile_items-number">31.</span> <span class="toc_mobile_items-text">讲字符串匹配基础(上):如何借助哈希算法实现高效字符串匹配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#BF算法"><span class="toc_mobile_items-number">31.1.</span> <span class="toc_mobile_items-text">BF算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RK算法"><span class="toc_mobile_items-number">31.2.</span> <span class="toc_mobile_items-text">RK算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-8"><span class="toc_mobile_items-number">31.3.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能"><span class="toc_mobile_items-number">32.</span> <span class="toc_mobile_items-text">Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情-2"><span class="toc_mobile_items-number">32.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo-讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法"><span class="toc_mobile_items-number">33.</span> <span class="toc_mobile_items-text">Todo:讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情-3"><span class="toc_mobile_items-number">33.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo-讲Trie树：如何实现搜索引擎的搜索关键词提示功能"><span class="toc_mobile_items-number">34.</span> <span class="toc_mobile_items-text">Todo:讲Trie树：如何实现搜索引擎的搜索关键词提示功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情-4"><span class="toc_mobile_items-number">34.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Todo-讲AC自动机：如何用多模式串匹配实现敏感词过滤功能"><span class="toc_mobile_items-number">35.</span> <span class="toc_mobile_items-text">Todo:讲AC自动机：如何用多模式串匹配实现敏感词过滤功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要完成的事情-5"><span class="toc_mobile_items-number">35.1.</span> <span class="toc_mobile_items-text">需要完成的事情</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#《数据结构与算法》-数据结构篇"><span class="toc-number">1.</span> <span class="toc-text">《数据结构与算法》-数据结构篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总览-数据结构"><span class="toc-number">2.</span> <span class="toc-text">总览-数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数学科普"><span class="toc-number">3.</span> <span class="toc-text">数学科普</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#科普内存存储数据大小"><span class="toc-number">3.1.</span> <span class="toc-text">科普内存存储数据大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取余和求模"><span class="toc-number">3.2.</span> <span class="toc-text">取余和求模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间复杂度科普"><span class="toc-number">3.3.</span> <span class="toc-text">时间复杂度科普</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#素数"><span class="toc-number">3.4.</span> <span class="toc-text">素数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#题目汇总"><span class="toc-number">4.</span> <span class="toc-text">题目汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#链表："><span class="toc-number">4.1.</span> <span class="toc-text">链表：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈："><span class="toc-number">4.2.</span> <span class="toc-text">栈：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列："><span class="toc-number">4.3.</span> <span class="toc-text">队列：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-number">4.4.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哨兵"><span class="toc-number">4.5.</span> <span class="toc-text">哨兵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序"><span class="toc-number">4.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性排序"><span class="toc-number">4.7.</span> <span class="toc-text">线性排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲数组：为什么很多编程语言中数组都从0开始编号"><span class="toc-number">5.</span> <span class="toc-text">讲数组：为什么很多编程语言中数组都从0开始编号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组：如何实现随机访问"><span class="toc-number">5.1.</span> <span class="toc-text">数组：如何实现随机访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组：如何解决数组”插入”和”删除”低效"><span class="toc-number">5.2.</span> <span class="toc-text">数组：如何解决数组”插入”和”删除”低效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据总览"><span class="toc-number">5.3.</span> <span class="toc-text">数据总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答"><span class="toc-number">5.4.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲链表（上）：如何实现LRU缓存淘汰算法"><span class="toc-number">6.</span> <span class="toc-text">讲链表（上）：如何实现LRU缓存淘汰算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">6.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组、容器、链表的区别"><span class="toc-number">6.2.</span> <span class="toc-text">数组、容器、链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-1"><span class="toc-number">6.3.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲链表（下）：如何轻松写出正确的链表代码"><span class="toc-number">7.</span> <span class="toc-text">讲链表（下）：如何轻松写出正确的链表代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧三-利用哨兵简化实现难度"><span class="toc-number">7.1.</span> <span class="toc-text">技巧三:利用哨兵简化实现难度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲栈：如何实现浏览器的前进和后退功能"><span class="toc-number">8.</span> <span class="toc-text">讲栈：如何实现浏览器的前进和后退功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲队列：队列在线程池等有限资源池中的应用"><span class="toc-number">9.</span> <span class="toc-text">讲队列：队列在线程池等有限资源池中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#循环队列"><span class="toc-number">9.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列和并发队列"><span class="toc-number">9.2.</span> <span class="toc-text">阻塞队列和并发队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲递归：如何用三行代码找到“最终推荐人”"><span class="toc-number">10.</span> <span class="toc-text">讲递归：如何用三行代码找到“最终推荐人”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解递归"><span class="toc-number">10.1.</span> <span class="toc-text">如何理解递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么将递归代码改写为非递归代码"><span class="toc-number">10.2.</span> <span class="toc-text">怎么将递归代码改写为非递归代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-2"><span class="toc-number">10.3.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">10.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲排序（上）：为什么插入排序比冒泡排序更受欢迎"><span class="toc-number">11.</span> <span class="toc-text">讲排序（上）：为什么插入排序比冒泡排序更受欢迎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何分析一个”排序算法”？"><span class="toc-number">11.1.</span> <span class="toc-text">如何分析一个”排序算法”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序"><span class="toc-number">11.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-number">11.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-number">11.4.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-3"><span class="toc-number">11.5.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-2"><span class="toc-number">11.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲排序（下）：如何用快排思想在O-n-内查找第K大元素"><span class="toc-number">12.</span> <span class="toc-text">讲排序（下）：如何用快排思想在O(n)内查找第K大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">12.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序（快排）"><span class="toc-number">12.2.</span> <span class="toc-text">快速排序（快排）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并和快排区别"><span class="toc-number">12.3.</span> <span class="toc-text">归并和快排区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-4"><span class="toc-number">12.4.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲线性排序：如何根据年龄给100万用户数据排序"><span class="toc-number">13.</span> <span class="toc-text">讲线性排序：如何根据年龄给100万用户数据排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排序-Bucket-sort"><span class="toc-number">13.1.</span> <span class="toc-text">桶排序(Bucket sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？"><span class="toc-number">13.1.1.</span> <span class="toc-text">桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数排序-Counting-Sort"><span class="toc-number">13.2.</span> <span class="toc-text">计数排序(Counting Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序-Radix-sort"><span class="toc-number">13.3.</span> <span class="toc-text">基数排序(Radix sort )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-3"><span class="toc-number">13.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲排序优化：如何实现一个通用的、高性能的排序函数"><span class="toc-number">14.</span> <span class="toc-text">讲排序优化：如何实现一个通用的、高性能的排序函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何选择合适的排序算法"><span class="toc-number">14.1.</span> <span class="toc-text">如何选择合适的排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何优化快速排序？"><span class="toc-number">14.2.</span> <span class="toc-text">如何优化快速排序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#举例分析排序函数qsort"><span class="toc-number">14.3.</span> <span class="toc-text">举例分析排序函数qsort()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲二分查找（上）：如何用最省内存的方式实现快速查找功能"><span class="toc-number">15.</span> <span class="toc-text">讲二分查找（上）：如何用最省内存的方式实现快速查找功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找思想"><span class="toc-number">15.1.</span> <span class="toc-text">二分查找思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找算法惊人O-logn"><span class="toc-number">15.2.</span> <span class="toc-text">二分查找算法惊人O(logn)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找的递归与非递归实现"><span class="toc-number">15.3.</span> <span class="toc-text">二分查找的递归与非递归实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找应用场景的局限性"><span class="toc-number">15.4.</span> <span class="toc-text">二分查找应用场景的局限性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲二分查找（下）：如何快速定位IP对应的省份地址"><span class="toc-number">16.</span> <span class="toc-text">讲二分查找（下）：如何快速定位IP对应的省份地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#变体1：查找第一个值等于给定值的元素"><span class="toc-number">16.1.</span> <span class="toc-text">变体1：查找第一个值等于给定值的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变体2：查找最后一个值等于给定值的元素"><span class="toc-number">16.2.</span> <span class="toc-text">变体2：查找最后一个值等于给定值的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变体3：查找第一个大于等于给定值的元素"><span class="toc-number">16.3.</span> <span class="toc-text">变体3：查找第一个大于等于给定值的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变体4：查找最后一个小于等于给定值的元素"><span class="toc-number">16.4.</span> <span class="toc-text">变体4：查找最后一个小于等于给定值的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-5"><span class="toc-number">16.5.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容总结"><span class="toc-number">16.6.</span> <span class="toc-text">内容总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲跳表：为什么Redis一定要用跳表来实现有序集合"><span class="toc-number">17.</span> <span class="toc-text">讲跳表：为什么Redis一定要用跳表来实现有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解”跳表”？"><span class="toc-number">17.1.</span> <span class="toc-text">如何理解”跳表”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际开发：空间换时间思想"><span class="toc-number">17.2.</span> <span class="toc-text">实际开发：空间换时间思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳表：高效的动态插入和删除O-logn"><span class="toc-number">17.3.</span> <span class="toc-text">跳表：高效的动态插入和删除O(logn)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳表：索引动态更新"><span class="toc-number">17.4.</span> <span class="toc-text">跳表：索引动态更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-6"><span class="toc-number">17.5.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的"><span class="toc-number">18.</span> <span class="toc-text">讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#散列思想"><span class="toc-number">18.1.</span> <span class="toc-text">散列思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#散列函数"><span class="toc-number">18.2.</span> <span class="toc-text">散列函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#散列冲突"><span class="toc-number">18.3.</span> <span class="toc-text">散列冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开放寻址法"><span class="toc-number">18.4.</span> <span class="toc-text">开放寻址法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表法"><span class="toc-number">18.5.</span> <span class="toc-text">链表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解决"><span class="toc-number">18.6.</span> <span class="toc-text">问题解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲散列表（中）：如何打造一个工业级水平的散列表"><span class="toc-number">19.</span> <span class="toc-text">讲散列表（中）：如何打造一个工业级水平的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何设计散列函数？"><span class="toc-number">19.1.</span> <span class="toc-text">如何设计散列函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装载因子过大了怎么办？"><span class="toc-number">19.2.</span> <span class="toc-text">装载因子过大了怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何避免低效地扩容？"><span class="toc-number">19.3.</span> <span class="toc-text">如何避免低效地扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何选择冲突解决办法？"><span class="toc-number">19.4.</span> <span class="toc-text">如何选择冲突解决办法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开放寻址法-1"><span class="toc-number">19.4.1.</span> <span class="toc-text">开放寻址法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表法-1"><span class="toc-number">19.4.2.</span> <span class="toc-text">链表法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中的HashMap分析"><span class="toc-number">19.5.</span> <span class="toc-text">Java中的HashMap分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-4"><span class="toc-number">19.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲散列表（下）：为什么散列表和链表经常会一起使用"><span class="toc-number">20.</span> <span class="toc-text">讲散列表（下）：为什么散列表和链表经常会一起使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栗子1：LRU缓存淘汰算法"><span class="toc-number">20.1.</span> <span class="toc-text">栗子1：LRU缓存淘汰算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栗子2：Redis有序集合"><span class="toc-number">20.2.</span> <span class="toc-text">栗子2：Redis有序集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栗子3：Java-LinkedHashMap"><span class="toc-number">20.3.</span> <span class="toc-text">栗子3：Java LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容总结-1"><span class="toc-number">20.4.</span> <span class="toc-text">内容总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲哈希算法（上）：如何防止数据库中的用户信息被脱库"><span class="toc-number">21.</span> <span class="toc-text">讲哈希算法（上）：如何防止数据库中的用户信息被脱库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是哈希算法？"><span class="toc-number">21.1.</span> <span class="toc-text">什么是哈希算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用一：安全加密"><span class="toc-number">21.2.</span> <span class="toc-text">应用一：安全加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用二：唯一标识"><span class="toc-number">21.3.</span> <span class="toc-text">应用二：唯一标识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用三：数据校验"><span class="toc-number">21.4.</span> <span class="toc-text">应用三：数据校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用四：散列函数"><span class="toc-number">21.5.</span> <span class="toc-text">应用四：散列函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲哈希算法（下）：哈希算法在分布式系统中有哪些应用"><span class="toc-number">22.</span> <span class="toc-text">讲哈希算法（下）：哈希算法在分布式系统中有哪些应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#应用五：负载均衡"><span class="toc-number">22.1.</span> <span class="toc-text">应用五：负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用六：数据分片"><span class="toc-number">22.2.</span> <span class="toc-text">应用六：数据分片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何统计大文件”搜索关键词”出现的次数？"><span class="toc-number">22.2.1.</span> <span class="toc-text">如何统计大文件”搜索关键词”出现的次数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何快速判断图片是否存在图库中？"><span class="toc-number">22.2.2.</span> <span class="toc-text">如何快速判断图片是否存在图库中？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用七：分布式存储"><span class="toc-number">22.3.</span> <span class="toc-text">应用七：分布式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲二叉树基础（上）：什么样的二叉树适合用数组来存储"><span class="toc-number">23.</span> <span class="toc-text">讲二叉树基础（上）：什么样的二叉树适合用数组来存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树（Tree）"><span class="toc-number">23.1.</span> <span class="toc-text">树（Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树相关的概念"><span class="toc-number">23.1.1.</span> <span class="toc-text">树相关的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树（Binary-Tree）"><span class="toc-number">23.2.</span> <span class="toc-text">二叉树（Binary Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的概念"><span class="toc-number">23.2.1.</span> <span class="toc-text">二叉树的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何表示（存储）一棵二叉树？"><span class="toc-number">23.3.</span> <span class="toc-text">如何表示（存储）一棵二叉树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">23.4.</span> <span class="toc-text">二叉树的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树"><span class="toc-number">24.</span> <span class="toc-text">讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉查找树（Binary-Search-Tree）"><span class="toc-number">24.1.</span> <span class="toc-text">二叉查找树（Binary Search Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树的概念"><span class="toc-number">24.1.1.</span> <span class="toc-text">二叉查找树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树的查找"><span class="toc-number">24.1.2.</span> <span class="toc-text">二叉查找树的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树的插入"><span class="toc-number">24.1.3.</span> <span class="toc-text">二叉查找树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树的删除"><span class="toc-number">24.1.4.</span> <span class="toc-text">二叉查找树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树的其他操作"><span class="toc-number">24.1.5.</span> <span class="toc-text">二叉查找树的其他操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持重复数据的二叉查找树"><span class="toc-number">24.2.</span> <span class="toc-text">支持重复数据的二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉查找树的时间复杂度分析"><span class="toc-number">24.3.</span> <span class="toc-text">二叉查找树的时间复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-7"><span class="toc-number">24.4.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲红黑树（上）：为什么工程中都用红黑树这种二叉树"><span class="toc-number">25.</span> <span class="toc-text">讲红黑树（上）：为什么工程中都用红黑树这种二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是”平衡二叉查找树”？"><span class="toc-number">25.1.</span> <span class="toc-text">什么是”平衡二叉查找树”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何定义一棵”红黑树”？"><span class="toc-number">25.2.</span> <span class="toc-text">如何定义一棵”红黑树”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-8"><span class="toc-number">25.3.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树"><span class="toc-number">26.</span> <span class="toc-text">Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-5"><span class="toc-number">26.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲堆和堆排序：为什么说堆排序没有快速排序快"><span class="toc-number">27.</span> <span class="toc-text">讲堆和堆排序：为什么说堆排序没有快速排序快</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解”堆”"><span class="toc-number">27.1.</span> <span class="toc-text">如何理解”堆”?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现一个堆？"><span class="toc-number">27.2.</span> <span class="toc-text">如何实现一个堆？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#往堆中插入一个元素"><span class="toc-number">27.2.1.</span> <span class="toc-text">往堆中插入一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除堆顶元素"><span class="toc-number">27.2.2.</span> <span class="toc-text">删除堆顶元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何基于堆实现排序"><span class="toc-number">27.3.</span> <span class="toc-text">如何基于堆实现排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#建堆"><span class="toc-number">27.3.1.</span> <span class="toc-text">建堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">27.3.2.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析"><span class="toc-number">27.3.3.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解析"><span class="toc-number">27.4.</span> <span class="toc-text">问题解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-6"><span class="toc-number">27.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲堆的应用：如何快速获取到Top10最热门的搜索关键词"><span class="toc-number">28.</span> <span class="toc-text">讲堆的应用：如何快速获取到Top10最热门的搜索关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用一：优先级队列"><span class="toc-number">28.1.</span> <span class="toc-text">堆的应用一：优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#合并有序小文件"><span class="toc-number">28.1.1.</span> <span class="toc-text">合并有序小文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高性能定时器"><span class="toc-number">28.1.2.</span> <span class="toc-text">高性能定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用二：利用堆求Top-K"><span class="toc-number">28.2.</span> <span class="toc-text">堆的应用二：利用堆求Top K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用三：利用堆求中位数"><span class="toc-number">28.3.</span> <span class="toc-text">堆的应用三：利用堆求中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何快速求接口的99-响应时间？"><span class="toc-number">28.3.1.</span> <span class="toc-text">如何快速求接口的99%响应时间？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-9"><span class="toc-number">28.4.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-7"><span class="toc-number">28.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系"><span class="toc-number">29.</span> <span class="toc-text">Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情"><span class="toc-number">29.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系"><span class="toc-number">30.</span> <span class="toc-text">Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情-1"><span class="toc-number">30.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲字符串匹配基础-上-如何借助哈希算法实现高效字符串匹配"><span class="toc-number">31.</span> <span class="toc-text">讲字符串匹配基础(上):如何借助哈希算法实现高效字符串匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BF算法"><span class="toc-number">31.1.</span> <span class="toc-text">BF算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RK算法"><span class="toc-number">31.2.</span> <span class="toc-text">RK算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-8"><span class="toc-number">31.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能"><span class="toc-number">32.</span> <span class="toc-text">Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情-2"><span class="toc-number">32.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo-讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法"><span class="toc-number">33.</span> <span class="toc-text">Todo:讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情-3"><span class="toc-number">33.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo-讲Trie树：如何实现搜索引擎的搜索关键词提示功能"><span class="toc-number">34.</span> <span class="toc-text">Todo:讲Trie树：如何实现搜索引擎的搜索关键词提示功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情-4"><span class="toc-number">34.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Todo-讲AC自动机：如何用多模式串匹配实现敏感词过滤功能"><span class="toc-number">35.</span> <span class="toc-text">Todo:讲AC自动机：如何用多模式串匹配实现敏感词过滤功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要完成的事情-5"><span class="toc-number">35.1.</span> <span class="toc-text">需要完成的事情</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">《数据结构与算法》-数据结构篇</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-18<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-06</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">26k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 83 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="《数据结构与算法》-数据结构篇"><a href="#《数据结构与算法》-数据结构篇" class="headerlink" title="《数据结构与算法》-数据结构篇"></a>《数据结构与算法》-数据结构篇</h1><h1 id="总览-数据结构"><a href="#总览-数据结构" class="headerlink" title="总览-数据结构"></a>总览-数据结构</h1><blockquote>
<ol>
<li>讲复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗</li>
<li>讲复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</li>
<li>讲数组：为什么很多编程语言中数组都从0开始编号</li>
<li>讲链表（上）：如何实现LRU缓存淘汰算法</li>
<li>讲链表（下）：如何轻松写出正确的链表代码</li>
<li>讲栈：如何实现浏览器的前进和后退功能</li>
<li>讲队列：队列在线程池等有限资源池中的应用</li>
<li>讲递归：如何用三行代码找到“最终推荐人”</li>
<li>讲排序（上）：为什么插入排序比冒泡排序更受欢迎</li>
<li>讲排序（下）：如何用快排思想在O(n)内查找第K大元素</li>
<li>讲线性排序：如何根据年龄给100万用户数据排序</li>
<li>讲排序优化：如何实现一个通用的、高性能的排序函数</li>
<li>讲二分查找（上）：如何用最省内存的方式实现快速查找功能</li>
<li>讲二分查找（下）：如何快速定位IP对应的省份地址</li>
<li>讲跳表：为什么Redis一定要用跳表来实现有序集合</li>
<li>讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的</li>
<li>讲散列表（中）：如何打造一个工业级水平的散列表</li>
<li>讲散列表（下）：为什么散列表和链表经常会一起使用</li>
<li>讲哈希算法（上）：如何防止数据库中的用户信息被脱库</li>
<li>讲哈希算法（下）：哈希算法在分布式系统中有哪些应用</li>
<li>讲二叉树基础（上）：什么样的二叉树适合用数组来存储</li>
<li>讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树</li>
<li>讲红黑树（上）：为什么工程中都用红黑树这种二叉树</li>
<li>讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</li>
<li>讲递归树：如何借助树来求解递归算法的时间复杂度</li>
<li>讲堆和堆排序：为什么说堆排序没有快速排序快</li>
<li>讲堆的应用：如何快速获取到Top10最热门的搜索关键词</li>
<li>讲图的表示：如何存储微博、微信等社交网络中的好友关系</li>
<li>讲深度和广度优先搜索：如何找出社交网络中的三度好友关系</li>
<li>讲字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配</li>
<li>讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能</li>
<li>讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法</li>
<li>讲Trie树：如何实现搜索引擎的搜索关键词提示功能</li>
<li>讲AC自动机：如何用多模式串匹配实现敏感词过滤功能</li>
<li>讲算法实战（一）：剖析Redis常用数据类型对应的数据结构</li>
<li>讲算法实战（二）：剖析搜索引擎背后的经典数据结构和算法</li>
<li>讲算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法</li>
<li>讲算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法</li>
<li>讲算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统</li>
</ol>
</blockquote>
<h1 id="数学科普"><a href="#数学科普" class="headerlink" title="数学科普"></a>数学科普</h1><blockquote>
<h2 id="科普内存存储数据大小"><a href="#科普内存存储数据大小" class="headerlink" title="科普内存存储数据大小"></a>科普内存存储数据大小</h2><ol>
<li>常用的英文单词有20万个左右，假设单词的平均⻓度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词 大约占2MB的存储空间，就算放大10倍也就是20MB。 </li>
<li>如何在1000万个整数中快速查找某个整数? <ul>
<li>这个问题并不难。我们的内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用差不 多是80MB，符合内存的限制。借助今天讲的内容，我们可以先对这1000万数据从小到大排序，然后再利用二分查找算法，就 可以快速地查找想要的数据了。 </li>
<li>规律：抽象数字转字节，字节*数量，再转mb。其中100w字节（Bytes）=1MB</li>
<li>也就是1000w整数，占用内存为80MB</li>
</ul>
</li>
<li>因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧?大约 是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。 </li>
</ol>
<h2 id="取余和求模"><a href="#取余和求模" class="headerlink" title="取余和求模"></a>取余和求模</h2><p>求余操作(%)：</p>
<p>1、被除数小于除数，那么余数就是被除数。</p>
<p>2、余数和取模计算公式：<br>c=a/b;<br>d=a-c*b</p>
<p>3、余数的取值范围[0,除数-1]</p>
<h2 id="时间复杂度科普"><a href="#时间复杂度科普" class="headerlink" title="时间复杂度科普"></a>时间复杂度科普</h2><p><img alt="image-20190621063728236" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zj9auyq5j31hc0u0e78.jpg" class="lazyload"></p>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>(也说质数) 数学上指在大于1的整数中只能被1和它本身整除的数。如2、3、5、7、11、43、109</p>
</blockquote>
<h1 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h1><blockquote>
<h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>基于数组（链表）实现LRU缓存淘汰算法</p>
<ul>
<li>- 单链表反转 </li>
</ul>
<ul>
<li>- 链表中环的检测 </li>
</ul>
<ul>
<li>- 两个有序的链表合并 </li>
</ul>
<ul>
<li>- 删除链表倒数第n个结点 </li>
</ul>
<ul>
<li>- 求链表的中间结点 </li>
</ul>
<h2 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h2><p>数组实现的顺序栈、链表实现的栈</p>
<ul>
<li>- 函数调用栈</li>
</ul>
<ul>
<li>- 表达式求值（双栈）</li>
</ul>
<ul>
<li>- 括号匹配</li>
</ul>
<ul>
<li><p>- 浏览器前进和后退</p>
</li>
<li><p>栈最小元素的 min 函数（双栈）</p>
</li>
</ul>
<h2 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h2><p>数组实现的顺序队列，链表实现的队列</p>
<ul>
<li>循环队列</li>
<li>阻塞队列（Lock+Condition）</li>
<li>并发队列（循环队列+cas）</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li><p>有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法? </p>
</li>
<li><p>n台阶使用散列函数来优化</p>
</li>
</ul>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><ul>
<li>哨兵代码：归并排序、有序链表合并</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>O(n)时间复杂度内求无序数组中的第K大元素。 </li>
</ul>
<h2 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h2><ul>
<li>如何根据年龄给100万用户数据排序</li>
<li>我们有10GB的订单数据，我们希望按订单金额(假设金额都是正整数)进行排序，但是我们的内存有限，只有几百 MB</li>
<li>如何实现100w考生的成绩和排名</li>
<li>假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序， </li>
</ul>
</blockquote>
<h1 id="讲数组：为什么很多编程语言中数组都从0开始编号"><a href="#讲数组：为什么很多编程语言中数组都从0开始编号" class="headerlink" title="讲数组：为什么很多编程语言中数组都从0开始编号"></a>讲数组：为什么很多编程语言中数组都从0开始编号</h1><blockquote>
<p>为什么数组要从0开始编号，而不是从1开始呢？</p>
</blockquote>
<h2 id="数组：如何实现随机访问"><a href="#数组：如何实现随机访问" class="headerlink" title="数组：如何实现随机访问"></a>数组：如何实现随机访问</h2><blockquote>
<ul>
<li><p>什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</li>
<li><p>线性表：数据排成像一条线一样的结构。每个线性表上的数据最对只有前和后两个方向。包括：数组、链表、队列、栈等。</p>
</li>
<li><p>连续的内存空间和相同类型的数据：这两大特性，让数组实现了随机访问。而为了维护这种结构插入和删除操作，就需要做大量的数据搬迁工作。</p>
<p><img alt="image-20191027081902843" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cg3lhjy8j30kj0fdn1z.jpg" class="lazyload"></p>
</li>
<li><p>非线性表：数据之间并不是简单的前后关系，包括：二叉树、堆、图等。</p>
</li>
</ul>
</blockquote>
<ul>
<li>计算机访问内存中数组公式：a[i]_address  = base_address + i * data_type_size </li>
</ul>
<h2 id="数组：如何解决数组”插入”和”删除”低效"><a href="#数组：如何解决数组”插入”和”删除”低效" class="headerlink" title="数组：如何解决数组”插入”和”删除”低效"></a>数组：如何解决数组”插入”和”删除”低效</h2><ul>
<li>插入操作：在第K个位置插入数据<ol>
<li>如果数组是没有任何规律的：将第K位置的数据搬迁到数组的末尾，然后再把要插入第K位置的数据插入.</li>
<li>如果数组是有序的：就根据K的位置，搬迁数据。</li>
</ol>
</li>
<li>删除操作<ol>
<li>多次删除操作集中在一起执行，删除的效率是不是会提高很多呢? </li>
<li>标记这个元素已经被删除。类比：JVM标记清除垃圾回收算法。</li>
</ol>
</li>
</ul>
<h2 id="数据总览"><a href="#数据总览" class="headerlink" title="数据总览"></a>数据总览</h2><ul>
<li>警惕数组的访问越界问题：Java本身帮我们做了越界检查。<code>ArrayIndexOutOfBoundsException</code></li>
<li><strong>容器能否完全替代数组？</strong>（换句话：容器（ArrayList）和数组的区别）<ol>
<li>容器可以将很多数组操作的细节封装起来 ，支持动态扩容(1.5倍 )。 <ul>
<li>但是扩容操作涉及内存申请和数据搬迁，比较耗时。建议在创建<strong>ArrayList</strong>的时候事先指定数据大小。 </li>
</ul>
</li>
<li>Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能 消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 </li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。 </li>
<li>业务开发，直接使用容器就足够了 。非常底层的开发 ，数组是首选。</li>
</ol>
</li>
</ul>
<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><blockquote>
<ul>
<li>如何下标是0开始：<ul>
<li>计算公式：a[i]_address  = base_address + i * data_type_size </li>
</ul>
</li>
<li>如果下标是1开始：<ul>
<li>计算公式：a[i]_address  = base_address + (i-1) * data_type_size </li>
</ul>
</li>
<li>从1开始的话，每次访问数组就多了一次减法运算。但是更多原因是历史的原因，因为C语言设计是0开始计数数组下标的.</li>
</ul>
</blockquote>
<h1 id="讲链表（上）：如何实现LRU缓存淘汰算法"><a href="#讲链表（上）：如何实现LRU缓存淘汰算法" class="headerlink" title="讲链表（上）：如何实现LRU缓存淘汰算法"></a>讲链表（上）：如何实现LRU缓存淘汰算法</h1><blockquote>
<ul>
<li><p>经典的链表应用场景：LRU缓存淘汰算法。</p>
</li>
<li><p>缓存淘汰策略：常见的有三种。</p>
<ol>
<li>先进先出策略：FIFO(First In,First Out)</li>
<li>最少使用策略：LFU（Least Frequently Used）</li>
<li>最近最少使用策略：LRU（Least Recently Used）</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>链表：零散的内存块串联起来的。包括：单链表、双向链表和循环链表。</p>
<p>循环链表：优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。 </p>
<p>双向链表：开发中，实际运用的更多。比单链表的优点就是知道前驱节点(用空间换时间)。<code>LinkedHashMap</code></p>
<p><img alt="image-20191027091453356" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8chpp4o1jj30kg061ac9.jpg" class="lazyload"></p>
<p>双向循环链表 ：上面二者结合</p>
<ul>
<li>空间换时间、时间换空间等设计思想。</li>
</ul>
</blockquote>
<h2 id="数组、容器、链表的区别"><a href="#数组、容器、链表的区别" class="headerlink" title="数组、容器、链表的区别"></a>数组、容器、链表的区别</h2><p><img alt="image-20191028085335672" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8dmpw51i5j30cq085adj.jpg" class="lazyload"></p>
<ul>
<li>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而 链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。 </li>
<li>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。 链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区 别。 <ul>
<li>数组太大，有可能会内存不足（out of memory）</li>
<li>数组太小，扩容和搬迁数据非常耗时。</li>
</ul>
</li>
<li>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存 储一份指向下一个结点的指针，所以内存消耗会翻倍。 </li>
</ul>
<h2 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h2><ul>
<li>LRU缓存淘汰算法（<a href="https://www.jianshu.com/p/1f8e36285539" target="_blank" rel="noopener">LRU和LFU的区别</a>）<ul>
<li>LRU按照访问时间排序，LFU按照访问频次排序</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组 稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。 </p>
<p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的 各种性能进行对比，综合来选择使用两者中的哪一个。 </p>
<h1 id="讲链表（下）：如何轻松写出正确的链表代码"><a href="#讲链表（下）：如何轻松写出正确的链表代码" class="headerlink" title="讲链表（下）：如何轻松写出正确的链表代码"></a>讲链表（下）：如何轻松写出正确的链表代码</h1><blockquote>
<ol>
<li>技巧一：理解指针和引用的含义<ul>
<li>在java中指针和引用都是存储所指对象的内存地址。</li>
<li>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向 了这个变量，通过指针就能找到这个变量。 </li>
</ul>
</li>
<li>技巧二：警惕指针丢失和内存泄漏<ul>
<li>插入结点时，一定要注意操作的顺序 </li>
</ul>
</li>
<li>技巧三:利用哨兵简化实现难度</li>
<li>技巧四:重点留意边界条件处理<ul>
<li>如果链表为空时，代码是否能正常工作? </li>
<li>如果链表只包含一个结点时，代码是否能正常工作? </li>
<li>如果链表只包含两个结点时，代码是否能正常工作? </li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作? </li>
</ul>
</li>
<li>技巧五:举例画图，辅助思考<ul>
<li>举例法和画图法。 </li>
</ul>
</li>
<li>技巧六:多写多练，没有捷径<ul>
<li>单链表反转 </li>
<li>链表中环的检测 </li>
<li>两个有序的链表合并 </li>
<li>删除链表倒数第n个结点 </li>
<li>求链表的中间结点 </li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="技巧三-利用哨兵简化实现难度"><a href="#技巧三-利用哨兵简化实现难度" class="headerlink" title="技巧三:利用哨兵简化实现难度"></a>技巧三:利用哨兵简化实现难度</h2><ul>
<li>如果我们在结点p后面插入一个新的结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node-&gt;next = p-&gt;next; </span><br><span class="line">p-&gt;next = new_node;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们要向一个空链表中插入第一个结点 ，特殊处理，其中head表 示链表的头结点 .</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要删除结点p的后继结点 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure>

<ul>
<li>要删除链表中的最后一个结点 ，特殊处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="keyword">null</span>) &#123; </span><br><span class="line">	head = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行 特殊处理。</strong></p>
<ul>
<li>带头链表：我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表。相反，没有哨兵结点的链表就叫作不带头链表。 </li>
</ul>
<p><img alt="image-20191028092255223" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8dnkdjjm1j30im06babr.jpg" class="lazyload"></p>
<h1 id="讲栈：如何实现浏览器的前进和后退功能"><a href="#讲栈：如何实现浏览器的前进和后退功能" class="headerlink" title="讲栈：如何实现浏览器的前进和后退功能"></a>讲栈：如何实现浏览器的前进和后退功能</h1><blockquote>
<p>理解栈：后进者先出，先进者后出，这就是典型的栈结构。类比：碟盘子。</p>
<ul>
<li>栈是一种<strong>“</strong>操作受限<strong>”</strong>的线性表，只允许在一端插入和删除数据。 </li>
<li>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选<strong>“</strong>栈<strong>”</strong>这种数据结构。 </li>
</ul>
<p>实现栈：</p>
<ul>
<li>用数组实现的栈，我们叫作顺序栈 ，用链表实现的栈，我们叫作链式 栈。 </li>
<li>空间复杂度和时间复杂度都是O(1)</li>
</ul>
<p>支持动态扩容的顺序栈 ：</p>
<ul>
<li>类比数组的动态扩容，也是申请一个更大的栈然后搬迁数据。</li>
</ul>
<p>栈的应用：</p>
<ul>
<li>函数调用栈</li>
<li>表达式求值（双栈）</li>
<li>括号匹配</li>
<li>浏览器前进和后退（双栈）</li>
</ul>
</blockquote>
<h1 id="讲队列：队列在线程池等有限资源池中的应用"><a href="#讲队列：队列在线程池等有限资源池中的应用" class="headerlink" title="讲队列：队列在线程池等有限资源池中的应用"></a>讲队列：队列在线程池等有限资源池中的应用</h1><blockquote>
<p>理解队列：先进者先出，这就是典型的队列。类比：排队购票。</p>
<ul>
<li>操作受限的线性表数据结构。 支持在队尾插入元素，在队头删除元素 </li>
</ul>
<p>实现队列：</p>
<ul>
<li>用数组实现的队列叫作顺序队列（有界队列），用链表实现的队列叫作链式队列（无界队列）。 </li>
</ul>
</blockquote>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><ul>
<li>解决了tail==n数据搬迁性能问题。</li>
<li>循环队列的实现：确定好队空和队满的判定条件 <ol>
<li>数组实现的非循环队列<ul>
<li>队列满：tail==n</li>
<li>队列空：head==tail</li>
</ul>
</li>
<li>循环队列<ul>
<li>队列满：<strong>(tail+1)%n=head</strong> </li>
<li>队列空：head==tail</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><blockquote>
<p>阻塞队列：当队列为空的时候，出队会被阻塞。当队列满的时候，入队会被阻塞。</p>
<ul>
<li>典型的生产者-消费者模型。线程池的本质。</li>
</ul>
<p>并发队列：线程安全的队列。基于数组的循环队列，利用CAS原子操作 。</p>
</blockquote>
<h1 id="讲递归：如何用三行代码找到“最终推荐人”"><a href="#讲递归：如何用三行代码找到“最终推荐人”" class="headerlink" title="讲递归：如何用三行代码找到“最终推荐人”"></a>讲递归：如何用三行代码找到“最终推荐人”</h1><h2 id="如何理解递归"><a href="#如何理解递归" class="headerlink" title="如何理解递归"></a>如何理解递归</h2><ul>
<li><p>学习算法和数据结构比较难理解的两个知识点：动态规划和递归。</p>
</li>
<li><p>非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递 推公式来表示。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景：自己坐在第几排</span></span><br><span class="line"><span class="comment">//递推公式：f(n)=f(n-1)+1 其中，f(1)=1</span></span><br><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">f</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归需要满足的三个条件 </p>
<ol>
<li>一个问题的解可以分解为几个子问题的解 </li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 </li>
<li>存在递归终止条件 </li>
</ol>
</li>
<li><p>如何编写递归代码</p>
<ul>
<li>写出递推公式，找到终止条件.</li>
</ul>
</li>
<li><p>求解n个台阶的走法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求解</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 当第一步走了1格，或者第一步走了2格</span></span><br><span class="line"><span class="comment"> * 递归公式：f(n)=f(n-1)+f(n-2)</span></span><br><span class="line"><span class="comment"> * 终止条件：f(1)=1,f(2)=2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursive(n - <span class="number">1</span>) + recursive(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条 件，最后将递推公式和终止条件翻译成代码。</p>
</li>
<li><p>说得很好地方，讲了那么久自己递归代码为什么理解不出来的原因</p>
<blockquote>
<p>计算机擅⻓做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把 递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p>
<p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力， 主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢?</p>
<p>如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而 且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子 子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>
</blockquote>
</li>
<li><p>递归代码要警惕堆栈溢出 </p>
<ul>
<li>递归最大深度比较小的时候，可以在代码定义一个全局变量，表示递归的深度。</li>
</ul>
</li>
<li><p>递归代码要警惕重复计算 </p>
<ul>
<li>用散列表等数据结构来保存</li>
<li>todo:n台阶问题优化</li>
</ul>
</li>
</ul>
<h2 id="怎么将递归代码改写为非递归代码"><a href="#怎么将递归代码改写为非递归代码" class="headerlink" title="怎么将递归代码改写为非递归代码"></a>怎么将递归代码改写为非递归代码</h2><ul>
<li><p>递归代码优点和缺点</p>
<ul>
<li>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本 </li>
<li>在空间复杂 度上，因为递归调用一次就会在内存栈中保存一次现场数据 </li>
</ul>
</li>
<li><p>具体栗子：电影第几排问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把递推公式：f(x)=f(x-1)+1、终止条件f(1)=1</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 修改为非递归的代码</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 场景：我在电影第几排修改为非递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是所有的递归代码都可以改为这种迭代循环的非递归写法 。</p>
</li>
</ul>
<h2 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">	Long referrerId = select referrer_id from [table] where actor_id = actorId; <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) 		<span class="keyword">return</span> actorId;</span><br><span class="line">	<span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是不能在线上使用，原因：递归深度太深（堆栈溢出）、a-b-c-a环检测问题。<ul>
<li>使用限制递归深度解决。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。 </p>
<p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件， 然后再翻译成递归代码。 </p>
<p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所 以，在编写递归代码的时候，一定要控制好这些副作用。 </p>
</blockquote>
<h1 id="讲排序（上）：为什么插入排序比冒泡排序更受欢迎"><a href="#讲排序（上）：为什么插入排序比冒泡排序更受欢迎" class="headerlink" title="讲排序（上）：为什么插入排序比冒泡排序更受欢迎"></a>讲排序（上）：为什么插入排序比冒泡排序更受欢迎</h1><blockquote>
<p>排序算法太多了，我们只讲最经典、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、基数排序、桶排序。</p>
<p>根据时间复杂度分为三类：</p>
<p><img alt="image-20191104082141713" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8lp4toe8aj30jr0ajgrt.jpg" class="lazyload"></p>
</blockquote>
<h2 id="如何分析一个”排序算法”？"><a href="#如何分析一个”排序算法”？" class="headerlink" title="如何分析一个”排序算法”？"></a>如何分析一个”排序算法”？</h2><ol>
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
<ul>
<li>正序和倒序：有序度不同，对于一些排序算法时间复杂度影响比较大。</li>
</ul>
</li>
<li><p>时间复杂度的系数、常数、低阶</p>
<ul>
<li>时间复杂度反应的是数据规模n很大的时候的一个增⻓趋势，所以它表示的时候会忽略系数、常数、低阶 .</li>
<li>但是实 际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性 能对比的时候，我们就要把系数、常数、低阶也考虑进来。 </li>
</ul>
</li>
<li><p>比较次数和交换（或移动）次数</p>
<ul>
<li><p><strong>排序算法的内存消耗</strong>（空间复杂度）</p>
<ul>
<li>原地排序：空间复杂度O(1)</li>
</ul>
</li>
<li><p><strong>排序算法的稳定性</strong></p>
<ul>
<li><p>稳定性。这个概 念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 </p>
</li>
<li><p>稳定性的实际运用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在 有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有 序。对于这样一个排序需求，我们怎么来做呢?</span><br><span class="line"></span><br><span class="line">方案1（欠佳）：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再 按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</span><br><span class="line"></span><br><span class="line">方案2（最佳）：我们先按照下单时间给订单排序，注意是按照下单时 间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照 金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li><p>原理：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就 让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。 </p>
</li>
<li><p>优化：刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的 冒泡操作。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> n = a.length - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//优化：如果没有比较次数了，直接break</span></span><br><span class="line">        <span class="keyword">boolean</span> nochange = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//这里决定了稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tem = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = tem;</span><br><span class="line">                nochange = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nochange) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三连问：xx排序算法是原地排序算法吗？xx排序算法是稳定的排序算法吗？xx排序算法的时间复杂度？</p>
<ul>
<li>冒泡排序是原地排序算法、是稳定的。正序最好复杂度（O(n)）倒序最坏（O(n²)）平均（O(n²)）</li>
</ul>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li><p>原理：我们将数组中的数据分为两个区间，已排序区间和未排序区间 。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一 直有序。 </p>
</li>
<li><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sorts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] sorts)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sorts.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sorts.length; i++) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> val = sorts[i];</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//排序好了的最后一位值</span></span><br><span class="line">            <span class="keyword">int</span> sortLast = sorts[j];</span><br><span class="line">			<span class="comment">//决定了稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (val &gt; sortLast) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//交换值</span></span><br><span class="line">                <span class="keyword">int</span> s1 = sorts[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> temp = s1;</span><br><span class="line">                sorts[j + <span class="number">1</span>] = sorts[j];</span><br><span class="line">                sorts[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三连问：原地排序、稳定的，正序最好情况（O(n)）、倒序最坏情况（O(n²)）、平均（O(n²)）</p>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li><p>原理：分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的 元素，将其放到已排序区间的末尾。 </p>
</li>
<li><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> n = a.length - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> smallIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (a[smallIndex] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                smallIndex = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//swap</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[smallIndex];</span><br><span class="line">        a[smallIndex] = temp;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三连问：原地排序算法、不稳定。最好情况时间复杂度、最坏情况和平均情况时间复杂度 都为O(n2) </p>
</li>
</ul>
<h2 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h2><p>为什么插入 排序要比冒泡排序更受欢迎呢? </p>
<ul>
<li>冒泡排序：元素交换思路。3次赋值操作</li>
<li>插入排序：元素移动思路。1次赋值操作</li>
<li>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选 插入排序。 </li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img alt="image-20191104100720115" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ls6ps0f0j30lw0a87ag.jpg" class="lazyload"></p>
<p>对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候， 这个时间复杂度还是稍微有点高 。</p>
<h1 id="讲排序（下）：如何用快排思想在O-n-内查找第K大元素"><a href="#讲排序（下）：如何用快排思想在O-n-内查找第K大元素" class="headerlink" title="讲排序（下）：如何用快排思想在O(n)内查找第K大元素"></a>讲排序（下）：如何用快排思想在O(n)内查找第K大元素</h1><blockquote>
<p>冒泡排序、插入排序、选择排序的时间复杂度都是O(n²)，比较高。适合小规模数据排序。</p>
<p>接下来要讲的是时间复杂度为O(nlogn)的排序算法：归并排序和快速排序（分治思想）。适合达规模的数据排序，比前面三者更常用。</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li><p>原理：分治思想，归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排 序，再将排好序的两部分合并在一起，这样整个数组就都有序了 。</p>
</li>
<li><p>图解：</p>
<p><img alt="image-20191105084148151" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mvc1wparj30kz0hgall.jpg" class="lazyload"></p>
</li>
<li><p>分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。 </p>
<ul>
<li>分治算法一般都是用递归来实现的。<strong>分治 是一种解决问题的处理思想，递归是一种编程技巧</strong> </li>
<li><strong>如何用递归代码来实现归并排序</strong>。 </li>
</ul>
</li>
<li><blockquote>
<p>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) </p>
<p>终止条件：p &gt;= r 不用再继续分解 </p>
</blockquote>
</li>
<li><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">// 归并排序算法, A是数组，n表示数组大小 </span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">	merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用函数 </span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">	<span class="comment">// 递归终止条件</span></span><br><span class="line">	<span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">	<span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">	q = (p+r) / <span class="number">2</span></span><br><span class="line">	<span class="comment">// 分治递归</span></span><br><span class="line">	merge_sort_c(A, p, q)</span><br><span class="line">	merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line"><span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r] </span></span><br><span class="line">	merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-05 08:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_12_MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        mergeSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">        <span class="keyword">int</span> q = p + (r - p) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分治递归</span></span><br><span class="line">        mergeSortInternally(a, p, q);</span><br><span class="line">        mergeSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">        merge(a, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = p;</span><br><span class="line">        <span class="keyword">int</span> j = q + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - p + <span class="number">1</span>]; <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                tmp[k++] = a[i++]; <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">int</span> end = q;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            start = j;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            tmp[k++] = a[start++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - p; ++i) &#123;</span><br><span class="line">            a[p + i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并(哨兵)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeBySentry</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftArr = <span class="keyword">new</span> <span class="keyword">int</span>[q - p + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightArr = <span class="keyword">new</span> <span class="keyword">int</span>[r - q + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= q - p; i++) &#123;</span><br><span class="line">            leftArr[i] = arr[p + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个数组添加哨兵（最大值）</span></span><br><span class="line">        leftArr[q - p + <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - q; i++) &#123;</span><br><span class="line">            rightArr[i] = arr[q + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个数组添加哨兵（最大值）</span></span><br><span class="line">        rightArr[r - q] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = p;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样</span></span><br><span class="line">            <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">                arr[k++] = leftArr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k++] = rightArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序三连问：稳定的，最好、最坏、平均时间复杂度O(nlogn)，不是原地排序算法，空间复杂度就是O(n) </p>
</li>
</ul>
<h2 id="快速排序（快排）"><a href="#快速排序（快排）" class="headerlink" title="快速排序（快排）"></a>快速排序（快排）</h2><ul>
<li><p>原理：分治思想。</p>
<ul>
<li>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区 点)。 </li>
<li>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。 </li>
<li>然后继续分治、递归处理，直到区间缩小为1。</li>
</ul>
</li>
<li><blockquote>
<p>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r) </p>
<p>终止条件：p &gt;= r </p>
</blockquote>
</li>
<li><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A是数组，n表示数组的大小 </span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">	quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标 </span></span><br><span class="line">quick_sort_c(A, p, r) &#123; </span><br><span class="line">	<span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">	<span class="comment">// 获取分区点 </span></span><br><span class="line">	q = partition(A, p, r) </span><br><span class="line">	quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，a是数组，n表示数组的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      quickSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">      quickSortInternally(a, p, q - <span class="number">1</span>);</span><br><span class="line">      quickSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">      <span class="keyword">int</span> i = p;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                  ++i;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">                  a[i++] = a[j];</span><br><span class="line">                  a[j] = tmp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">      a[i] = a[r];</span><br><span class="line">      a[r] = tmp;</span><br><span class="line">  </span><br><span class="line">      System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序是不是原地排序，取决partition()获取分区点的函数实现。</p>
<ul>
<li><p>非原地排序算法实现：partition()分区函数可以写得非常简单。我们申请两个临时数组X和Y，遍历A[p…r]，将小于 pivot的元素都拷⻉到临时数组X，将大于pivot的元素都拷⻉到临时数组Y，最后再将数组X和数组Y中数据顺序拷⻉到A[p… r]。</p>
</li>
<li><p>原地排序算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123; </span><br><span class="line">	pivot := A[r]</span><br><span class="line">	i := p</span><br><span class="line">	<span class="keyword">for</span> j := p to r-<span class="number">1</span> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i := i+<span class="number">1</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>快速排序三连问：不稳定、可原地排序算法</p>
</li>
</ul>
<h2 id="归并和快排区别"><a href="#归并和快排区别" class="headerlink" title="归并和快排区别"></a>归并和快排区别</h2><p><img alt="image-20191105092256226" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mwiszytmj30lr0dbn5u.jpg" class="lazyload"></p>
<ol>
<li>处理过程<ul>
<li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并 </li>
<li>快排正好相反，它的处理过程是由上到下的， 先分区，然后再处理子问题。 </li>
</ul>
</li>
<li>原地排序（空间复杂度O(1)）<ul>
<li>归并排序是稳定的、时间复杂度O(nlogn)。但是在合并的时候，不是原地排序。额外内存空间。</li>
<li>快排是原地排序的，不稳定的。大多数情况的时间复杂度都为O(nlogn)，极端情况才会退化为O(n²)</li>
</ul>
</li>
</ol>
<h2 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h2><p>如何在O(n)找到第K大元素？</p>
<ul>
<li>利用分治和分区的实现。</li>
<li>实现：Todo</li>
</ul>
<h1 id="讲线性排序：如何根据年龄给100万用户数据排序"><a href="#讲线性排序：如何根据年龄给100万用户数据排序" class="headerlink" title="讲线性排序：如何根据年龄给100万用户数据排序"></a>讲线性排序：如何根据年龄给100万用户数据排序</h1><blockquote>
<p>线性排序：时间复杂度为O(n)，常见：桶排序、计数排序、基数排序。不是基于比较的排序算法，不涉及元素之间的比较操作。但是对排序的数据有对应的场景。</p>
<p>题目：如何根据年龄给100w用户排序。</p>
</blockquote>
<h2 id="桶排序-Bucket-sort"><a href="#桶排序-Bucket-sort" class="headerlink" title="桶排序(Bucket sort)"></a>桶排序(<strong>Bucket sort</strong>)</h2><ul>
<li><p>原理：将要排序的数据分到几个有序的桶里，每个桶里的数据 再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 </p>
</li>
<li><p>三连问：时间复杂度O(n)</p>
<p><img alt="image-20191107084317855" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8p6m8kthjj30kh0bpn35.jpg" class="lazyload"></p>
</li>
</ul>
<h3 id="桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？"><a href="#桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？" class="headerlink" title="桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？"></a>桶排序看起来那么优秀，可以替换之前讲的常规排序算法吗？</h3><blockquote>
<ul>
<li>不能，因为我们对桶排序之前，都做了很多假设，本质就是对要排序的数据要求很苛刻。</li>
<li>但是桶排序比较适合用在外部排序中 。</li>
<li>外部排序：就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加 载到内存中。 </li>
<li>题目：在内存为100MB的情况下，把10G的订单文件按照金额进行排序。<ol>
<li>用桶排序。</li>
<li>第一遍扫描价格区间，根据价格区间创建适合的桶。</li>
<li>利用快排在桶内排序。</li>
<li>如果某个桶的数据太大，再继续划分桶</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h2><ul>
<li>计数排序其实是桶排序的一种特殊情况 </li>
<li>原理：最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。 </li>
<li>适用场景：计数排序只能用在数据范围不大的场景中，如果数据范围<strong>k</strong>比要排序的数据<strong>n</strong>大很多，就不适合用计数排序了。 而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整 数。 </li>
</ul>
<h2 id="基数排序-Radix-sort"><a href="#基数排序-Radix-sort" class="headerlink" title="基数排序(Radix sort )"></a>基数排序(<strong>Radix sort</strong> )</h2><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>线性排序：虽然时间复杂度都是O(n)，但是应用不是特别广泛，只能使用在特定的场景下。</p>
</blockquote>
<h1 id="讲排序优化：如何实现一个通用的、高性能的排序函数"><a href="#讲排序优化：如何实现一个通用的、高性能的排序函数" class="headerlink" title="讲排序优化：如何实现一个通用的、高性能的排序函数"></a>讲排序优化：如何实现一个通用的、高性能的排序函数</h1><p>如何实现一个通用的、高性能的排序函数? </p>
<h2 id="如何选择合适的排序算法"><a href="#如何选择合适的排序算法" class="headerlink" title="如何选择合适的排序算法"></a>如何选择合适的排序算法</h2><ul>
<li><p>总结之前学习过的算法</p>
<p><img alt="image-20191108083725762" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qc2frphfj30ic0bjtdx.jpg" class="lazyload"></p>
</li>
<li><p>如何选择：</p>
<ol>
<li>线性算法要适用于特定场景。</li>
<li>对于小规模的数据，可以选择时间复杂度为O(n²)</li>
<li>对于大规模的数据，时间复杂度为O(nlogn)的算法更加高效。一般也选择O(nlogn)作为排序算法首选.</li>
<li>O(nlogn)的排序算法<ul>
<li>快速排序：c语言使用</li>
<li>堆排序：java语言使用，如何优化最坏时间复杂度为O(n²)了？</li>
<li>归并排序：因为不是原地排序并没有使用。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h2><ul>
<li>问题产生的原因：<ul>
<li>在有序的数据并且每次选择分区都选择最后一个。</li>
<li>这种<strong>O(n²)</strong> 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。 </li>
</ul>
</li>
<li>解决问题：<ul>
<li>那什么样的分区点是好的分区点呢?或者说如何来选择分区点呢? </li>
<li>被分区点分开的两个分区中，数据的数量差不多。 </li>
</ul>
</li>
<li>分区点选择算法<ol>
<li>三数取中法 </li>
<li>随机法 </li>
</ol>
</li>
<li>堆栈溢出解决<ol>
<li>限制递归深度</li>
<li>在堆上模拟是一个函数调用栈</li>
</ol>
</li>
</ul>
<h2 id="举例分析排序函数qsort"><a href="#举例分析排序函数qsort" class="headerlink" title="举例分析排序函数qsort()"></a>举例分析排序函数qsort()</h2><ol>
<li>qsort()会优先使用归并排序输入数据（数据规模1KB~10KB）</li>
<li>要排序的数 据量比较大的时候，<strong>qsort()</strong>会改为用快速排序算法来排序。 <ul>
<li>分区点的选择：三数取中法</li>
<li>堆栈溢出：堆上模拟函数调用栈</li>
</ul>
</li>
<li>在快速排序过程：如何元素个数&lt;=4，使用插入排序。<ul>
<li><strong>O(n²)</strong>时间复杂度的算法并不一定比<strong>O(nlogn)</strong>的算法执行时间⻓ </li>
</ul>
</li>
<li>哨兵简化代码</li>
</ol>
<h1 id="讲二分查找（上）：如何用最省内存的方式实现快速查找功能"><a href="#讲二分查找（上）：如何用最省内存的方式实现快速查找功能" class="headerlink" title="讲二分查找（上）：如何用最省内存的方式实现快速查找功能"></a>讲二分查找（上）：如何用最省内存的方式实现快速查找功能</h1><blockquote>
<p>针对有序数据集合的查找算法：二分查找（Binary search）算法，也叫折半查找算法。</p>
<p>问题：如何设计数据结构和算法，快速判断某个整数是否出现在这<strong>1000</strong>万数据 中? </p>
</blockquote>
<h2 id="二分查找思想"><a href="#二分查找思想" class="headerlink" title="二分查找思想"></a>二分查找思想</h2><p>二分查找针对的是一个有序的数据集 合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的 元素，或者区间被缩小为<strong>0</strong> 。时间复杂度O(logn)</p>
<h2 id="二分查找算法惊人O-logn"><a href="#二分查找算法惊人O-logn" class="headerlink" title="二分查找算法惊人O(logn)"></a>二分查找算法惊人O(logn)</h2><blockquote>
<p>二分查找算法的时间复杂度为O(logn)，后续讲到的堆、二叉树也是该时间复杂度。</p>
<p>因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧?大约 是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。 </p>
</blockquote>
<h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_15_BinarySearchSimple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找的递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> bsearchInternally(a, mid + <span class="number">1</span>, high, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bsearchInternally(a, low, mid - <span class="number">1</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span>[] r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = r.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (r[mid] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r[mid] &lt; value) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归实现容易出错的三个地方<ol>
<li>mid的取值：超过Integer的最大值，取中间值：<code>low+(high-low)/ 2</code>或者<code>low+((high-low)&gt;&gt;1)</code></li>
<li>循环退出：是&lt;=</li>
<li>low和high的更新</li>
</ol>
</li>
</ul>
<h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><ol>
<li>二分查找依赖的是顺序表结构，简单点说就是数组。 </li>
<li>二分查找针对的是有序数据。<ul>
<li>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</li>
<li>针对动态变化的数据集合，二分查找将不再适 用。那针对动态数据集合，如何在其中快速查找某个数据呢?<ul>
<li>二叉树那一节我会详细讲。 </li>
</ul>
</li>
</ul>
</li>
<li>数据量太小不适合二分查找 <ul>
<li>比较次数过多的，也可以使用二分查找</li>
</ul>
</li>
<li>数据量太大也不适合二分查找 <ul>
<li>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。 比如，我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。 </li>
</ul>
</li>
</ol>
<h1 id="讲二分查找（下）：如何快速定位IP对应的省份地址"><a href="#讲二分查找（下）：如何快速定位IP对应的省份地址" class="headerlink" title="讲二分查找（下）：如何快速定位IP对应的省份地址"></a>讲二分查找（下）：如何快速定位IP对应的省份地址</h1><blockquote>
<p>二分查找的变形问题：我们上一章讲的都是基于没有重复元素并且存在存在给定值的情况。</p>
<p>二分查找：比较难写。我们默认接下来的集合数据都是按照从小到大排好顺序了。</p>
<p><img alt="image-20191108095342476" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qe9rntqtj30k70dln7b.jpg" class="lazyload"></p>
</blockquote>
<h2 id="变体1：查找第一个值等于给定值的元素"><a href="#变体1：查找第一个值等于给定值的元素" class="headerlink" title="变体1：查找第一个值等于给定值的元素"></a>变体1：查找第一个值等于给定值的元素</h2><h2 id="变体2：查找最后一个值等于给定值的元素"><a href="#变体2：查找最后一个值等于给定值的元素" class="headerlink" title="变体2：查找最后一个值等于给定值的元素"></a>变体2：查找最后一个值等于给定值的元素</h2><h2 id="变体3：查找第一个大于等于给定值的元素"><a href="#变体3：查找第一个大于等于给定值的元素" class="headerlink" title="变体3：查找第一个大于等于给定值的元素"></a>变体3：查找第一个大于等于给定值的元素</h2><h2 id="变体4：查找最后一个小于等于给定值的元素"><a href="#变体4：查找最后一个小于等于给定值的元素" class="headerlink" title="变体4：查找最后一个小于等于给定值的元素"></a>变体4：查找最后一个小于等于给定值的元素</h2><h2 id="问题解答-5"><a href="#问题解答-5" class="headerlink" title="问题解答"></a>问题解答</h2><p>如何快速定位一个IP地址的归属地？</p>
<ul>
<li>这种类型问题的特点：<ol>
<li>如果IP区间与归属地的对应关系不经常更新 。</li>
<li>我们可以先预处理这12万条数据，让其按照起始IP 从小到大排序。 IP地址可以转化为32位的整型数 </li>
</ol>
</li>
<li>根据上面的特点，我们就把问题转换为二分查找的变形问题4了，在有序数组中，找到最后一个小于等于某个给定值的元素了。</li>
</ul>
<h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><ol>
<li>凡是用二分查找能解决的，绝大部分我们更倾向于用<strong>散列表或者二叉查找树</strong>。即便是二分查找在内存使用上更 节省，但是毕竟内存如此紧缺的情况并不多。</li>
<li>二分查找的用途：<ul>
<li>二分查找更适合用在“近似”查找问题 。</li>
<li>求“值等于给定值”的二分查找确实不怎么会被用到 。</li>
<li>变体问题最好二分的用户，用散列表或者二叉树很难实现。</li>
</ul>
</li>
<li>二分查找算法很难，容易出错的地方：终止条件、区间上下界更新方法、返回值选择。</li>
</ol>
<h1 id="讲跳表：为什么Redis一定要用跳表来实现有序集合"><a href="#讲跳表：为什么Redis一定要用跳表来实现有序集合" class="headerlink" title="讲跳表：为什么Redis一定要用跳表来实现有序集合"></a>讲跳表：为什么Redis一定要用跳表来实现有序集合</h1><blockquote>
<ul>
<li>二分查找的底层是依赖于数组随机访问特性来实现的。如果数据存储在链表上，我们用折半的思想对链表进行改造，改造的数据结构叫跳表（Skip list）。</li>
<li>跳表：各方面都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作。甚至可以替代红黑树。这种链表加多级索引的结构，就是跳表 </li>
</ul>
</blockquote>
<h2 id="如何理解”跳表”？"><a href="#如何理解”跳表”？" class="headerlink" title="如何理解”跳表”？"></a>如何理解”跳表”？</h2><ul>
<li><p>即使在一个有序的链表中，查找某个数据，也是要从头到尾遍历，时间复杂度O(n)。</p>
</li>
<li><p>如果我们对链表建立”索引”。</p>
<p><img alt="image-20191111082942008" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tspayezdj30lv07awi3.jpg" class="lazyload"></p>
<ul>
<li><p>我们把抽出来的那一级叫做索引或索引层，加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了 。查找62节点，只需要遍历11个节点</p>
<p><img alt="image-20191111083301463" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tssqcgrij30kc0a20w3.jpg" class="lazyload"></p>
</li>
</ul>
</li>
<li><p>跳表的时间复杂度O(logn)，基于链表实现的二分查找。</p>
</li>
<li><p>跳表的空间复杂度O(n)，每两个结点会抽出一个结点作为上一级索引的结点（可变） 。</p>
</li>
</ul>
<h2 id="实际开发：空间换时间思想"><a href="#实际开发：空间换时间思想" class="headerlink" title="实际开发：空间换时间思想"></a>实际开发：空间换时间思想</h2><blockquote>
<p>在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引只需要存储关键值和几个指针，并不需要存储对象。所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。 </p>
</blockquote>
<h2 id="跳表：高效的动态插入和删除O-logn"><a href="#跳表：高效的动态插入和删除O-logn" class="headerlink" title="跳表：高效的动态插入和删除O(logn)"></a>跳表：高效的动态插入和删除O(logn)</h2><ul>
<li>插入问题：要保证链表的有序性，根据跳表的查找时间复杂度为O(logn)+链表的插入复杂度O(1)</li>
<li>删除问题：删除要获取前驱节点，使用双向链表就能解决这个问题了。</li>
</ul>
<h2 id="跳表：索引动态更新"><a href="#跳表：索引动态更新" class="headerlink" title="跳表：索引动态更新"></a>跳表：索引动态更新</h2><blockquote>
<ul>
<li>当插入数据太多，有可能出现某2个索引节点之间数据非常多。极端情况下，跳表有可能会退化为单链表。</li>
<li>链表是一种动态数据结构，需要手动维护链表大小和索引之间的平衡。<ul>
<li>红黑树和AVL树通过左右旋的方式保持左右子树的大小平衡。</li>
</ul>
</li>
<li>跳表维护平衡性：<ol>
<li>随机函数：随机函数生成了值K，那我们就将这个结点添加到第一 级到第K级这K级索引中。 </li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="问题解答-6"><a href="#问题解答-6" class="headerlink" title="问题解答"></a>问题解答</h2><ul>
<li>为什么Redis要用跳表来实现有序集合，而不是红黑树？<ol>
<li>Redis中的有序集合是通过散列表和跳表实现的。</li>
<li>跳表实现相对比较容易，容易理解，好写，可读性好。</li>
<li>不过，跳表也不能完全替代红黑树 ，很多编程语言的Map都是通过红黑树实现。而跳表是没有现成的。</li>
</ol>
</li>
</ul>
<h1 id="讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的"><a href="#讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的" class="headerlink" title="讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的"></a>讲散列表（上）：Word文档中的单词拼写检查功能是如何实现的</h1><h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><blockquote>
<ol>
<li>散列表的英文是”Hash Table”，也叫哈希表或者Hash表。</li>
<li>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</li>
<li>应用场景：快速查找编号对应的选手信息。<ul>
<li>参赛选手的编号为数组下标，数组存储选手信息。</li>
</ul>
</li>
<li>这就是典型的散列思想。其中，参赛选手的编号我们叫作键(key)或者关键字。我们用它来标识一个选手。我们把参赛编号 转化为数组下标的映射方法就叫作<strong><code>散列函数</code></strong>(或“Hash函数”“哈希函数”)，而散列函数计算得到的值就叫作散列值(或“Hash 值”“哈希值”) </li>
</ol>
</blockquote>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><blockquote>
<ul>
<li><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散 列函数计算得到的散列值。 </p>
</li>
<li><p>如何构建散列函数，三点基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数。</li>
<li>if key1 = key2 ，那hash(key1) = hash(key2)</li>
<li>if key2 != key2 ，那hash(key1) != hash(key2)</li>
</ol>
</li>
<li><p>根据第三点，我们谈谈如何解决散列冲突。</p>
</li>
</ul>
</blockquote>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><ul>
<li>我们常用的散列冲突解决办法有两大类：开放寻址法(open addressing)和链表法(chaining)</li>
</ul>
<h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><blockquote>
<ol>
<li>开放寻址法的核心思想是，如果有了散列冲突，我们就重新探测一个空闲位置，将其插入。</li>
<li>如何重新探测新的位置呢？<ul>
<li>线性探测(Linear Probing)：探测步长是1</li>
<li>二次探测(Quadratic Probing)：探测步长是线性的原来二次方</li>
<li>双重散列(Double hashing)：多个散列函数</li>
</ul>
</li>
<li><code>装载因子</code>:表示空位的多少 ，保证散列表中有一定比例的空闲槽位 ，减少散列冲突。<ul>
<li>计算公式：散列表装载因子=填入表中的元素个数/散列表的长度</li>
<li>所以装载因子越大（1），说明空闲位置越小，冲突越多，散列表的性能就下降越严重。</li>
</ul>
</li>
<li>todo：请思想线程探测是怎么实现插入、查找、删除</li>
</ol>
</blockquote>
<h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><blockquote>
<ol>
<li><p>链表法是一种更加常用的散列冲突的解决办法。</p>
<p><img alt="image-20191111094640710" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tuxd4a3pj30lj0aejvl.jpg" class="lazyload"></p>
</li>
<li><p>当散列冲突的时候，通过链表直接拼接在一起。</p>
</li>
<li><p>插入、查找、删除在分配均匀的散列表的时间复杂度为O(1)</p>
</li>
</ol>
</blockquote>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>直接把20w单词（2MB）构建一个散列表，直接到散列表中查找这个元素是否存在。</p>
<h1 id="讲散列表（中）：如何打造一个工业级水平的散列表"><a href="#讲散列表（中）：如何打造一个工业级水平的散列表" class="headerlink" title="讲散列表（中）：如何打造一个工业级水平的散列表"></a>讲散列表（中）：<strong>如何打造一个工业级水平的散列表</strong></h1><blockquote>
<p>散列表的查询效率不能笼统地说是O(1)，它跟散列函数，装载因子、散列冲突有关。应该这样描述：在分配均匀的散列表中，查找、插入、删除的时间复杂度为O(1)。</p>
<p>在一些极端或者恶意攻击的情况下，在基于链表解决散列冲突的情况下，散列函数设计不好，散列表就会退化为链表。</p>
<p>问题：如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的 急剧下降，并且能抵抗散列碰撞攻击? </p>
</blockquote>
<h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><ol>
<li>设计散列函数的要求？<ul>
<li>散列函数的设计不能太复杂</li>
<li>散列函数生成的值要尽可能随机并且均匀分布。</li>
</ul>
</li>
</ol>
<h2 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h2><ul>
<li>采用动态扩容的思想来解决，那我们思考下数组、栈、队列是怎么实现动态扩容的。</li>
<li>但是扩容之后，所有的数据都要经过散列函数重新计算在散列表中的位置。<ul>
<li>时间复杂度O(n)</li>
<li>但是用摊还分析法 ，平均插入的时间复杂度还是O(1)</li>
</ul>
</li>
</ul>
<h2 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h2><ul>
<li>如何解决”一次性”扩容重新计算和插入成本太高的问题？</li>
</ul>
<blockquote>
<ul>
<li>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后， 我们只申请新空间，但并不将老的数据搬移到新散列表中。 </li>
</ul>
<p><img alt="image-20191112085602466" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uz30m2tqj30l60d9qah.jpg" class="lazyload"></p>
<ul>
<li>但是查询操作，需要查询新老两个散列表。</li>
</ul>
</blockquote>
<h2 id="如何选择冲突解决办法？"><a href="#如何选择冲突解决办法？" class="headerlink" title="如何选择冲突解决办法？"></a>如何选择冲突解决办法？</h2><blockquote>
<ul>
<li>解决散列冲突的两种主要方法：开放寻址法和链表法。<ol>
<li>Java中LinkedHashMap就采用了链表法解决冲突</li>
<li>ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。 </li>
</ol>
</li>
<li>这两种散列冲突解决办法有什么优势和劣势，适用场景又是什么？</li>
</ul>
</blockquote>
<h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><blockquote>
<ol>
<li>存储在数组中，可以有效地利用CPU缓存加快查询速度。序列化代价小。</li>
<li>缺点：删除元素特殊标志。装载因子不能太大，更加消耗内存。</li>
<li>总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是<strong>Java</strong>中的<strong>ThreadLocalMap</strong>使用开 放寻址法解决散列冲突的原因。 </li>
</ol>
</blockquote>
<h3 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h3><blockquote>
<ol>
<li><p>内存利用率更高，不用事先申请好内存。</p>
</li>
<li><p>装载因子容忍度更高，只要散列函数的值随机均匀，即便装载 因子变成10，也就是链表的⻓度变⻓了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。 </p>
</li>
<li><p>缺点：链表空间不连续，相对存储数据的指针大小空间问题。</p>
</li>
<li><p>我们对链表法稍加改造，可以实现一个更加高效的散列表。 </p>
<ul>
<li><p>链表更改为：跳表、红黑树等。查询的时间复杂度也O(logn)</p>
<p><img alt="image-20191112091059570" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uzijp0i9j30cm096q4w.jpg" class="lazyload"></p>
</li>
</ul>
</li>
<li><p>总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加 灵活，支持更多的优化策略，比如用红黑树代替链表。 </p>
</li>
</ol>
</blockquote>
<h2 id="Java中的HashMap分析"><a href="#Java中的HashMap分析" class="headerlink" title="Java中的HashMap分析"></a>Java中的HashMap分析</h2><ol>
<li><p>初始化大小</p>
<ul>
<li>HashMap的初始化大小为16，也可以手动设置，减少扩容次数，大大提高HashMap的性能。</li>
</ul>
</li>
<li><p>装载因子和动态扩容</p>
<ul>
<li>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity(capacity表示散列表的容量)的时候，就会启动扩容， 每次扩容都会扩容为原来的两倍大小。 </li>
</ul>
</li>
<li><p>散列冲突解决办法</p>
<ul>
<li>HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过⻓的情况 </li>
<li>在JDK1.8版本中，为了对HashMap做进一步优化，我们引入了红黑树。而当链表⻓度太⻓(默认超过8)时，链表就转 换为红黑树。 </li>
</ul>
</li>
<li><p>散列函数</p>
<ul>
<li><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>主要讲了三个主题：如何设计散列函数，如何根据装载因 子动态扩容，以及如何选择散列冲突解决方法。 </p>
<ol>
<li>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每 个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。 </li>
<li>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情况下，链表法更加普 适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。 </li>
<li>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现 装载因子过高的情况。这个时候，我们就需要启动动态扩容。 </li>
</ol>
<h1 id="讲散列表（下）：为什么散列表和链表经常会一起使用"><a href="#讲散列表（下）：为什么散列表和链表经常会一起使用" class="headerlink" title="讲散列表（下）：为什么散列表和链表经常会一起使用"></a>讲散列表（下）：为什么散列表和链表经常会一起使用</h1><blockquote>
<p>总结之前链表和散列表一起使用的例子</p>
<ol>
<li>LRU缓存淘汰算法</li>
<li>Redis有序集合（改良的跳表）</li>
<li>Java LinkedHashMap</li>
</ol>
</blockquote>
<h2 id="栗子1：LRU缓存淘汰算法"><a href="#栗子1：LRU缓存淘汰算法" class="headerlink" title="栗子1：LRU缓存淘汰算法"></a>栗子1：LRU缓存淘汰算法</h2><p><img alt="image-20191113081438591" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8w3i939e3j30jo0d2jxn.jpg" class="lazyload"></p>
<ol>
<li>双向链表和散列表组合。</li>
<li>链表中的每个结点处理存储数据(data)、前驱指针(prev)、后继指针(next)之外，还新增 了一个特殊的字段hnext。 前驱和后继指针是为了将结点串在双向链表中，<strong>hnext</strong>指针是为了将结点串在散列表的拉链中。 </li>
<li>查找、删除、新增元素的时间复杂度都为O(1)</li>
</ol>
<h2 id="栗子2：Redis有序集合"><a href="#栗子2：Redis有序集合" class="headerlink" title="栗子2：Redis有序集合"></a>栗子2：Redis有序集合</h2><p>每个成员对象有两个重要的属性，<strong>key</strong>(键值)和<strong>score</strong>(分值)。我们不仅会通过score来查找数据，还会通过key来查找数据。 </p>
<h2 id="栗子3：Java-LinkedHashMap"><a href="#栗子3：Java-LinkedHashMap" class="headerlink" title="栗子3：Java LinkedHashMap"></a>栗子3：Java LinkedHashMap</h2><p>如何理解LinkHashMap中的”Linked”？</p>
<ul>
<li>不仅仅代表它是通过链表法解决散列冲突的 。</li>
<li>实际上，它不仅支持按照插入顺序遍历数 据，还支持按照访问顺序来遍历数据。 </li>
<li>这就是一个天生支持LRU缓存淘汰策略的缓存系统。</li>
<li>总结：<strong>LinkedHashMap</strong>是通过双向链表和散列表这两种数据结构组合实现的。<strong>LinkedHashMap</strong>中 的<strong>“Linked”</strong>实际上是指的是双向链表，并非指用链表法解决散列冲突。 </li>
</ul>
<h2 id="内容总结-1"><a href="#内容总结-1" class="headerlink" title="内容总结"></a>内容总结</h2><p>为什么散列表和链表经常一起使用？</p>
<ol>
<li>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律 存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中 的数据拷⻉到数组中，然后排序，再遍历。 </li>
<li>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排 序，那效率势必会很低。为了解决这个问题，我们将散列表和链表(或者跳表)结合在一起使用。 </li>
</ol>
<h1 id="讲哈希算法（上）：如何防止数据库中的用户信息被脱库"><a href="#讲哈希算法（上）：如何防止数据库中的用户信息被脱库" class="headerlink" title="讲哈希算法（上）：如何防止数据库中的用户信息被脱库"></a>讲哈希算法（上）：如何防止数据库中的用户信息被脱库</h1><h2 id="什么是哈希算法？"><a href="#什么是哈希算法？" class="headerlink" title="什么是哈希算法？"></a>什么是哈希算法？</h2><blockquote>
<ol>
<li>因为散列、哈希在英文都是Hash。</li>
<li>哈希算法：<code>将任意⻓度的二进制值串映射为固定⻓度的二进制值串</code> 。而通过原始数据映射之后得到的二进制值串就是哈希值 。</li>
<li>如何设计一个优秀的哈希算法？（栗子：MD5哈希算法）<ol>
<li>从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法) </li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同; </li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小; </li>
<li>哈希算法的执行效率要尽量高效，针对较⻓的文本，也能快速地计算出哈希值。 </li>
</ol>
</li>
<li>哈希算法应用：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分 片、分布式存储。 </li>
</ol>
</blockquote>
<h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><ol>
<li>常用的加密哈希算法：MD5、SHA、DES、AES。</li>
<li>为什么哈希算法无法做到0冲突？<ul>
<li>根据鸽巢原理（也叫抽屉原理），10个鸽子，9个鸽巢。必定有2个鸽子在1个鸽巢。</li>
<li>因为哈希算法产生的哈希值的长度是固定且有限的。所以穷举完所有+1,必定有冲突。</li>
<li>但是这是很那破解的，能够哈希值越大，冲突概率越小。</li>
</ul>
</li>
</ol>
<h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>栗子：如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息(比如图片名称)来比 对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢? </p>
<p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取100个字节，从中间取 100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法(比如MD5)，得到一个哈希字符串，用 它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。 </p>
<p>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要 查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标 识。 </p>
<h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>栗子：BT下载的原理是基于P2P协议的。我们从多个机器上并行下载一个2GB的 电影，这个电影文件可能会被分割成很多文件块(比如可以分成100块，每块大约20MB) 。在网络传输之后，如何确保数据块没被串改呢？</p>
<p>利用哈希算法特点2，数据敏感。在把多个文件块合成之前，进行哈希计算。是否跟源文件的哈希值相等。</p>
<h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>散列函数也是哈希算法的一种应用。</p>
<h1 id="讲哈希算法（下）：哈希算法在分布式系统中有哪些应用"><a href="#讲哈希算法（下）：哈希算法在分布式系统中有哪些应用" class="headerlink" title="讲哈希算法（下）：哈希算法在分布式系统中有哪些应用"></a>讲哈希算法（下）：哈希算法在分布式系统中有哪些应用</h1><h2 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h2><p>载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞(session sticky)的负载均 衡算法呢?也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。 </p>
<ul>
<li>使用一张映射关系表（次）：<ol>
<li>客户端很多，映射表大，查看耗时并且浪费内存</li>
<li>客户端上下线，服务器扩容，映射表都会失效，维护成本高。</li>
</ol>
</li>
<li>客服端ip计算哈希值，然后取模，得到服务器编号。<ol>
<li>我们可以通过哈希算法，对客户端<strong>IP</strong>地址或者会话<strong>ID</strong>计算哈希值，将取 得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。  </li>
</ol>
</li>
</ul>
<h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><blockquote>
<h3 id="如何统计大文件”搜索关键词”出现的次数？"><a href="#如何统计大文件”搜索关键词”出现的次数？" class="headerlink" title="如何统计大文件”搜索关键词”出现的次数？"></a>如何统计大文件”搜索关键词”出现的次数？</h3><ul>
<li>问题：第一，搜索日志很大，一台机器内存无法放下。第二，一台机器处理，时间比较长。</li>
<li>解决：我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。 （MapReduce的基本设计思想 ）</li>
<li>具体：我们用n台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计 算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。 </li>
</ul>
<h3 id="如何快速判断图片是否存在图库中？"><a href="#如何快速判断图片是否存在图库中？" class="headerlink" title="如何快速判断图片是否存在图库中？"></a>如何快速判断图片是否存在图库中？</h3><ul>
<li>问题：根据我们上一节讨论：对图片取唯一标识（哈希算法），然后存储在散列表中。如果1亿张图片，是无法存储在一台机器上的散列表中。</li>
<li>解决：对数据分片。</li>
<li>具体：我们准备n台机器，让每台机器只维护某一部分图片对应的散列表。我们 每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图 片的唯一标识和图片路径发往对应的机器构建散列表。 </li>
<li>数学科普：这1亿张图片构建散列表大约需要多少台机器？<ol>
<li>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过MD5来计算哈希值，那⻓度就是128比特，也 就是16字节。文件路径⻓度的上限是256字节，我们可以假设平均⻓度是128字节。如果我们用链表法来解决冲突，那还需要 存储指针，指针只占用8字节。所以，散列表中每个数据单元就占用152字节(这里只是估算，并不准确) </li>
<li>假设一台机器的内存大小为2GB，散列表的装载因子为0.75，那一台机器可以给大约1000万(2GB*0.75/152)张图片构建散 列表。所以，如果要对1亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要 投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。 </li>
</ol>
</li>
<li>总结：实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。 </li>
</ul>
</blockquote>
<h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>分布式存储应用很多，常见的都是给定的值通过哈希算法计算得到哈希值，然后对机器数量取模。</p>
<ul>
<li>问题：如果机器库容，那取余运算结果就不对。就要对所有数据都要重新计算哈希值。如果是缓存机器，那就会发生雪崩效应。</li>
<li>解决：一致性哈希算法。（解决分布式系统的扩容、缩容导致数据大量搬移的难题 ）<ol>
<li>假设我们有k个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成m个小区间(m远大于k)，每个机器负责m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。 </li>
<li>除此之外，它还会借助一个虚拟的环和虚拟结点，更加优美地实现出来。 </li>
</ol>
</li>
</ul>
<h1 id="讲二叉树基础（上）：什么样的二叉树适合用数组来存储"><a href="#讲二叉树基础（上）：什么样的二叉树适合用数组来存储" class="headerlink" title="讲二叉树基础（上）：什么样的二叉树适合用数组来存储"></a>讲二叉树基础（上）：什么样的二叉树适合用数组来存储</h1><blockquote>
<p>前面我们讲的都是都是线性结构：数组、链表、栈、队列等等。</p>
<p>现在我们开始讲非线性结构：树、图等等的内容。</p>
<ol>
<li>树、二叉树</li>
<li>二叉查找树</li>
<li>平衡二叉查找树、红黑树</li>
<li>递归树</li>
</ol>
<p>问题：二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</p>
</blockquote>
<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><blockquote>
<h3 id="树相关的概念"><a href="#树相关的概念" class="headerlink" title="树相关的概念"></a>树相关的概念</h3><ol>
<li><p>父节点、子节点、兄弟节点、根节点、叶子节点。</p>
</li>
<li><p>高度、深度、层</p>
<p><img alt="image-20191114083317253" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8x9nxkpztj30hm09dq73.jpg" class="lazyload"></p>
<p><img alt="image-20191114083342698" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8x9od0bgmj30j00a00uh.jpg" class="lazyload"></p>
</li>
</ol>
</blockquote>
<h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><blockquote>
<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><ol>
<li>二叉树：每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。 </li>
<li>满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。</li>
<li>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大 。</li>
</ol>
<p><img alt="image-20191114084232716" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8x9xk74qvj30kt0b9gok.jpg" class="lazyload"></p>
</blockquote>
<h2 id="如何表示（存储）一棵二叉树？"><a href="#如何表示（存储）一棵二叉树？" class="headerlink" title="如何表示（存储）一棵二叉树？"></a>如何表示（存储）一棵二叉树？</h2><blockquote>
<p>常见的有两种方法：</p>
<ol>
<li>一种基于指针或者引用的二叉链式存储法（大部分二叉树都是这样存储）</li>
<li>一种是基于数组的顺序存储法<ul>
<li>如果节点X存储在数组中下标为i的位置（完全二叉树） <ul>
<li>下标为2 * i 的位置存储的就是左子节点 </li>
<li>下标为2 * i + 1的位置存储 的就是右子节点 </li>
<li>下标为i/2的位置存储就是它的父节点 </li>
<li>根节点会存储在下标为1的位置 </li>
</ul>
</li>
<li>完全二叉树的最佳存储方式，非完全二叉树会浪费更多的数组空间。</li>
<li>堆其实就是一种完全二叉树，最常用的存储方式就是数组。 </li>
</ul>
</li>
</ol>
<p><img alt="image-20191114085226004" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8xa7udt9ij30df09zac1.jpg" class="lazyload"></p>
</blockquote>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><blockquote>
<p>如何遍历二叉树中的所有节点？</p>
<ol>
<li><p>前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 </p>
</li>
<li><p>中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 </p>
</li>
<li><p>后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
<li><p>一图胜前文：时间复杂度O(n)</p>
<p><img alt="image-20191114090214856" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8xai23o3ej30lr09hq92.jpg" class="lazyload"></p>
</li>
</ol>
<p>代码实现：递归实现</p>
<p>写递推公式：假设要解决问题A，分解为子问题B、C（递）。那B和C的问题已经解决了，然后再看如何利用B和C来解决问题A（归）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式:</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line">中序遍历的递推公式:</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line">后序遍历的递推公式:</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	print root <span class="comment">// 此处为伪代码，表示打印root节点 </span></span><br><span class="line">	preOrder(root-&gt;left); </span><br><span class="line">	preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">	inOrder(root-&gt;left);</span><br><span class="line">	print root <span class="comment">// 此处为伪代码，表示打印root节点 </span></span><br><span class="line">	inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">	postOrder(root-&gt;left); </span><br><span class="line">	postOrder(root-&gt;right);</span><br><span class="line">	print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树"><a href="#讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树" class="headerlink" title="讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树"></a>讲二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树</h1><blockquote>
<p>二叉查找树：支持动态数据集合的快速插入、删除、查找操作。散列表都支持这些操作，并且时间复杂度O(1)。</p>
<p>问题：既然有了这么 高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢?有没有哪些地方是散列表做不了，必须要用二叉树来做的 呢? </p>
</blockquote>
<h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><blockquote>
<h3 id="二叉查找树的概念"><a href="#二叉查找树的概念" class="headerlink" title="二叉查找树的概念"></a>二叉查找树的概念</h3><ol>
<li><p>二叉查找树：支持动态数据集合的快速插入、删除、查找操作。又名：二叉搜索树、二叉排序树。</p>
</li>
<li><p>二叉查找树结构特点：</p>
<ul>
<li>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个 节点的值，而右子树节点的值都大于这个节点的值。  </li>
</ul>
</li>
<li><p>一图胜千文：</p>
<p><img alt="image-20191114092235848" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8xb38a9bgj30j808ngnp.jpg" class="lazyload"></p>
</li>
</ol>
</blockquote>
<h3 id="二叉查找树的查找"><a href="#二叉查找树的查找" class="headerlink" title="二叉查找树的查找"></a>二叉查找树的查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树：查询操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树：插入操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><blockquote>
<p>二叉查找树的查找、插入操作比较容易理解。但是删除操作就比较复杂，要根据删除节点的子节点个数不同，分为三种情况。</p>
<ol>
<li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。比如图中的删除节点55。 </li>
<li>如果要删除的节点只有一个子节点(只有左子节点或者右子节点)，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。 </li>
<li>如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换 到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果有左子结点，那就不是最小节点 了)，所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18。 </li>
</ol>
<p><img alt="image-20191114094545802" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8xbrc1585j30kp0ab78a.jpg" class="lazyload"></p>
<p>骚操作：关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除” 。浪费点内存，对查找和新增无影响。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">    Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">        <span class="keyword">else</span> p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">        Node minP = p.right;</span><br><span class="line">        Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">        p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">        pp = minPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">    Node child; <span class="comment">// p的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">    <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">    <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h3><blockquote>
<ul>
<li>二叉查找树除了支持快速查找、插入、删除操作之外。</li>
<li>还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。</li>
<li>还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。</li>
</ul>
</blockquote>
<h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><ul>
<li><p>我们上面谈论都是键值不同的的情况下，但实际开发我们二叉查找树是存在键值相同的情况。</p>
<ol>
<li>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构， 把值相同的数据都存储在同一个节点上。 </li>
<li>第二种方法比较不好理解，不过更加优雅。<ul>
<li>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要 插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。 </li>
<li>查找和删除的操作链路更长：要一直查找到叶子节点，判断是否有重复的元素。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><ul>
<li><p>对于同一集合数据：1,2,3,4,5,6,7,8,9。可以构建多种二叉查找树。</p>
<p><img alt="image-20191115083551736" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zj8zersej30kr0d6n06.jpg" class="lazyload"></p>
<ul>
<li>最糟糕的情况是：二叉查找树退化为链表，那查找时间复杂度退化为O(n)</li>
<li>最理想的情况是：<strong>二叉查找树是一棵完全二叉树。</strong><ul>
<li>查找、插入、删除的时间复杂度：<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong> </li>
<li>也就是时间复杂度O(logn)</li>
</ul>
</li>
</ul>
</li>
<li><p>如何求一棵包含n个节点的完全二叉树的高度？</p>
<ul>
<li>我们换个角度出发：树的高度=最大层数-1</li>
<li>完全二叉树的层数小于等于log2n +1， 完全二叉树的高度小于等于log2n。 </li>
</ul>
</li>
<li><p>在极度不平衡的二叉查找树的性能是不能满足我们的。我们需要构建一种无论数据怎么插入、删除都是比较平衡的二叉查找树，树的高度logn，那crud的复杂度就是O(logn)==&gt;平衡二叉查找树。</p>
</li>
</ul>
<h2 id="问题解答-7"><a href="#问题解答-7" class="headerlink" title="问题解答"></a>问题解答</h2><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效。而二叉查找树在 比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要 用二叉查找树呢? </p>
<ol>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍 历，就可以在O(n)的时间复杂度内，输出有序的数据序列。 </li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常 用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。 </li>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小， 所以实际的查找速度可能不一定比O(logn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。 </li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东⻄很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡 二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 </li>
</ol>
<h1 id="讲红黑树（上）：为什么工程中都用红黑树这种二叉树"><a href="#讲红黑树（上）：为什么工程中都用红黑树这种二叉树" class="headerlink" title="讲红黑树（上）：为什么工程中都用红黑树这种二叉树"></a>讲红黑树（上）：为什么工程中都用红黑树这种二叉树</h1><blockquote>
<p>终于开始讲我们心心期待的红黑树了，结合我们上面讲的。</p>
<ol>
<li>我们已经将了树、二叉树、二叉查找树。其中二叉查找树是最常用的一种二叉树。</li>
<li>二叉查找树支持快速的crud，在理想的情况下（完全二叉树），时间复杂度跟树的高度成正比，为O(logn)</li>
<li>接下来我们就要讲如何维持二叉查找树的平衡，也就是平衡二叉查找树（红黑树）。</li>
</ol>
</blockquote>
<h2 id="什么是”平衡二叉查找树”？"><a href="#什么是”平衡二叉查找树”？" class="headerlink" title="什么是”平衡二叉查找树”？"></a>什么是”平衡二叉查找树”？</h2><blockquote>
<p>平衡二叉树的定义：二叉树中任意一个节点的左右子树的高度相差不能大于1 。</p>
<ul>
<li>完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树 </li>
</ul>
<p>平衡二叉查找树定义：平衡二叉树+二叉查找树</p>
<ul>
<li>最先被发明的平衡二叉查找树是<strong>AVL树</strong>，它严格 符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过1，是一种高度平衡的二叉查找树。 </li>
<li>但是很多平衡二叉查找树其实并没有严格符合上面的定义（平衡二叉树）。包括红黑树</li>
</ul>
<p>平衡二叉查找树的运用：</p>
<ul>
<li>平衡二叉查找树就是为了解决时间复杂度退化的问题。</li>
<li>平衡二叉查找树中<strong>“</strong>平衡<strong>”</strong>的意思，其实就是让整棵树左右看起来比较<strong>“</strong>对称<strong>”</strong>、比较<strong>“</strong>平衡<strong>”</strong>，不要出现左子树很高、右子 树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。 </li>
<li>只要时间复杂度在O(logn)，就是一个合格的平衡二叉查找树。</li>
</ul>
</blockquote>
<h2 id="如何定义一棵”红黑树”？"><a href="#如何定义一棵”红黑树”？" class="headerlink" title="如何定义一棵”红黑树”？"></a>如何定义一棵”红黑树”？</h2><p>平衡二叉查找树其实有很多，比如，Splay Tree(伸展树)、Treap(树堆)等，但是我们提到平衡二叉查找树，听到的基本 都是红黑树。它的出镜率甚至要高于“平衡二叉查找树”这几个字，有时候，我们甚至默认平衡二叉查找树就是红黑树，那我们 现在就来看看这个“明星树”。 </p>
<blockquote>
<p>红黑树的定义：</p>
<ol>
<li>根节点是黑色的; </li>
<li>每个叶子节点都是黑色的空节点(NIL)，也就是说，叶子节点不存储数据; </li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的; </li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点; </li>
</ol>
<p><img alt="image-20191116073530820" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zj8h1kdrj30jj08gmyy.jpg" class="lazyload"></p>
<p>红黑树总结：</p>
<ul>
<li>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树(满二叉树或完全二叉树)的高度大约是log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近log2n就好了。 </li>
<li>红黑树的高度只比高度平衡的AVL树的高度(log2n)仅仅大了一倍 </li>
</ul>
</blockquote>
<h2 id="问题解答-8"><a href="#问题解答-8" class="headerlink" title="问题解答"></a>问题解答</h2><p>我们前面提到Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退 化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。 </p>
<p>AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更 多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。 </p>
<p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。  </p>
<h1 id="Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树"><a href="#Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树" class="headerlink" title="Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树"></a>Todo：讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</h1><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>红黑树很难学，那我们要如何学习呢？</p>
<p>我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。对于红黑 树，也不例外。你如果能搞懂这几个问题，其实就已经足够了。 </p>
<p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高 度近似log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是O(logn)。 </p>
<p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到 它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。 </p>
<h1 id="讲堆和堆排序：为什么说堆排序没有快速排序快"><a href="#讲堆和堆排序：为什么说堆排序没有快速排序快" class="headerlink" title="讲堆和堆排序：为什么说堆排序没有快速排序快"></a>讲堆和堆排序：为什么说堆排序没有快速排序快</h1><blockquote>
<p>“堆(Heap)”：是一种特殊的树，应用最多的是堆排序，堆排序是一种原地的、时间复杂度为O(nlogn)。</p>
</blockquote>
<h2 id="如何理解”堆”"><a href="#如何理解”堆”" class="headerlink" title="如何理解”堆”?"></a>如何理解”堆”?</h2><ul>
<li><p>堆是一种特殊的树，需要满足下面的条件</p>
<ol>
<li>堆是一棵完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值 </li>
</ol>
</li>
<li><p>图解堆：对于同一组数据，我们可以构建多种不同形态的堆</p>
</li>
</ul>
<p><img alt="image-20191116075927640" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zjxcx1ivj30ii0eiq6s.jpg" class="lazyload"></p>
<h2 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h2><p>要实现一个堆，我们需要知道<strong>堆都支持哪些操作</strong>以及<strong>如何存储一个堆</strong></p>
<ul>
<li><p>如何存储一个堆？</p>
<ol>
<li>堆是一棵完全二叉树，使用数组来存储是非常好的，既不会浪费数组的存储空间，也不用使用链表的指针。</li>
<li>如果节点X存储在数组中下标为i的位置（完全二叉树） ,下标从1开始<ul>
<li>下标为2 * i 的位置存储的就是左子节点 </li>
<li>下标为2 * i + 1的位置存储 的就是右子节点 </li>
<li>下标为i/2的位置存储就是它的父节点 </li>
<li>根节点会存储在下标为1的位置 </li>
</ul>
</li>
<li>如果节点X存储在数组中下标为i的位置（完全二叉树） ,下标从0开始<ul>
<li>左节点2<em>*i+1</em></li>
<li>右节点2*i+2（下标0开始计算）</li>
</ul>
</li>
</ol>
</li>
<li><p>堆支持哪些操作？</p>
<blockquote>
<ol>
<li><h3 id="往堆中插入一个元素"><a href="#往堆中插入一个元素" class="headerlink" title="往堆中插入一个元素"></a>往堆中插入一个元素</h3><ul>
<li><p>我们把数据插入堆之后，要继续满足堆的两个特性。</p>
</li>
<li><p>一般我们把插入的数据放到堆的最后面，我们把重新满足堆特性的过程叫做堆化（heapify）</p>
<ul>
<li>从下往上</li>
<li>从上往下</li>
</ul>
</li>
<li><p>图解：</p>
</li>
</ul>
</li>
</ol>
<p><img alt="image-20191116081806566" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zkgr276hj30ln0ej7ac.jpg" class="lazyload"></p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 堆插入操作：自下而上堆化，数组从下标0开始,大顶堆</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span>; <span class="comment">// 堆满了</span></span><br><span class="line">++count;</span><br><span class="line">a[count] = data;</span><br><span class="line"><span class="keyword">int</span> i = count;</span><br><span class="line"><span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i / <span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">   swap(a, i, i / <span class="number">2</span>); <span class="comment">// swap()函数作用:交换下标为i和i/2的两个元素</span></span><br><span class="line">   i = i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><ul>
<li><p>方案一（不好）：直接拿堆顶，从堆顶元素由上到下，移除堆顶元素。</p>
<ul>
<li>出现数组空洞</li>
<li>最后堆化出来的堆并不满足完全二叉树的特点。</li>
</ul>
</li>
<li><p>方案二（好）：把最后一个节点放到堆顶，然后从上往下堆化。</p>
<ul>
<li>无数组空洞问题。完全符合完全二叉树</li>
</ul>
</li>
<li><p>图解<img alt="image-20191117101656604" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90tirgbrpj30w80nagzv.jpg" class="lazyload"></p>
</li>
<li><p>代码实现</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>堆操作：插入、删除的时间复杂度分析</p>
<ol>
<li>完全二叉树的任何crud，时间复杂度分析都可以总结为跟树的高度成正比，而完全二叉树的高度不会超过O(logn)。curd在堆的操作中，主要的操作是堆化，因此时间复杂度为O(logn)</li>
</ol>
</li>
</ul>
<h2 id="如何基于堆实现排序"><a href="#如何基于堆实现排序" class="headerlink" title="如何基于堆实现排序"></a>如何基于堆实现排序</h2><blockquote>
<p>我们先回忆总结一下之前学习的排序算法。分类角度：时间复杂度、稳定性、原地算法等</p>
<ol>
<li>时间复杂度O(n²)：冒泡排序、插入排序、选择排序</li>
<li>时间复杂度O(nlogn)：归并排序、快速排序</li>
<li>线性时间复杂度O(n)：桶排序、计数排序、基数排序</li>
</ol>
<p>新的排序算法，基于堆（特殊的树）这种结构实现的堆排序算法：</p>
<ul>
<li>时间复杂度非常稳定O(nlogn)，原地排序算法。</li>
<li>堆排序的两大步骤：建堆和排序</li>
</ul>
</blockquote>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><ul>
<li><p>建堆有两种方案</p>
<ol>
<li><p>方案一（不佳）：思路类似我们在堆中插入一个元素，数组从前往后插入（堆的尾部），然后每次堆化都是从下往上堆化。</p>
</li>
<li><p>方案二（佳）：从后往前处理数组（第一个非叶子节点（n/2）开始堆化），并且每个数据都是从上往下堆化。 </p>
<ul>
<li><p>图解</p>
<p><img alt="image-20191118084639813" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91wj4juc1j30kz0c10x2.jpg" class="lazyload"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        heapify(a, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i * <span class="number">2</span>]) maxPos = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i * <span class="number">2</span> + <span class="number">1</span>]) maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">        swap(a, i, maxPos);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>建堆的时间复杂度为O(n)。</p>
</li>
<li><p>数学科普时间：对于一棵完全二叉树，数组从下标1开始，那么第一个非叶子节点就是n/2。n/2+1~n的节点都是叶子节点。</p>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>建堆之后，数组中的数据是按照大顶堆的特性来组织的。堆顶元素是最大的元素。接下来的操作类似我们刚才删除堆顶元素，和最后一个元素交换值，并且从上往下堆化，区间在[1,–n]</p>
<ul>
<li><p>图解</p>
<p><img alt="image-20191118090720787" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91x4m3e1hj30km0ed44g.jpg" class="lazyload"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    buildHeap(a, n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, k);</span><br><span class="line">        --k;</span><br><span class="line">        heapify(a, k, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原地排序算法、总时间复杂度O(nlogn)=建堆O(n)+排序O(logn)。注意点：堆的原始数组是从下标0还是下标1开始</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>为什么快速排序要比堆排序的性能好？</p>
<ol>
<li>堆排序数据访问方式没有快速排序友好：cpu缓存层面</li>
<li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要&gt;快速排序：有序度和逆序度，基于比较的排序算法：两个基本操作分别是比较和交换（移动）</li>
</ol>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是:每个节点的值都大于等于(或小于等于)其子树节点 的值。因此，堆被分成了两类，大顶堆和小顶堆。 </p>
<p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的 数据放到数组的最后，然后从下往上堆化;删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆 化。这两个操作时间复杂度都是$O(\log n)$。 </p>
<p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从$\frac{n}{2}$到$1$的 节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素 放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列 了。 </p>
<h1 id="讲堆的应用：如何快速获取到Top10最热门的搜索关键词"><a href="#讲堆的应用：如何快速获取到Top10最热门的搜索关键词" class="headerlink" title="讲堆的应用：如何快速获取到Top10最热门的搜索关键词"></a>讲堆的应用：如何快速获取到Top10最热门的搜索关键词</h1><blockquote>
<p>问题：假设现在我们有一个包含<strong>10</strong>亿个搜索关键词的日志文件，如何能快速获取到热⻔榜<strong>Top 10</strong>的搜索关键词呢? </p>
<p>堆几个重要的应用：优先级队列、求Top K和中位数</p>
</blockquote>
<h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><ul>
<li>实现优先级队列的方式很多，但是用堆来实现优先级队列是最直接、最高效的。堆和优先级队列非常相似，它们只是概念上的区分而已。</li>
<li>优先级队列的应用：很多数据结构和算法都要依赖它，比如：哈夫曼编码、图的最短路径、最小生成树算法等等。<code>java.util.PriorityQueue</code></li>
</ul>
<h3 id="合并有序小文件"><a href="#合并有序小文件" class="headerlink" title="合并有序小文件"></a>合并有序小文件</h3><p>情景：假设有100个小文件，文件存储的都是有序的字符串。如何把为一个大文件？</p>
<ul>
<li>方案一（欠佳）：每次从这个100个文件，取一个字符串加入到数组中，然后循环遍历整个数组取出最小的字符串加入到大文件，并且从数组中删除这个字符串，从取出这个字符串（最小）中的文件再取出下一个字符串比较。</li>
<li>方案二（优秀）：我们使用小顶堆来解决，移除堆顶最小元素之后，每次从最小字符串的文件取出来的字符串加入到堆中。移除堆顶和插入数据，在堆的操作时间复杂度为O(logn)，因为堆是完全二叉树，操作跟树的高度有关。</li>
</ul>
<h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><p>情景：假设我们有一个定时器，定时器有很多定时任务，有些定时任务的cron时间间隔很小(比如1s)，有些定时器任务的时间间隔很长。如何获取定时器下次执行任务的时间？</p>
<ul>
<li>方案一（欠佳）：我们获取最小时间间隔的cron，然后每隔这个时间就遍历任务列表。但是这有下面问题。<ol>
<li>问题一：大部分任务的约定时间隔距离当前时间还有很久，这样你每次扫描全表都是徒劳的，并且浪费系统资源。</li>
<li>问题二：每次都要扫描整个任务表，如果任务表很大的话，会非常耗时。</li>
</ol>
</li>
<li>方案二（优化）：使用优先级队列来解决（小顶堆）,我们只需要取出堆顶，然后计算与当前时间的间隔T，在间隔T之后再移除堆顶元素执行。堆化后，重复上面的步骤。</li>
</ul>
<h2 id="堆的应用二：利用堆求Top-K"><a href="#堆的应用二：利用堆求Top-K" class="headerlink" title="堆的应用二：利用堆求Top K"></a>堆的应用二：利用堆求Top K</h2><p>情景：对于求top k的问题，可以抽象分为两类。一类是针对静态数据，一类是动态数据。无论静态还是动态都适合用堆来解决问题。</p>
<ul>
<li><p>解决思路：维护大小为k的小顶堆就行了。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用堆求解topk问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 动态数据:在100个数据当中求top 10大的数据</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 静态数据也使用该方法求解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-18 14:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_29_TopK</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAP = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_HEAP + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> a = random.nextInt(<span class="number">100</span>);</span><br><span class="line">            list.add(a);</span><br><span class="line">            buildHeap(a);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] aa = list.toArray();</span><br><span class="line">        Arrays.sort(aa);</span><br><span class="line">        System.out.println(Arrays.toString(aa));</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个大小$&#123;MAX_HEAP&#125;的小顶堆，数组从下标1开始存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//堆中没有数据</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || count &lt; MAX_HEAP) &#123;</span><br><span class="line">            insert(a);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">1</span>] &gt;= a) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1、移除堆顶元素。2、插入元素</span></span><br><span class="line">            removeMin();</span><br><span class="line">            insert(a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        arr[count] = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自下而上堆化</span></span><br><span class="line">        <span class="keyword">int</span> i = count;</span><br><span class="line">        <span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[i / <span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">            swap(arr, i, i / <span class="number">2</span>); <span class="comment">// swap()函数作用:交换下标为i和i/2的两个元素</span></span><br><span class="line">            i = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把最后元素移动到堆顶，然后自上而下堆化</span></span><br><span class="line">        arr[<span class="number">1</span>] = arr[count];</span><br><span class="line">        <span class="comment">//arr[count] = 0;</span></span><br><span class="line">        --count;</span><br><span class="line"></span><br><span class="line">        heapfiy();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自上而下堆化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapfiy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= count &amp;&amp; arr[minPos] &gt; arr[i * <span class="number">2</span>]) &#123;</span><br><span class="line">                minPos = i * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= count &amp;&amp; arr[minPos] &gt; arr[i * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                minPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minPos == i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(arr, minPos, i);</span><br><span class="line">            i = minPos;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> pi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[pi];</span><br><span class="line">        arr[pi] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h2><blockquote>
<p>中位数：在一个有序集合当中，奇数的中位数就是$\frac{n}{2}+1$ ，偶数的中位数是$\frac{n}{2}$个和第$\frac{n}{2}+1$（折中选择一个）。</p>
<p>对于静态数据，我们直接把数组排序取值就完成了。</p>
<p>对于动态数据，我们需要借助堆这种结构来解决。</p>
</blockquote>
<ul>
<li><p>解题思路：我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数 据都大于大顶堆中的数据。 </p>
<ol>
<li>n是偶数，我们从小到大排序，那前$\frac{n}{2}$个数据存储在大顶堆中，后$\frac{n}{2}$个数据 存储在小顶堆中。 </li>
<li>n是奇数，情况是类似的，大顶堆就存储$\frac{n} {2}+1$个数据，小顶堆中就存储$\frac{n}{2}$个数据。 </li>
<li>大顶堆中的堆顶元素就是我们要找的中位数。</li>
<li>并且我们要维护大小顶堆元素的个数各一半一半。如果不符合，我们就将一个堆中的数据移动到另一个堆，直到满足这个比例 。</li>
</ol>
</li>
<li><p>图解：</p>
<p><img alt="image-20191119084346799" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9322fg300j30jv0910vc.jpg" class="lazyload"></p>
</li>
</ul>
<h3 id="如何快速求接口的99-响应时间？"><a href="#如何快速求接口的99-响应时间？" class="headerlink" title="如何快速求接口的99%响应时间？"></a>如何快速求接口的99%响应时间？</h3><ul>
<li>数学科普：99百分数和99%的关系，如果将一组数据从小到大排列，这个99百分位数就是大于前面99%数据的那个数据。 <ol>
<li>假设有100个数据，分别是1，2，3，……，100，那99百分位数就是99，因为小于等 于99的数占总个数的99%。 </li>
<li>我们再来看99%响应时间。如果有100个接口访问请求，每个接口请求的响应时间都不同，比如55毫秒、 100毫秒、23毫秒等，我们把这100个接口的响应时间按照从小到大排列，排在第99的那个数据就是99%响应时间，也叫99百 分位响应时间。 </li>
<li>总结一下，如果有n个数据，将数据从小到大排列之后，99百分位数大约就是第n<em>99%个数据，同类，80百分位数大约就 是第n</em>80%个数据。 </li>
</ol>
</li>
<li>实现：假设当前总数据的个数是n，大顶堆中保存n<em>99%个数据，小顶堆中保存n</em>1%个数据。大顶堆堆顶的数据就是我们要找的99%响应时间。 <ol>
<li>如果这个 新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆;如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。 </li>
<li>为了保持大顶堆中的数据占99%，小顶堆中的数据占1%，在每次新插入数据之后，我们都要重新计算，这个时候大顶 堆和小顶堆中的数据个数，是否还符合99:1这个比例。如果不符合，我们就将一个堆中的数据移动到另一个堆，直到满足这个 比例。 </li>
</ol>
</li>
<li>代码：todo</li>
</ul>
<h2 id="问题解答-9"><a href="#问题解答-9" class="headerlink" title="问题解答"></a>问题解答</h2><p>10亿个搜索关键字，在限定内存为1G的情况下，如何查找top 10关键字。</p>
<ol>
<li>求top k问题使用堆的思路来解决。</li>
<li>限定内存情况下，通过数学计算公式，比如：1千万8字节int，占用80MB空间。去计算消耗内存的大小。<ul>
<li>利用哈希算法实现数据的分片。</li>
</ul>
</li>
<li>对分片的数据分别求top 10。再最终汇集求top 10</li>
</ol>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>我们今天主要讲了堆的几个重要的应用，它们分别是:优先级队列、求Top K问题和求中位数问题。 </p>
<ul>
<li><p>优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级 队列，只是称谓不一样罢了。</p>
</li>
<li><p>求Top K问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高 效率的查询Top K的数据。</p>
</li>
<li><p>求中位数实际上还有很多变形，比如求99百分位数据、90百分位数据等，处理的思路都是一样的， 即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求 的数据。 </p>
</li>
</ul>
<h1 id="Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系"><a href="#Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系" class="headerlink" title="Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系"></a>Todo：讲图的表示：如何存储微博、微信等社交网络中的好友关系</h1><h2 id="需要完成的事情"><a href="#需要完成的事情" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2><h1 id="Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系"><a href="#Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系" class="headerlink" title="Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系"></a>Todo：讲深度和广度优先搜索：如何找出社交网络中的三度好友关系</h1><h2 id="需要完成的事情-1"><a href="#需要完成的事情-1" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2><h1 id="讲字符串匹配基础-上-如何借助哈希算法实现高效字符串匹配"><a href="#讲字符串匹配基础-上-如何借助哈希算法实现高效字符串匹配" class="headerlink" title="讲字符串匹配基础(上):如何借助哈希算法实现高效字符串匹配"></a>讲字符串匹配基础(上):如何借助哈希算法实现高效字符串匹配</h1><blockquote>
<p>字符串匹配算法很多，今天讲比较简单和容易理解的BF算法和RK算法。后面讲的BM算法和KMP算法比较难理解、但高效。</p>
<p>前面讲的是单模式串匹配算法：也就是一个串跟一个串进行比较。还有一种就是多模式串匹配算法：在一个串中同时查找多个串，它们分别是Trie树和AC自动机。</p>
<p>RK算法是BF算法的改进，巧妙借助我们之前讲过的哈希算法。</p>
<p>主串和模式串概念定义：我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。我们把主串的⻓度记作n，模式串的⻓ 度记作m。因为我们是在主串中查找模式串，所以n&gt;m </p>
</blockquote>
<h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><ul>
<li><p>BF算法概念：BF算法是Brute Force的缩写，又名暴力匹配算法，也叫朴素匹配算法。</p>
</li>
<li><p>概括：我们在主串中，检查起始位置分别是 <strong>0</strong>、<strong>1</strong>、<strong>2…n-m</strong>且⻓度为<strong>m</strong>的<strong>n-m+1</strong>个子串，看有没有跟模式串匹配的。</p>
</li>
<li><p>图解：BF算法过程</p>
<p><img alt="image-20191119093105785" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g933fmevqoj30e70fp0xy.jpg" class="lazyload"></p>
</li>
<li><p>分析：尽管BF的算法的时间复杂度很高O(n*m)，但是在实际开发中还是使用比较多的。</p>
<ol>
<li>在实际开发的过程中，主串和模式串的长度都不会太长。所以即使时间复杂度为O(n*m)，但是实际要比这个高效多。</li>
<li>BF算法：思路简单，代码实现容易。</li>
</ol>
</li>
</ul>
<h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><ul>
<li>RK算法概念：全称是Rabin-Karp算法，分别是这两位作者创建的。是BF算法的升级版。</li>
<li>思路：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。 如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了(这里先不考虑哈希冲突的问题，后面我们会讲 到) <ol>
<li>解决了BF算法模式串要一个个字母跟主串对比的耗时操作。</li>
<li>有没有方法可以提高哈希算法计算子串哈希值的效率呢? <ul>
<li>利用进制表示十进制的优化方法（取值会过大，超过范围）</li>
<li>每个字符累加（字符代表是素数（冲突概率低）、而非自然数）<ul>
<li>哈希冲突的时候，还要比较字符串本身</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>分析：所以RK算法的时间复杂度为O(n)</li>
</ul>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>BF算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。 所以，时间复杂度也比较高，是O(n*m)，n、m表示主串和模式串的⻓度。不过，在实际的软件开发中，因为这种算法实现简 单，对于处理小规模的字符串匹配很好用。 </p>
<p>RK算法是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少 了比较的时间。所以，理想情况下，RK算法的时间复杂度是O(n)，跟BF算法相比，效率提高了很多。不过这样的效率取决于 哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化 为O(n*m)。 </p>
<h1 id="Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能"><a href="#Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能" class="headerlink" title="Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能"></a>Todo：讲字符串匹配基础（中）：如何实现文本编辑器中的查找功能</h1><blockquote>
<p>BF算法和RK算法在某些极端的情况下，性能会退化很严重。如何实现一个工业级别的字符串匹配算法呢？</p>
<p>对于查找功 能是重要功能的软件来说，比如一些文本编辑器，它们的查找功能都是用哪种算法来实现的呢?有没有比<strong>BF</strong>算法和<strong>RK</strong>算法更 加高效的字符串匹配算法呢? </p>
</blockquote>
<h2 id="需要完成的事情-2"><a href="#需要完成的事情-2" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2><h1 id="Todo-讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法"><a href="#Todo-讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法" class="headerlink" title="Todo:讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法"></a>Todo:讲字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法</h1><h2 id="需要完成的事情-3"><a href="#需要完成的事情-3" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2><h1 id="Todo-讲Trie树：如何实现搜索引擎的搜索关键词提示功能"><a href="#Todo-讲Trie树：如何实现搜索引擎的搜索关键词提示功能" class="headerlink" title="Todo:讲Trie树：如何实现搜索引擎的搜索关键词提示功能"></a>Todo:讲Trie树：如何实现搜索引擎的搜索关键词提示功能</h1><h2 id="需要完成的事情-4"><a href="#需要完成的事情-4" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2><h1 id="Todo-讲AC自动机：如何用多模式串匹配实现敏感词过滤功能"><a href="#Todo-讲AC自动机：如何用多模式串匹配实现敏感词过滤功能" class="headerlink" title="Todo:讲AC自动机：如何用多模式串匹配实现敏感词过滤功能"></a>Todo:讲AC自动机：如何用多模式串匹配实现敏感词过滤功能</h1><h2 id="需要完成的事情-5"><a href="#需要完成的事情-5" class="headerlink" title="需要完成的事情"></a>需要完成的事情</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/">http://yoursite.com/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>《数据结构与算法》-算法篇</span></div></a></div><div class="next-post pull_right"><a href="/2019/10/17/2019-10-17-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%91%A2-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java并发编程实战③-并发设计模式</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/20/2019-11-20-《数据结构与算法》-算法篇/" title="《数据结构与算法》-算法篇"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97ph0biawj31c00u04qp.jpg"><div class="relatedPosts_title">《数据结构与算法》-算法篇</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2019 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>