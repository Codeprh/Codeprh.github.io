<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>《数据结构与算法》-算法篇 | Noah</title><meta name="description" content="阅读《数据结构与算法》-算法篇"><meta name="keywords" content="数据结构与算法"><meta name="author" content="Noah Pan"><meta name="copyright" content="Noah Pan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006y8mN6ly1g97xocyw0bj300g00g0s2.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="《数据结构与算法》-算法篇"><meta name="twitter:description" content="阅读《数据结构与算法》-算法篇"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《数据结构与算法》-算法篇"><meta property="og:url" content="http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><meta property="og:site_name" content="Noah"><meta property="og:description" content="阅读《数据结构与算法》-算法篇"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="canonical" href="http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/"><link rel="prev" title="剑指Offer（完整版）" href="http://yoursite.com/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><link rel="next" title="《数据结构与算法》-数据结构篇" href="http://yoursite.com/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Noah</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95i8yiaddj30sg0sgdgm.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 更多</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#《数据结构与算法》-算法篇"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">《数据结构与算法》-算法篇</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#总览-算法"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">总览-算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲贪心算法：如何用贪心算法实现Huffman压缩编码"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">讲贪心算法：如何用贪心算法实现Huffman压缩编码</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解”贪心算法”？"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">如何理解”贪心算法”？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#贪心算法解决问题的步骤"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">贪心算法解决问题的步骤</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#贪心算法实战分析"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">贪心算法实战分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分糖果"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">分糖果</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#钱币找零"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">钱币找零</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#区间覆盖"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">区间覆盖</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">问题解答</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲分治算法-谈一谈大规模计算框架MapReduce中的分治思想"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">讲分治算法:谈一谈大规模计算框架MapReduce中的分治思想</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解分治算法"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">如何理解分治算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分治算法应用举例"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">分治算法应用举例</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何编程求出一组数据的有序对个数或者逆序对个数？"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">如何编程求出一组数据的有序对个数或者逆序对个数？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分治思想在海量数据处理中的应用"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">分治思想在海量数据处理中的应用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解决"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">问题解决</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲回溯算法-从电影《蝴蝶效应》中学习回溯算法的核心思想"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">讲回溯算法:从电影《蝴蝶效应》中学习回溯算法的核心思想</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何理解回溯算法？"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">如何理解回溯算法？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#八皇后问题"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">八皇后问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#两个回溯算法的经典应用"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">两个回溯算法的经典应用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#0-1背包问题"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">0-1背包问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#正则表达式"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">正则表达式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内容总结"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">内容总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲初识动态规划-如何巧妙解决“双十一”购物时的凑单问题"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">讲初识动态规划:如何巧妙解决“双十一”购物时的凑单问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#动态规划学习路线"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">动态规划学习路线</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#两个经典动态规划问题"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">两个经典动态规划问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#0-1背包问题-1"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">0-1背包问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#回溯算法思想（优化）"><span class="toc_mobile_items-number">6.2.1.1.</span> <span class="toc_mobile_items-text">回溯算法思想（优化）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态规划思想"><span class="toc_mobile_items-number">6.2.1.2.</span> <span class="toc_mobile_items-text">动态规划思想</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#0-1背包问题升级版"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">0-1背包问题升级版</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#回溯算法思想"><span class="toc_mobile_items-number">6.2.2.1.</span> <span class="toc_mobile_items-text">回溯算法思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态规划思想-1"><span class="toc_mobile_items-number">6.2.2.2.</span> <span class="toc_mobile_items-text">动态规划思想</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#问题解答-1"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">问题解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲动态规划理论-一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">讲动态规划理论:一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#“一个模型三个特征”理论讲解"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">“一个模型三个特征”理论讲解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实战：n-n矩阵求解最短路径"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">实战：n*n矩阵求解最短路径</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#回溯算法"><span class="toc_mobile_items-number">7.1.1.1.</span> <span class="toc_mobile_items-text">回溯算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态规划算法"><span class="toc_mobile_items-number">7.1.1.2.</span> <span class="toc_mobile_items-text">动态规划算法</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#两种动态规划解题思路"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">两种动态规划解题思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#状态转义表法"><span class="toc_mobile_items-number">7.2.1.</span> <span class="toc_mobile_items-text">状态转义表法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#状态转义方程法"><span class="toc_mobile_items-number">7.2.2.</span> <span class="toc_mobile_items-text">状态转义方程法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四种算法思想比较分析"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">四种算法思想比较分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-1"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO-42-讲动态规划实战-如何实现搜索引擎中的拼写纠错功能-——47讲向量空间：如何实现一个简单的音乐推荐系统"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">TODO:42-讲动态规划实战:如何实现搜索引擎中的拼写纠错功能 ——47讲向量空间：如何实现一个简单的音乐推荐系统</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要去完成的事情"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">需要去完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲B-树-MySQL数据库索引是如何实现的"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">讲B+树:MySQL数据库索引是如何实现的</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#思考的过程比结论更重要"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">思考的过程比结论更重要</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解决问题的前提是定义清楚问题"><span class="toc_mobile_items-number">9.1.1.</span> <span class="toc_mobile_items-text">解决问题的前提是定义清楚问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#尝试用学过的数据结构解决这个问题"><span class="toc_mobile_items-number">9.1.2.</span> <span class="toc_mobile_items-text">尝试用学过的数据结构解决这个问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#改造二叉查找树来解决这个问题"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">改造二叉查找树来解决这个问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#B-树讲解"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">B+树讲解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#B-树演进"><span class="toc_mobile_items-number">9.3.1.</span> <span class="toc_mobile_items-text">B+树演进</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#B-树实现"><span class="toc_mobile_items-number">9.3.2.</span> <span class="toc_mobile_items-text">B+树实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#B-树的弊"><span class="toc_mobile_items-number">9.3.2.1.</span> <span class="toc_mobile_items-text">B+树的弊</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-2"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要去完成的事情-1"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">需要去完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲索引：如何在海量数据中快速查找某个数据"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">讲索引：如何在海量数据中快速查找某个数据</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么需要索引？"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">为什么需要索引？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#索引的需求定义"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">索引的需求定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#功能性需求"><span class="toc_mobile_items-number">11.2.1.</span> <span class="toc_mobile_items-text">功能性需求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#非功能性需求"><span class="toc_mobile_items-number">11.2.2.</span> <span class="toc_mobile_items-text">非功能性需求</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#构建索引常用的数据结构有哪些"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">构建索引常用的数据结构有哪些</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲并行算法：如何利用并行处理提高算法的执行效率"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">讲并行算法：如何利用并行处理提高算法的执行效率</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行排序"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">并行排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行查找"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">并行查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行字符串匹配"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">并行字符串匹配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行搜索"><span class="toc_mobile_items-number">12.4.</span> <span class="toc_mobile_items-text">并行搜索</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲算法实战（一）：剖析Redis常用数据类型对应的数据结构"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">讲算法实战（一）：剖析Redis常用数据类型对应的数据结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Redis数据库介绍"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text">Redis数据库介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字符串"><span class="toc_mobile_items-number">13.1.1.</span> <span class="toc_mobile_items-text">字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#列表（list）"><span class="toc_mobile_items-number">13.1.2.</span> <span class="toc_mobile_items-text">列表（list）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#压缩列表"><span class="toc_mobile_items-number">13.1.2.1.</span> <span class="toc_mobile_items-text">压缩列表</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字典（hash）"><span class="toc_mobile_items-number">13.1.3.</span> <span class="toc_mobile_items-text">字典（hash）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#集合（set）"><span class="toc_mobile_items-number">13.1.4.</span> <span class="toc_mobile_items-text">集合（set）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#有序集合（sortedSet）"><span class="toc_mobile_items-number">13.1.5.</span> <span class="toc_mobile_items-text">有序集合（sortedSet）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数据结构持久化"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text">数据结构持久化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-3"><span class="toc_mobile_items-number">13.3.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#TODO：讲算法实战-二-剖析搜索引擎背后的经典数据结构和算法"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">TODO：讲算法实战(二):剖析搜索引擎背后的经典数据结构和算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要去完成的事情-2"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text">需要去完成的事情</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#讲算法实战-三-剖析高性能队列Disruptor背后的数据结构和算法"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">讲算法实战(三):剖析高性能队列Disruptor背后的数据结构和算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需要去完成的事情-3"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">需要去完成的事情</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#《数据结构与算法》-算法篇"><span class="toc-number">1.</span> <span class="toc-text">《数据结构与算法》-算法篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总览-算法"><span class="toc-number">2.</span> <span class="toc-text">总览-算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲贪心算法：如何用贪心算法实现Huffman压缩编码"><span class="toc-number">3.</span> <span class="toc-text">讲贪心算法：如何用贪心算法实现Huffman压缩编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解”贪心算法”？"><span class="toc-number">3.1.</span> <span class="toc-text">如何理解”贪心算法”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心算法解决问题的步骤"><span class="toc-number">3.1.1.</span> <span class="toc-text">贪心算法解决问题的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法实战分析"><span class="toc-number">3.2.</span> <span class="toc-text">贪心算法实战分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分糖果"><span class="toc-number">3.2.1.</span> <span class="toc-text">分糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钱币找零"><span class="toc-number">3.2.2.</span> <span class="toc-text">钱币找零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间覆盖"><span class="toc-number">3.2.3.</span> <span class="toc-text">区间覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答"><span class="toc-number">3.3.</span> <span class="toc-text">问题解答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲分治算法-谈一谈大规模计算框架MapReduce中的分治思想"><span class="toc-number">4.</span> <span class="toc-text">讲分治算法:谈一谈大规模计算框架MapReduce中的分治思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解分治算法"><span class="toc-number">4.1.</span> <span class="toc-text">如何理解分治算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治算法应用举例"><span class="toc-number">4.2.</span> <span class="toc-text">分治算法应用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何编程求出一组数据的有序对个数或者逆序对个数？"><span class="toc-number">4.2.1.</span> <span class="toc-text">如何编程求出一组数据的有序对个数或者逆序对个数？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治思想在海量数据处理中的应用"><span class="toc-number">4.3.</span> <span class="toc-text">分治思想在海量数据处理中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解决"><span class="toc-number">4.4.</span> <span class="toc-text">问题解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲回溯算法-从电影《蝴蝶效应》中学习回溯算法的核心思想"><span class="toc-number">5.</span> <span class="toc-text">讲回溯算法:从电影《蝴蝶效应》中学习回溯算法的核心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解回溯算法？"><span class="toc-number">5.1.</span> <span class="toc-text">如何理解回溯算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#八皇后问题"><span class="toc-number">5.1.1.</span> <span class="toc-text">八皇后问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个回溯算法的经典应用"><span class="toc-number">5.2.</span> <span class="toc-text">两个回溯算法的经典应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题"><span class="toc-number">5.2.1.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式"><span class="toc-number">5.2.2.</span> <span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容总结"><span class="toc-number">5.3.</span> <span class="toc-text">内容总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲初识动态规划-如何巧妙解决“双十一”购物时的凑单问题"><span class="toc-number">6.</span> <span class="toc-text">讲初识动态规划:如何巧妙解决“双十一”购物时的凑单问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划学习路线"><span class="toc-number">6.1.</span> <span class="toc-text">动态规划学习路线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个经典动态规划问题"><span class="toc-number">6.2.</span> <span class="toc-text">两个经典动态规划问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">0-1背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回溯算法思想（优化）"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">回溯算法思想（优化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划思想"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">动态规划思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题升级版"><span class="toc-number">6.2.2.</span> <span class="toc-text">0-1背包问题升级版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回溯算法思想"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">回溯算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划思想-1"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">动态规划思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题解答-1"><span class="toc-number">6.3.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲动态规划理论-一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"><span class="toc-number">7.</span> <span class="toc-text">讲动态规划理论:一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#“一个模型三个特征”理论讲解"><span class="toc-number">7.1.</span> <span class="toc-text">“一个模型三个特征”理论讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实战：n-n矩阵求解最短路径"><span class="toc-number">7.1.1.</span> <span class="toc-text">实战：n*n矩阵求解最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回溯算法"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划算法"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">动态规划算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两种动态规划解题思路"><span class="toc-number">7.2.</span> <span class="toc-text">两种动态规划解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转义表法"><span class="toc-number">7.2.1.</span> <span class="toc-text">状态转义表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转义方程法"><span class="toc-number">7.2.2.</span> <span class="toc-text">状态转义方程法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种算法思想比较分析"><span class="toc-number">7.3.</span> <span class="toc-text">四种算法思想比较分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO-42-讲动态规划实战-如何实现搜索引擎中的拼写纠错功能-——47讲向量空间：如何实现一个简单的音乐推荐系统"><span class="toc-number">8.</span> <span class="toc-text">TODO:42-讲动态规划实战:如何实现搜索引擎中的拼写纠错功能 ——47讲向量空间：如何实现一个简单的音乐推荐系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要去完成的事情"><span class="toc-number">8.1.</span> <span class="toc-text">需要去完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲B-树-MySQL数据库索引是如何实现的"><span class="toc-number">9.</span> <span class="toc-text">讲B+树:MySQL数据库索引是如何实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思考的过程比结论更重要"><span class="toc-number">9.1.</span> <span class="toc-text">思考的过程比结论更重要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决问题的前提是定义清楚问题"><span class="toc-number">9.1.1.</span> <span class="toc-text">解决问题的前提是定义清楚问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试用学过的数据结构解决这个问题"><span class="toc-number">9.1.2.</span> <span class="toc-text">尝试用学过的数据结构解决这个问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改造二叉查找树来解决这个问题"><span class="toc-number">9.2.</span> <span class="toc-text">改造二叉查找树来解决这个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-树讲解"><span class="toc-number">9.3.</span> <span class="toc-text">B+树讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树演进"><span class="toc-number">9.3.1.</span> <span class="toc-text">B+树演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树实现"><span class="toc-number">9.3.2.</span> <span class="toc-text">B+树实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树的弊"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">B+树的弊</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-2"><span class="toc-number">9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能"><span class="toc-number">10.</span> <span class="toc-text">TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要去完成的事情-1"><span class="toc-number">10.1.</span> <span class="toc-text">需要去完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲索引：如何在海量数据中快速查找某个数据"><span class="toc-number">11.</span> <span class="toc-text">讲索引：如何在海量数据中快速查找某个数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要索引？"><span class="toc-number">11.1.</span> <span class="toc-text">为什么需要索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的需求定义"><span class="toc-number">11.2.</span> <span class="toc-text">索引的需求定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#功能性需求"><span class="toc-number">11.2.1.</span> <span class="toc-text">功能性需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非功能性需求"><span class="toc-number">11.2.2.</span> <span class="toc-text">非功能性需求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建索引常用的数据结构有哪些"><span class="toc-number">11.3.</span> <span class="toc-text">构建索引常用的数据结构有哪些</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲并行算法：如何利用并行处理提高算法的执行效率"><span class="toc-number">12.</span> <span class="toc-text">讲并行算法：如何利用并行处理提高算法的执行效率</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并行排序"><span class="toc-number">12.1.</span> <span class="toc-text">并行排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行查找"><span class="toc-number">12.2.</span> <span class="toc-text">并行查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行字符串匹配"><span class="toc-number">12.3.</span> <span class="toc-text">并行字符串匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行搜索"><span class="toc-number">12.4.</span> <span class="toc-text">并行搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲算法实战（一）：剖析Redis常用数据类型对应的数据结构"><span class="toc-number">13.</span> <span class="toc-text">讲算法实战（一）：剖析Redis常用数据类型对应的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis数据库介绍"><span class="toc-number">13.1.</span> <span class="toc-text">Redis数据库介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">13.1.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表（list）"><span class="toc-number">13.1.2.</span> <span class="toc-text">列表（list）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩列表"><span class="toc-number">13.1.2.1.</span> <span class="toc-text">压缩列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典（hash）"><span class="toc-number">13.1.3.</span> <span class="toc-text">字典（hash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合（set）"><span class="toc-number">13.1.4.</span> <span class="toc-text">集合（set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序集合（sortedSet）"><span class="toc-number">13.1.5.</span> <span class="toc-text">有序集合（sortedSet）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构持久化"><span class="toc-number">13.2.</span> <span class="toc-text">数据结构持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-3"><span class="toc-number">13.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO：讲算法实战-二-剖析搜索引擎背后的经典数据结构和算法"><span class="toc-number">14.</span> <span class="toc-text">TODO：讲算法实战(二):剖析搜索引擎背后的经典数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要去完成的事情-2"><span class="toc-number">14.1.</span> <span class="toc-text">需要去完成的事情</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#讲算法实战-三-剖析高性能队列Disruptor背后的数据结构和算法"><span class="toc-number">15.</span> <span class="toc-text">讲算法实战(三):剖析高性能队列Disruptor背后的数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需要去完成的事情-3"><span class="toc-number">15.1.</span> <span class="toc-text">需要去完成的事情</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">《数据结构与算法》-算法篇</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-20<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-22</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">21.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 69 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h1 id="《数据结构与算法》-算法篇"><a href="#《数据结构与算法》-算法篇" class="headerlink" title="《数据结构与算法》-算法篇"></a>《数据结构与算法》-算法篇</h1><h1 id="总览-算法"><a href="#总览-算法" class="headerlink" title="总览-算法"></a>总览-算法</h1><blockquote>
<ol>
<li>讲贪心算法：如何用贪心算法实现Huffman压缩编码</li>
<li>讲分治算法：谈一谈大规模计算框架MapReduce中的分治思想</li>
<li>讲回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</li>
<li>讲初识动态规划：如何巧妙解决“双十一”购物时的凑单问题</li>
<li>讲动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</li>
<li>讲动态规划实战：如何实现搜索引擎中的拼写纠错功能</li>
<li>讲拓扑排序：如何确定代码源文件的编译依赖关系</li>
<li>讲最短路径：地图软件是如何计算出最优出行路径的</li>
<li>讲位图：如何实现网页爬虫中的URL去重功能</li>
<li>讲概率统计：如何利用朴素贝叶斯算法过滤垃圾短信</li>
<li>讲向量空间：如何实现一个简单的音乐推荐系统</li>
<li>讲B+树：MySQL数据库索引是如何实现的</li>
<li>讲搜索：如何用A搜索算法实现游戏中的寻路功能</li>
<li>讲索引：如何在海量数据中快速查找某个数据</li>
<li>讲并行算法：如何利用并行处理提高算法的执行效率</li>
</ol>
</blockquote>
<h1 id="讲贪心算法：如何用贪心算法实现Huffman压缩编码"><a href="#讲贪心算法：如何用贪心算法实现Huffman压缩编码" class="headerlink" title="讲贪心算法：如何用贪心算法实现Huffman压缩编码"></a>讲贪心算法：如何用贪心算法实现Huffman压缩编码</h1><blockquote>
<p>基础的数据结构和算法在《数据结构与算法》-数据结构篇讲完了。接下来我们开始讲算法篇。讲几种更加基本的算法。它们分别是贪心算法、分治算法、回溯算法、动态规划。更加准确地说我们应该学习的是算法的思想。</p>
<p>贪心算法的经典应用：霍夫曼编码(Huffman Coding)、Prim和Kruskal最小生成树算法、还有Dijkstra单源最短路径算法。最小生成树算法和最短路径算法等。</p>
<p>问题：霍夫曼编码，它是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。 </p>
</blockquote>
<h2 id="如何理解”贪心算法”？"><a href="#如何理解”贪心算法”？" class="headerlink" title="如何理解”贪心算法”？"></a>如何理解”贪心算法”？</h2><blockquote>
<p>场景：在一个给定重量的背包下，要装物品总价值最大的。</p>
<p>思路：我们计算每个物品的单价，依次取最大放入背包中。</p>
</blockquote>
<h3 id="贪心算法解决问题的步骤"><a href="#贪心算法解决问题的步骤" class="headerlink" title="贪心算法解决问题的步骤"></a>贪心算法解决问题的步骤</h3><ol>
<li>第一步，<strong>当我们看到这类问题的时候，首先要联想到贪心算法</strong>：针对一组数据，我们定义了限制值和期望值，希望从中选出几 个数据，在满足限制值的情况下，期望值最大。 </li>
<li>第二步，<strong>我们尝试看下这个问题是否可以用贪心算法解决</strong>：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值 贡献最大的数据。 </li>
<li>第三部<strong>，我们举几个例子看下贪心算法产生的结果是否是最优的。</strong></li>
</ol>
<blockquote>
<p>但是贪心算法的解决问题的思路，并不总能给出最优解。</p>
<p>比如在有权图，找最短路径的过程。即使你的每一步在看来都是最优解，但是你第一步的选择会影响后面的选择的解。</p>
<p>所以，即便我们第一步选择最优的走法(边最短)，但 有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。 </p>
</blockquote>
<h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><blockquote>
<p>问题：我们有m个糖果和n个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多(m&lt;n)，所以糖果只能分配给一部分孩子。 </p>
<p>每个糖果的大小不等，这m个糖果的大小分别是s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样 的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这n个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。 </p>
<p>我的问题是，如何分配糖果，能尽可能满足最多数量的孩子? </p>
<p>解决：我们现在来看看如何用贪心算法来解决。对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大 的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小 的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。 </p>
<p>我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方 案，也就是满足的孩子个数最多的方案。 </p>
</blockquote>
<h3 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h3><blockquote>
<p>问题：这个问题在我们的日常生活中更加普遍。假设我们有1元、2元、5元、10元、20元、50元、100元这些面额的纸币，它们的张 数分别是c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付K元，最少要用多少张纸币呢? </p>
<p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用1元来补⻬。 </p>
<p>在贡献相同期望值(纸币数目)的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思 路。直觉告诉我们，这种处理方法就是最好的。实际上，要严谨地证明这种贪心算法的正确性，需要比较复杂的、有技巧的数 学推导，我不建议你花太多时间在上面，不过如果感兴趣的话，可以自己去研究下。 </p>
</blockquote>
<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><blockquote>
<p>问题：假设我们有n个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这n个区间中选出一 部分区间，这部分区间满足两两不相交(端点相交的情况不算相交)，最多能选出多少个区间呢? </p>
<p>这个问题的处理思路稍微不是那么好懂，不过，我建议你最好能弄懂，因为这个处理思想在很多贪心算法问题中都有用到，比 如任务调度、教师排课等等问题。 </p>
<p>解决：这个问题的解决思路是这样的:我们假设这n个区间中最左端点是lmin，最右端点是rmax。这个问题就相当于，我们选择几个 不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这n个区间排序。 </p>
<p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的 大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。 </p>
<p>图文：</p>
<p><img alt="image-20191120092140308" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g948s5j54rj30jw05fmy9.jpg" class="lazyload"></p>
<p><img alt="image-20191120092224398" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g948svodeej30i10awwfr.jpg" class="lazyload"></p>
</blockquote>
<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><ul>
<li>如何使用贪心算法实现霍弗码编码？</li>
<li>场景：我们有一个包含1000个字符的文件，每个字符占用1个byte(8 bits)，而存储1000个字符，总共需要8000bits，如何节省更多的空间？</li>
</ul>
<blockquote>
<ul>
<li><p>方式一：假设我们通过统计分析发现，这1000个字符中只包含6种不同字符，假设它们分别是a、b、c、d、e、f。而3个二进制位 (bit)就可以表示8个不同的字符，所以，为了尽量减少存储空间，每个字符我们用3个二进制位来表示。那存储这1000个字 符只需要3000bits就可以了，比原来的存储方式节省了很多空间。 </p>
</li>
<li><p>方式二：霍夫曼编码，不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同⻓度的编码。霍 夫曼编码试图用这种不等⻓的编码方法，来进一步增加压缩的效率。 </p>
<ul>
<li>如何给不同频率的字符选择不同⻓度的编码呢? <ul>
<li>根据贪心 的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码;出现频率比较少的字符，用稍微⻓一些的编码。 </li>
</ul>
</li>
<li>如何解决解压时候不等长的霍夫曼编码？<ul>
<li>为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编 码之间，不会出现某个编码是另一个编码前缀的情况。 在解压缩的时候，我们每次会读取尽可能⻓的可解压的二进制串。</li>
</ul>
</li>
</ul>
</li>
<li><p>实战：这1000个字符只需要2100bits就可以了。 </p>
</li>
</ul>
<p><img alt="image-20191121083800546" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95d5175kxj30hp0b241a.jpg" class="lazyload"></p>
<ul>
<li><p>实现技巧：</p>
<ol>
<li>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点A、B，然后新 建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A、B的父节点。最后再把C节点放入到优先级 队列中。重复这个过程，直到队列中没有数据。 </li>
<li>我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为0，指向右子节点的边，我们统统标记为1，那从 根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。 </li>
</ol>
<p><img alt="image-20191121084152476" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95d90kzb3j30mc0ffqbt.jpg" class="lazyload"></p>
<p><img alt="image-20191121084232923" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95d9pvbc3j30j109ntap.jpg" class="lazyload"></p>
</li>
</ul>
</blockquote>
<h1 id="讲分治算法-谈一谈大规模计算框架MapReduce中的分治思想"><a href="#讲分治算法-谈一谈大规模计算框架MapReduce中的分治思想" class="headerlink" title="讲分治算法:谈一谈大规模计算框架MapReduce中的分治思想"></a>讲分治算法:谈一谈大规模计算框架MapReduce中的分治思想</h1><h2 id="如何理解分治算法"><a href="#如何理解分治算法" class="headerlink" title="如何理解分治算法"></a>如何理解分治算法</h2><ul>
<li>分治算法定义：英文是divide and conquer，分而治之。也就是将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归解决这些子问题，然后再合并其结果，就得到原问题的解。</li>
<li>分治和递归的区别：分治算法是一种处理问题的思想，递归是一种编程技巧。</li>
<li>分治算法一般比较适合用递归来实现，每一层递归都会涉及三个操作：<ol>
<li>分解:将原问题分解成一系列子问题; </li>
<li>解决:递归地求解各个子问题，若子问题足够小，则直接求解; </li>
<li>合并:将子问题的结果合并成原问题。 </li>
</ol>
</li>
<li>什么场景适合使用分治算法来解决？（必须要满足的条件）<ol>
<li>原问题与分解成的小问题具有相同的模式; </li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别。</li>
<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解; </li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。 </li>
</ol>
</li>
</ul>
<h2 id="分治算法应用举例"><a href="#分治算法应用举例" class="headerlink" title="分治算法应用举例"></a>分治算法应用举例</h2><h3 id="如何编程求出一组数据的有序对个数或者逆序对个数？"><a href="#如何编程求出一组数据的有序对个数或者逆序对个数？" class="headerlink" title="如何编程求出一组数据的有序对个数或者逆序对个数？"></a>如何编程求出一组数据的有序对个数或者逆序对个数？</h3><ul>
<li><p>场景：根据有序度和逆序度的概念，求解逆序对个数。</p>
<p><img alt="image-20191121091028185" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95e2ruebhj30eq04qdgq.jpg" class="lazyload"></p>
</li>
<li><p>解决一：采用两个循环来解决问题，那时间复杂度为O(n²)</p>
</li>
<li><p>解决二：分治算法</p>
<ol>
<li><p>我们可以将数组分成前后两半A1和A2，分别计算A1 和A2的逆序对个数K1和K2，然后再计算A1与A2之间的逆序对个数K3。那数组A的逆序对个数就等于K1+K2+K3。 </p>
</li>
<li><p>如何计算A1和A2之间的逆序对个数呢？</p>
<ul>
<li>需要想到归并排序的思想。</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 逆序度个数求解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-21 09:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_38_ReverseOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        _38_ReverseOrder app = <span class="keyword">new</span> _38_ReverseOrder();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"逆序对的个数="</span> + app.count(a, a.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        mergeSortCounting(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q = (p + r) / <span class="number">2</span>;</span><br><span class="line">        mergeSortCounting(a, p, q);</span><br><span class="line">        mergeSortCounting(a, q + <span class="number">1</span>, r);</span><br><span class="line">        merge(a, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = p, j = q + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - p + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                tmp[k++] = a[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">                num += (q - i + <span class="number">1</span>);</span><br><span class="line">                tmp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= q) &#123;</span><br><span class="line">            <span class="comment">// 处理剩下的</span></span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// 处理剩下的</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - p; ++i) &#123;</span><br><span class="line">            <span class="comment">// 从tmp拷⻉回a</span></span><br><span class="line">            a[p + i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>分治算法的相关题目</p>
<ol>
<li>二维平面上有n个点，如何快速计算出两个距离最近的点对? </li>
<li>有两个n<em>n的矩阵A，B，如何快速求解两个矩阵的乘积C=A</em>B? </li>
</ol>
</li>
</ul>
<h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>分治算法的思想应用非常广泛，并不仅限于指导编程和算法设计。在海量数据处理的场景中应用十分广泛。突破单机的内存存储和单机处理。</p>
<ul>
<li>比如前面我们讲过的给10GB的订单根据金额排序。</li>
<li>解决思路<ol>
<li>首先分片数据，根据桶排序（线性时间），划分金额的桶。</li>
<li>然后每个桶之间的数据数据排序（归并排序或者快速排序）</li>
<li>如果步骤的2数据量还是太大了，继续划分。</li>
</ol>
</li>
</ul>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>为什么说MapReduce的本质就是分治思想? </p>
<ul>
<li>对于谷歌搜索引擎来说，网⻚爬取、清洗、分析、分词、计算权重、倒排索引 等等各个环节中，都会面对如此海量的数据(比如网⻚)。所以，利用集群并行处理显然是大势所趋。 </li>
<li>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结 果合并。这不就是分治思想吗? </li>
</ul>
<h1 id="讲回溯算法-从电影《蝴蝶效应》中学习回溯算法的核心思想"><a href="#讲回溯算法-从电影《蝴蝶效应》中学习回溯算法的核心思想" class="headerlink" title="讲回溯算法:从电影《蝴蝶效应》中学习回溯算法的核心思想"></a>讲回溯算法:从电影《蝴蝶效应》中学习回溯算法的核心思想</h1><blockquote>
<p>在深度优先搜索（二叉树的前序、中序、后序）利用的就是回溯算法。但是还有很多应用场景：正则表达式匹配、编译原理中的 语法分析、数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等 等。 </p>
</blockquote>
<h2 id="如何理解回溯算法？"><a href="#如何理解回溯算法？" class="headerlink" title="如何理解回溯算法？"></a>如何理解回溯算法？</h2><blockquote>
<p>概念：如何求解最优解，在”搜索”问题上适用（在一组可能的解中，搜索满足期望的解 ）。贪心算法每一步看起来是最优解，但是有些情况下最终结果并不是最优解。</p>
</blockquote>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><ul>
<li><p>问题定义：我们有一个8x8的棋盘，希望往里放8个棋子(皇后)，每个棋子所在的行、列、对⻆线都不能有另一个棋子。 </p>
</li>
<li><p>解决：我们把这个问题划分成8个阶段，依次将8个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检 查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子;如果不满足，那就再换一种方法，继续尝试。 </p>
</li>
<li><p>实现：非常适合使用递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 参考版</span></span><br><span class="line"><span class="comment"> * 使用回溯思想解决八皇后问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-25 08:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_39_EightQueensProblem</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        _39_EightQueensProblem app = <span class="keyword">new</span> _39_EightQueensProblem();</span><br><span class="line">        app.cal8queens(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * // 调用方式:cal8queens(0)</span></span><br><span class="line"><span class="comment">     * 八皇后问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">8</span>) &#123;</span><br><span class="line">            printQueens(result);<span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">            <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">                result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">                cal8queens(row + <span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断row行column列放置是否合适</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗?</span></span><br><span class="line">            <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对⻆线:第i行leftup列有棋子吗?</span></span><br><span class="line">                <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对⻆线:第i行rightup列有棋子吗?</span></span><br><span class="line">                <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --leftup;</span><br><span class="line">            ++rightup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印出一个二维矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[row] == column) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(<span class="string">"* "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图解：有多种解，这只是其中的一个解</p>
<ul>
<li></li>
<li><img alt="image-20191125085438672" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9a03km683j30kx0ayjw4.jpg" class="lazyload"></li>
</ul>
</li>
</ul>
<h2 id="两个回溯算法的经典应用"><a href="#两个回溯算法的经典应用" class="headerlink" title="两个回溯算法的经典应用"></a>两个回溯算法的经典应用</h2><p>回溯算法的实现还是比较难的，尤其是递归实现。我们通过下面的两个例子，进一步加深学习和理解。</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><blockquote>
<p>0-1背包问题是非常经典的算法问题，很多场景都可以抽象为这个问题的模型。最经典的解法是使用冬天规划，不过还有一种简单但是没有那么高效的解法（回溯算法）。</p>
<p>问题：0-1背包问题有很多变体，我这里介绍一种比较基础的。我们有一个背包，背包总的承载重量是Wkg。现在我们有n个物品，每 个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何 让背包中物品的总重量最大? </p>
<p>区分：背包问题我们在贪心算法那一节，已经讲过一个了，不过那里讲的物品是可以分割的，我可以装某个物品的一部分到 背包里面。今天讲的这个背包问题，物品是不可分割的，要么装要么不装，所以叫0-1背包问题。显然，这个问题已经无法通 过贪心算法来解决了。 </p>
<p>解决：</p>
<ol>
<li>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于n个物品来说，总的装法就有2^n种，去掉总重量超过 Wkg的，从剩下的装法中选择总重量最接近Wkg的。不过，我们如何才能不重复地穷举出这2^n种装法呢? </li>
<li>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了n个阶段，每个阶段对应一个物品怎么选择。先对 第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。描述起来很费劲，我们直接看代码，反而会 更加清晰一些。 </li>
</ol>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 0-1背包问题，使用回溯算法解决</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-25 09:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_39_KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cw表示当前已经装进去的物品的重量和;i表示考察到哪个物品了;</span></span><br><span class="line">    <span class="comment">// w背包重量;items表示每个物品的重量;n表示物品个数</span></span><br><span class="line">    <span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数:</span></span><br><span class="line">    <span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">            <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f(i + <span class="number">1</span>, cw, items, n, w);</span><br><span class="line">        <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">            f(i + <span class="number">1</span>, cw + items[i], items, n, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>场景：使用正则表达式来匹配文本中是否有符合的字符串。假设我们更改了”?”和”*”的语义。</p>
<ul>
<li>“*”匹配任意多个(大于等于0个)任意字 符，“?”匹配零个或者一个任意字符 </li>
</ul>
<p>思路：如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串 中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这 个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。 </p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 利用回溯算法实现正则表达式匹配</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * “*”匹配任意多个(大于等于0个)任意字 符，“?”匹配零个或者一个任意字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-25 09:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_39_Pattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式⻓度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">_39_Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">this</span>.plen = plen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">        matched = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">        <span class="keyword">return</span> matched;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">        <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">            <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen - ti; ++k) &#123;</span><br><span class="line">                rmatch(ti + k, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">            rmatch(ti, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">            rmatch(ti + <span class="number">1</span>, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">            rmatch(ti + <span class="number">1</span>, pj + <span class="number">1</span>, text, tlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求 的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷 举搜索所有的情况，从而提高搜索效率。 </p>
<h1 id="讲初识动态规划-如何巧妙解决“双十一”购物时的凑单问题"><a href="#讲初识动态规划-如何巧妙解决“双十一”购物时的凑单问题" class="headerlink" title="讲初识动态规划:如何巧妙解决“双十一”购物时的凑单问题"></a>讲初识动态规划:如何巧妙解决“双十一”购物时的凑单问题</h1><blockquote>
<p>问题场景：双11有满200减50的活动，假设购物车有n个(n&gt;100)想要买的商品，希 望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件(200元) 。</p>
<p>如何利用动态规划来解决问题？</p>
</blockquote>
<h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><blockquote>
<p>动态规划比较适合用于求解最优问题，比如求最大值、最小值等等。它可以显著降低时间复杂度，提高代码的执行效率。但是它是非常难学的，跟递归类似，他并不是以人脑思考问题的方式来解决。</p>
<p>因此动态划分为三个章节来讲解：初识动态规划、动态规划理论、动态规划实战 。</p>
<ol>
<li>初始动态规划：通过列举两个非常经典的动态规划问题，让你知道为什么需要动态规划，以及动态规划解题方法是如何演进出来的。实际上，你只要掌握了这两个例子的解决思路，对于其他很多动态规划问题，你都可以套用类似的思路来解决。 </li>
<li>动态规划理论：我会总结动态规划适合解决的问题的特征，以及动态规划解题思路。除此之外，我还会将贪心、分治、回溯、动态规 划这四种算法思想放在一起，对比分析它们各自的特点以及适用的场景。 </li>
<li>动态规划实战：我会教你应用第二节讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深你对理论的理解。弄懂了 这三节中的例子，对于动态规划这个知识点，你就算是入⻔了。 </li>
</ol>
</blockquote>
<h2 id="两个经典动态规划问题"><a href="#两个经典动态规划问题" class="headerlink" title="两个经典动态规划问题"></a>两个经典动态规划问题</h2><h3 id="0-1背包问题-1"><a href="#0-1背包问题-1" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><h4 id="回溯算法思想（优化）"><a href="#回溯算法思想（优化）" class="headerlink" title="回溯算法思想（优化）"></a>回溯算法思想（优化）</h4><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单版本：使用回溯算法求解0-1背包问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_39_KnapsackProblem_Simple</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回溯算法实现。注意:我把输入的变量都定义成了成员变量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">// 结果放到maxW中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] weight = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>; <span class="comment">// 物品个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>; <span class="comment">// 背包承受的最大重量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>][<span class="number">10</span>]; <span class="comment">// 备忘录，默认值false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常规方法：存在冗余计算</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cw</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123; <span class="comment">// 调用f(0, 0)</span></span><br><span class="line">        <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了，i==n表示物品都考察完了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f(i + <span class="number">1</span>, cw); <span class="comment">// 选择不装第i个物品</span></span><br><span class="line">        <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line">            f(i + <span class="number">1</span>, cw + weight[i]); <span class="comment">// 选择装第i个物品</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化版本：使用数组存储临时值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cw</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123; <span class="comment">// 调用f(0, 0)</span></span><br><span class="line">        <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了，i==n表示物品都考察完了</span></span><br><span class="line">            <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mem[i][cw]) <span class="keyword">return</span>; <span class="comment">// 重复状态</span></span><br><span class="line">        mem[i][cw] = <span class="keyword">true</span>; <span class="comment">// 记录(i, cw)这个状态</span></span><br><span class="line">        f2(i + <span class="number">1</span>, cw); <span class="comment">// 选择不装第i个物品</span></span><br><span class="line">        <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line">            f2(i + <span class="number">1</span>, cw + weight[i]); <span class="comment">// 选择装第i个物品</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解</p>
<p><img alt="image-20191126083311156" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9b53jgsu8j30l10d4dlk.jpg" class="lazyload"></p>
<p>优化：递归存在重复计算，我们可以存储一个备忘录来记录那些问题已经计算过了。避免冗余计算。</p>
<p>总结：优化后的方法，执行效率跟动态规划差不多了。</p>
<h4 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h4><p>分析：物品的重量分别为2，2，4，6，3 </p>
<ol>
<li>我们把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策(放入或者不放入背包)完之 后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。 </li>
<li>我们把每一层重复的状态(节点)合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可 以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过w个(w表示背包的承载重量)，也就是例子中 的9。于是，我们就成功避免了每层状态个数的指数级增⻓。 </li>
</ol>
<p>实现：</p>
<ul>
<li><p>我们用一个二维数组<code>states[n][w+1]</code>，来记录每层可以达到的不同状态。 </p>
<ol>
<li>第0个(下标从0开始编号)物品的重量是2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中 物品的总重量是0或者2。我们用<code>states[0][0]</code>=true和<code>states[0][2]</code>=true来表示这两种状态。 </li>
<li>第1个物品的重量也是2，基于之前的背包状态，在这个物品决策完之后，不同的状态有3个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用<code>states[1][0]</code>=true，<code>states[1][2]</code>=true，<code>states[1][4]</code>=true来表示这三种状态。 </li>
<li>以此类推，直到考察完所有的物品后，整个states状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0表示false，1表示true。我们只需要在最后一层，找一个值为true的最接近w(这里是9)的值，就是背包中物品总重量的最大 值。 </li>
</ol>
</li>
<li><p>图解</p>
<p><img alt="image-20191126091618565" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9b6ce1vpej30kd0kv17a.jpg" class="lazyload"></p>
</li>
<li><p>代码实现</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * weight:物品重量，n:物品个数，w:背包可承载重量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w + <span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;<span class="comment">// 动态规划状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;<span class="comment">// 不把第i个物品放入背包</span></span><br><span class="line">            <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">            <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j + weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (states[n - <span class="number">1</span>][i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段 可达的状态集合(去掉重复的)，然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。 </p>
<p>时间复杂度：O(n*w)。n表示物品个 数，w表示背包可以承载的总重量。 比回溯算法解决0-1背包问题指数级别2^n的性能要高太多了。</p>
<p>代码分析：我们使用了一个二维的数组来存储状态，所以有时候我们会讲动态规划是一种空间换时间的思路。所以这里的二维数组也可以使用一维数组来表示</p>
<h3 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h3><p>场景：我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可 分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢? </p>
<h4 id="回溯算法思想"><a href="#回溯算法思想" class="headerlink" title="回溯算法思想"></a>回溯算法思想</h4><p>图解：</p>
<p><img alt="image-20191126094912535" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9b7amwr3vj30x60k6k5g.jpg" class="lazyload"></p>
<p>分析：</p>
<ol>
<li>在递归树中，有几个节点的i和cw是完全相同的，比如f(2,2,4)和f(2,2,3)。在背包中物品总重量一样的情况 下，f(2,2,4)这种状态对应的物品总价值更大，我们可以舍弃f(2,2,3)这种状态，只需要沿着f(2,2,4)这条决策路线继续往下决策 就可以。 </li>
<li>如果用回溯算法，这个问题就没法再用“备忘录”解决了。 </li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用回溯算法求解0-1背包升级问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span> cv)</span> </span>&#123; <span class="comment">// 调用f(0, 0, 0)</span></span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了,i==n表示物品都考察完了</span></span><br><span class="line">        <span class="keyword">if</span> (cv &gt; maxV) maxV = cv;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i + <span class="number">1</span>, cw, cv); <span class="comment">// 选择不装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line"></span><br><span class="line">        f(i + <span class="number">1</span>, cw + weight[i], cv + value[i]); <span class="comment">// 选择装第i个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划思想-1"><a href="#动态规划思想-1" class="headerlink" title="动态规划思想"></a>动态规划思想</h4><p>分析：</p>
<ol>
<li>我们还是把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总 重量以及总价值，会有多种情况，也就是会达到多种不同的状态。 </li>
<li>我们用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是boolean类型的了，而是 当前状态对应的最大总价值。我们把每一层中(i, cw)重复的状态(节点)合并，只记录cv值最大的那个状态，然后基于这些状 态来推导下一层的状态。 </li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划求解0-1背包升级问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack3</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">// 初始化states</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            states[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">//动态规划，状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;<span class="comment">// 不选择第i个物品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>) states[i][j] = states[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j) &#123; <span class="comment">// 选择第i个物品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = states[i - <span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span> (v &gt; states[i][j + weight[i]]) &#123;</span><br><span class="line">                    states[i][j + weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (states[n - <span class="number">1</span>][j] &gt; maxvalue) maxvalue = states[n - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：O(n*w)，同理也可以优化为一维数组。</p>
<h2 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h2><ul>
<li><p>问题：双11有满200减50的活动，假设购物车有n个(n&gt;100)想要买的商品，希 望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件(200元) 。</p>
<ol>
<li><p>方式一（回溯算法思想）：对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于200并且最接近200的组合是哪一个?但是，这 样效率太低了点，时间复杂度非常高，是指数级的。 </p>
</li>
<li><p>方式二（动态规划）：跟第一个例子0-1背包问题很像，我们这里需要把”重量”替换为”价格”，二维数组<code>states[n][x]</code>,那这里的x的值是多少呢？</p>
<ul>
<li><p>0-1背包问题中，我们找的是小于等于w的最大值，x就是背包的最大承载重量w+1。 </p>
</li>
<li><p>在购物问题中，我们的理论值是大于等于200（满减条件）值中最小值的。但是从实际问题出发，200块很容易就满足了，所以我们设置为1000+1</p>
</li>
<li><p>在确定了x的价格维度之后，我们还需要在动态规划之后，把选中的商品都筛选出来。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * 使用动态规划来解决双11凑单问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-27 08:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_40_11_11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        _40_11_11 app = <span class="keyword">new</span> _40_11_11();</span><br><span class="line">        <span class="comment">//int[] items = new int[]&#123;150, 100, 300, 400, 800, 50, 10, 30, 20&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] items = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">150</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">800</span>&#125;;</span><br><span class="line">        app.double11advance(items, items.length, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * items商品价格，n商品个数, w表示满减条件，比如200</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">double11advance</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">3</span> * w + <span class="number">1</span>];<span class="comment">//超过3倍就没有薅羊毛的价值了</span></span><br><span class="line">        states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 第一行的数据要特殊处理</span></span><br><span class="line">        states[<span class="number">0</span>][items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;<span class="comment">// 动态规划</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span> * w; ++j) &#123;<span class="comment">// 不购买第i个商品</span></span><br><span class="line">                <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span> * w - items[i]; ++j) &#123;<span class="comment">//购买第i个商品</span></span><br><span class="line">                <span class="keyword">if</span> (states[i - <span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j + items[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = w; j &lt; <span class="number">3</span> * w + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states[n - <span class="number">1</span>][j] == <span class="keyword">true</span>) <span class="keyword">break</span>; <span class="comment">// 输出结果大于等于w的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 没有可行解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">// i表示二维数组中的行，j表示列</span></span><br><span class="line">            <span class="keyword">if</span> (j - items[i] &gt;= <span class="number">0</span> &amp;&amp; states[i - <span class="number">1</span>][j - items[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(items[i] + <span class="string">" "</span>); <span class="comment">// 购买这个商品</span></span><br><span class="line">                j = j - items[i];</span><br><span class="line">            &#125;  <span class="comment">//else 没有购买这个商品，j不变。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">0</span>) System.out.print(items[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码分析：</p>
<ol>
<li>代码的前半部分跟0-1背包问题没有什么不同，我们着重看后半部分，看它是如何打印出选择购买哪些商品的。</li>
<li>状态(i, j)只有可能从(i-1, j)或者(i-1, j-value[i])两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是<code>states[i- 1][j]</code>或者<code>states[i-1][j-value[i]]</code>是否是true。 </li>
<li>如果<code>states[i-1][j]</code>可达，就说明我们没有选择购买第i个商品，如果<code>states[i-1][j-value[i]]</code>可达，那就说明我们选择了购买第i个商 品。我们从中选择一个可达的状态(如果两个都可达，就随意选择一个)，然后，继续迭代地考察其他商品是否有选择购买。 </li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇的动态规划，没有讲太多的理论知识。只是展示两个非常经典的动态规划例子，我们必须要深刻理解上面的两个例子，基本上动态规划算是入门一半了。</p>
<p>从上面的例子可以发现，使用动态规划来解决的问题，都可以使用回溯算法思想来解决。不过回溯算法的时间复杂度是指数级别的。而动态规划算法，在执行效率提高非常显著，但是这是在提高了空间复杂度（二维数组），所以，很多时候我们会讲：动态规划算法是空间换时间的算法思想。</p>
<p>个人觉得，贪心、分治、回溯、动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问 题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确 性。所以，你大可不必过于急于寻求动态规划的理论知识。 </p>
<h1 id="讲动态规划理论-一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"><a href="#讲动态规划理论-一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题" class="headerlink" title="讲动态规划理论:一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"></a>讲动态规划理论:一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</h1><blockquote>
<p>通过前面的两个例子，我们对动态规划有了初步的认识。接下来我们要学习的动态规划的理论知识，在学习完之后。</p>
<p>可以帮你解决这样几个问题:什么样的问题可以用动态规划解决? 解决动态规划问题的一般思考过程是什么样的?贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系? </p>
</blockquote>
<h2 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h2><p>什么问题适合用动态规划来解决？我总结为一个模型三个特征。</p>
<ol>
<li>什么是”一个模型”？<ul>
<li>一个模型：它指的是动态规划适合解决的问题的模型，也就是<strong>多阶段决策最优解模型。</strong></li>
<li>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后 我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</li>
</ul>
</li>
<li>什么是”三个特征”？<ul>
<li>三个特征：它们分别是最优子结构、无后效性和重复子问题。</li>
<li><strong>最优子结构</strong><ul>
<li>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优 解。 </li>
<li>如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前 面阶段的状态推导出来。 </li>
</ul>
</li>
<li><strong>无后效性</strong><ul>
<li>第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么 一步一步推导出来的。 </li>
<li>第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。 </li>
</ul>
</li>
<li><strong>重复子问题</strong><ul>
<li>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。 </li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="实战：n-n矩阵求解最短路径"><a href="#实战：n-n矩阵求解最短路径" class="headerlink" title="实战：n*n矩阵求解最短路径"></a>实战：n*n矩阵求解最短路径</h3><ol>
<li><p>问题描述：我们有一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上⻆，终止位置在右下⻆。我们将棋子从左 上⻆移动到右下⻆。每次只能向右或者向下移动一位。从左上⻆到右下⻆，会有很多不同的路径可以走。我们把每条路径经过 的数字加起来看作路径的⻓度。那从左上⻆移动到右下⻆的最短路径⻓度是多少呢? </p>
</li>
<li><p>图解：</p>
<p><img alt="image-20191127085701653" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cben6rrfj30bp0auq4n.jpg" class="lazyload"></p>
<p><img alt="image-20191127085727817" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cbf3hybtj30bn08oadu.jpg" class="lazyload"></p>
</li>
</ol>
<ol start="3">
<li>分析：这个问题是如何满足动态规划的一个模型三个特征的。公式：<code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</code></li>
</ol>
<h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><ul>
<li>图解：</li>
</ul>
<p><img alt="image-20191127092347765" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cc6i3jh6j30l70dqjyk.jpg" class="lazyload"></p>
<ul>
<li><p>分析：我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态(也就是一个节点)包含三 个变量(i, j, dist)，其中i，j分别表示行和列，dist表示从起点到达(i, j)的路径⻓度。从图中，我们看出，尽管(i, j, dist)不存在重 复的，但是(i, j)重复的有很多。对于(i, j)重复的节点，我们只需要选择dist最小的节点，继续递归求解，其他节点就可以舍弃 了。 </p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用回溯算法思想：穷举（搜索）所有可能的路径</span></span><br><span class="line"><span class="comment"> * 调用方式:minDistBacktracing(0, 0, 0, w, n);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span></span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; minDist) minDist = dist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) &#123; <span class="comment">// 往下走，更新i=i+1, j=j</span></span><br><span class="line">        minDistBT(i + <span class="number">1</span>, j, dist + w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; n) &#123; <span class="comment">// 往右走，更新i=i, j=j+1</span></span><br><span class="line">        minDistBT(i, j + <span class="number">1</span>, dist + w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><ul>
<li>图解：表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策 过程，通过不断状态递推演进，将状态表填好。 </li>
</ul>
<p><img alt="image-20191127092549375" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cc8lurxdj30kx0okqc0.jpg" class="lazyload"></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用动态规划思想：解决矩阵最短路径问题（状态转义表法）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; <span class="comment">// 初始化states的第一行数据</span></span><br><span class="line">        sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">        states[<span class="number">0</span>][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states的第一列数据</span></span><br><span class="line">        sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">        states[i][<span class="number">0</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            states[i][j] =</span><br><span class="line">                    matrix[i][j] + Math.min(states[i][j - <span class="number">1</span>], states[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划求解：矩阵最短路径（状态转义方程法）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 方程：min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 调用minDist(n-1, n-1);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (mem[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minLeft = minDist(i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minUp = minDist(i - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">    mem[i][j] = currMinDist;</span><br><span class="line">    <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="两种动态规划解题思路"><a href="#两种动态规划解题思路" class="headerlink" title="两种动态规划解题思路"></a>两种动态规划解题思路</h2><blockquote>
<p>前面讲了什么场景适合使用动态规划来解决，现在，我们再总结动态规划解题的思路，让你有章可循。</p>
<p>解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。 </p>
<p>不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思 路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。 </p>
</blockquote>
<h3 id="状态转义表法"><a href="#状态转义表法" class="headerlink" title="状态转义表法"></a>状态转义表法</h3><ol>
<li>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回 溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在 重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。 </li>
<li>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯加<strong>“</strong>备忘录<strong>”</strong>的方法，来避免重复子问题。从执行效 率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，状态转移表法。第一种思路，我就不讲 了，你可以看看上一节的两个例子。我们重点来看状态转移表法是如何工作的。 </li>
<li>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、 数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表 的过程，翻译成代码，就是动态规划代码了。 如果是高维（&gt;2）数组就不适合使用状态转义表法来解决了。</li>
</ol>
<h3 id="状态转义方程法"><a href="#状态转义方程法" class="headerlink" title="状态转义方程法"></a>状态转义方程法</h3><ol>
<li>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。 根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我 们有两种代码实现方法，一种是递归加<strong>“</strong>备忘录<strong>”</strong>，另一种是迭代递推。 </li>
<li><strong>状态转移方程是解决动态规划的关键。</strong> </li>
</ol>
<h2 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h2><p>总结下四种算法：贪心、分治、回溯和动态规划区别和联系。</p>
<ol>
<li>分类：那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个 都不大一样。为什么这么说呢?前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治 算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。 </li>
<li>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。 穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问 题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。 </li>
<li>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个 特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分 割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子 问题。 </li>
<li>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题 也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性(这里我们不怎么强调重复子问题)。 其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。 每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。 </li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>我首先讲了什么样的问题适合用动态规划解决。这些问题可以总结概括为“一个模型三个特征”。其中，“一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子节、无后效性和重复子问题。 </p>
<p>然后，我讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以 概括为，回溯算法实现<strong>-</strong>定义状态<strong>-</strong>画递归树<strong>-</strong>找重复子问题<strong>-</strong>画状态转移表<strong>-</strong>根据递推关系填表<strong>-</strong>将填表过程翻译成代码。状态转移 方程法的大致思路可以概括为，找最优子结构<strong>-</strong>写状态转移方程<strong>-</strong>将状态转移方程翻译成代码。 </p>
<p>最后，我们对比了之前讲过的四种算法思想。贪心、回溯、动态规划可以解决的问题模型类似，都可以抽象成多阶段决策最优 解模型。尽管分治算法也能解决最优问题，但是大部分问题的背景都不适合抽象成多阶段决策模型。 </p>
<h1 id="TODO-42-讲动态规划实战-如何实现搜索引擎中的拼写纠错功能-——47讲向量空间：如何实现一个简单的音乐推荐系统"><a href="#TODO-42-讲动态规划实战-如何实现搜索引擎中的拼写纠错功能-——47讲向量空间：如何实现一个简单的音乐推荐系统" class="headerlink" title="TODO:42-讲动态规划实战:如何实现搜索引擎中的拼写纠错功能 ——47讲向量空间：如何实现一个简单的音乐推荐系统"></a>TODO:42-讲动态规划实战:如何实现搜索引擎中的拼写纠错功能 ——47讲向量空间：如何实现一个简单的音乐推荐系统</h1><h2 id="需要去完成的事情"><a href="#需要去完成的事情" class="headerlink" title="需要去完成的事情"></a>需要去完成的事情</h2><h1 id="讲B-树-MySQL数据库索引是如何实现的"><a href="#讲B-树-MySQL数据库索引是如何实现的" class="headerlink" title="讲B+树:MySQL数据库索引是如何实现的"></a>讲B+树:MySQL数据库索引是如何实现的</h1><blockquote>
<p>问题：数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</p>
</blockquote>
<h2 id="思考的过程比结论更重要"><a href="#思考的过程比结论更重要" class="headerlink" title="思考的过程比结论更重要"></a>思考的过程比结论更重要</h2><h3 id="解决问题的前提是定义清楚问题"><a href="#解决问题的前提是定义清楚问题" class="headerlink" title="解决问题的前提是定义清楚问题"></a>解决问题的前提是定义清楚问题</h3><p>如何定义清楚问题？除了对问题进行详细的调研，还有一个办法，那就是，<strong>通过对一些模糊的需求进行假设，来限定要解决的问题的范围。</strong></p>
<blockquote>
<p>功能需求：索引是怎么实现的？所以，这里我们假设要解决的问题，只包含这样两个常用的需求: </p>
<ul>
<li>根据某个值查找数据，比如select * from user where id=1234;</li>
<li>根据区间值来查找某些数据，比如select * from user where id &gt; 1234 and id &lt; 2345 </li>
</ul>
<p>除了这些功能性需求之外 ，我们着重考虑性能方面的需求。性能方面的需求，我们主要考察时间和空间两方 面，也就是执行效率和存储空间。 </p>
<p>在执行效率方面，我们希望通过索引，查询数据的效率尽可能的高;在存储空间方面，我们希望索引不要消耗太多的内存空 间。 </p>
</blockquote>
<h3 id="尝试用学过的数据结构解决这个问题"><a href="#尝试用学过的数据结构解决这个问题" class="headerlink" title="尝试用学过的数据结构解决这个问题"></a>尝试用学过的数据结构解决这个问题</h3><ul>
<li><p>问题的需求大致定义清楚了，我们现在回想一下，能否利用已经学习过的数据结构解决这个问题呢?<strong>支持快速查询、插入等操 作的动态数据结构，我们已经学习过散列表、平衡二叉查找树、跳表。</strong> </p>
<ol>
<li><p>散列表：散列表的查询性能很好，时间复杂度O(1)。但是散列表不支持按照区间快速查找数据。不满足需求。</p>
</li>
<li><p>平衡二叉查找树：平衡二叉查找树的查找性能也很高，时间复杂度O(logn)。而且，对树中序遍历，我们可以得到一个从小到大的有序数据序列。但是仍然无法查找区间的值。不满足需求。</p>
</li>
<li><p>跳表：跳表是在链表之上加上多层所有构成的。它支持快速插入、查找、删除数据，对应时间复杂度为O(logn)。并且，跳表也支持按照区间快速地查找数据。</p>
<p><img alt="image-20191128083601585" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dgf5afwqj30ln0bvjw2.jpg" class="lazyload"></p>
</li>
</ol>
</li>
<li><p>跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作B+树。不过，它是通过 二叉查找树演化过来的，而非跳表。 所以，接下来，我还再从二叉查找树讲起，看 它是如何一步一步被改造成B+树的。 </p>
</li>
</ul>
<h2 id="改造二叉查找树来解决这个问题"><a href="#改造二叉查找树来解决这个问题" class="headerlink" title="改造二叉查找树来解决这个问题"></a>改造二叉查找树来解决这个问题</h2><p>为了解决二叉查找树可以满足按照区间来查找数据，我们吧二叉查找树这样更改：<strong>树中的节点不存储数据本身，而只是作为索引。除此之外，我们把每个叶子节点串在一条链表上</strong>，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这 样，看起来是不是很像跳表呢? </p>
<p><img alt="image-20191128084452045" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dgobil15j30kr0dmq83.jpg" class="lazyload"></p>
<p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们 再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。 </p>
<p><img alt="image-20191128084529385" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dgoyy4l0j30cq0chgp3.jpg" class="lazyload"></p>
<h2 id="B-树讲解"><a href="#B-树讲解" class="headerlink" title="B+树讲解"></a>B+树讲解</h2><h3 id="B-树演进"><a href="#B-树演进" class="headerlink" title="B+树演进"></a>B+树演进</h3><p>经过我们改造的二叉查找树满足按照区间查找，如果我们把索引存在内存中，在内存中访问速度很快，查询效率非常高。但是占用的内存会非常大。</p>
<p>假设我们的一张表中有1亿数据给建立索引，那二叉查找树树当中大约会有1亿个节点，假设一个节点是16字节，那这张表的这个索引占用的内存是1G。如果有这样的10张表就使用了10G的内存空间。那如何解决这个问题呢？</p>
<p>我们可以借助<strong>时间换空间的思路</strong>，把索引存储在硬盘中，而非内存中。我们都知道，<strong>硬盘是一个非常慢速的存储设备。通常内 存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的</strong>。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中 读取所花费时间的上万倍，甚至几十万倍。 </p>
<p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的 读取(或者访问)，都对应一次磁盘IO操作。<strong>树的高度就等于每次查询数据时磁盘IO操作的次数。</strong></p>
<p>我们前面讲到，比起内存读写操作，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作，也就是，尽量降 低树的高度。那如何降低树的高度呢? </p>
<p>我们来看下，<strong>如果我们把索引构建成m叉树</strong>，高度是不是比二叉树要小呢?如图所示，给16个数据构建二叉树索引，树的高度 是4，查找一个数据，就需要4个磁盘IO操作(如果根节点存储在内存中，其他结点存储在磁盘中)，如果对16个数据构建五 叉树索引，那高度只有2，查找一个数据，<strong>对应只需要2次磁盘操作</strong>。如果m叉树中的m是100，那对一亿个数据构建索引，树 的高度也只是3，最多只要3次磁盘IO就能获取到数据。磁盘IO变少了，查找数据的效率也就提高了。 </p>
<p><img alt="image-20191128090515170" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dh9j6unmj30ih0az41p.jpg" class="lazyload"></p>
<p><img alt="image-20191128090523894" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dh9o6xgyj30hr08mmzo.jpg" class="lazyload"></p>
<h3 id="B-树实现"><a href="#B-树实现" class="headerlink" title="B+树实现"></a>B+树实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述:</span></span><br><span class="line"><span class="comment"> * b+树实现：改进版本的二叉查找树</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果我们将m叉树实现B+树索引，用代码实现出来，就是下面这个样子(假设我们给int类型的数据库字段添加索引，所以代 码中的keywords是int类型的):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Noah</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-28 09:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_48_BPlus_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是B+树非叶子节点的定义。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 假设keywords=[3, 5, 8, 10]</span></span><br><span class="line"><span class="comment">     * 4个键值将数据分为5个区间:(-INF,3), [3,5), [5,8), [8,10), [10,INF)</span></span><br><span class="line"><span class="comment">     * 5个区间分别对应:children[0]...children[4]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * m值是事先计算得到的，计算的依据是让所有信息的大小正好等于⻚的大小:</span></span><br><span class="line"><span class="comment">     * PAGE_SIZE = (m-1)*4[keywordss大小]+m*8[children大小]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> m = <span class="number">5</span>; <span class="comment">// 5叉树</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[m - <span class="number">1</span>]; <span class="comment">// 键值，用来划分数据区间</span></span><br><span class="line">        <span class="keyword">public</span> BPlusTreeNode[] children = <span class="keyword">new</span> BPlusTreeNode[m];<span class="comment">//保存子节点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是B+树中叶子节点的定义。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * B+树中的叶子节点跟内部结点是不一样的,</span></span><br><span class="line"><span class="comment">     * 叶子节点存储的是值，而非区间。</span></span><br><span class="line"><span class="comment">     * 这个定义里，每个叶子节点存储3个数据行的键值及地址信息。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * k值是事先计算得到的，计算的依据是让所有信息的大小正好等于⻚的大小:</span></span><br><span class="line"><span class="comment">     * PAGE_SIZE = k*4[keyw..大小]+k*8[dataAd..大小]+8[prev大小]+8[next大小]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeLeafNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[k]; <span class="comment">// 数据的键值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span>[] dataAddress = <span class="keyword">new</span> <span class="keyword">long</span>[k]; <span class="comment">// 数据地址</span></span><br><span class="line">        <span class="keyword">public</span> BPlusTreeLeafNode prev; <span class="comment">// 这个结点在链表中的前驱结点</span></span><br><span class="line">        <span class="keyword">public</span> BPlusTreeLeafNode next; <span class="comment">// 这个结点在链表中的后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一波上面的代码：</p>
<p>对于相同个数的数据构建m叉树索引，m叉树中的m越大，那树的高度就越小，那m叉树中的m是不是越大越好呢?到底多大才 最合适呢? </p>
<p>不管是内存中的数据，还是磁盘中的数据，<strong>操作系统都是按⻚(一⻚大小通常是4KB，这个值可以通过getconfig PAGE_SIZE 命令查看)来读取的，一次会读一⻚的数据</strong>。如果要读取的数据量超过一⻚的大小，就会触发多次IO操作。所以，我们在选择 m大小的时候，要尽量让每个节点的大小等于一个⻚的大小。读取一个节点，只需要一次磁盘IO操作。 </p>
<p>图解B+树实现：</p>
<p><img alt="image-20191128092530711" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dhum5x90j30l20g5ahg.jpg" class="lazyload"></p>
<h4 id="B-树的弊"><a href="#B-树的弊" class="headerlink" title="B+树的弊"></a>B+树的弊</h4><p>尽管索引可以提高数据库的查询效率，但是索引有利也有弊，它让写入/更新数据的效率下降，这是为什么呢？</p>
<p>对于一个B+树来说，m值是根据⻚的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在往数据库中写入数据 的过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个⻚的大小，读取这样一个节点， 就会导致多次磁盘IO操作。我们该如何解决这个问题呢? </p>
<p>实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有 可能超过m个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响 到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解(图中的B+树是一个三叉树。我们限定叶子节点 中，数据的个数超过2个就分裂节点;非叶子节点中，子节点的个数超过3个就分裂节点)。 </p>
<p><img alt="image-20191128093840080" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9di8aq6i9j30ly0gaqbg.jpg" class="lazyload"></p>
<p>正是因为要时刻保证B+树索引是一个m叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变 慢，删除数据也会变慢。这是为什么呢? </p>
<p>我们可以设置一个阈值。在B+树中，这个阈值等于m/2。如果某个节点的子节点个数小于m/2，我们就将它跟相邻的兄弟节点 合并。不过，合并之后结点的子节点个数有可能会超过m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节 点。 </p>
<p><img alt="image-20191128094035714" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9diaasn9uj30m50gbqbk.jpg" class="lazyload"></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>今天我们梳理了B+树是如何实现索引的，底层依赖的数据结构是B+树。B+树通过存储在磁盘的多叉查找树结构，做到时间、空间的平衡，既保证了执行效率，又节省了内存。</p>
<p>上面是一步步介绍B+树的由来，比较零散。这里再总结一下<strong>B+树的特点。</strong></p>
<ol>
<li>m叉查找树=B+树，m是通过计算得到的，为了刚好一个节点存储的最大内存大小不超过”一页”的大小。</li>
<li>每个节点中子节点的个数不能超过m，也不能小于m/2</li>
<li>根节点的子节点个数可以不超过m/2，这是一个例外。</li>
<li>m叉树只存储索引，并不真正存储数据，有点类似跳表。</li>
<li>通过链表将叶子节点串联在一起，这样实现区间查找。</li>
<li>一般情况，根节点存储会被存储在内存中，其他节点存储在磁盘中。</li>
</ol>
<p>除了B+树，你可能还听说过B树、B-树，我这里简单提一下。实际上，B-树就是B树，英文翻译都是B-Tree，这里的“-”并不是 相对B+树中的“+”，而只是一个连接符。这个很容易误解，所以我强调下。 </p>
<p>而B树实际上是低级版的B+树，或者说B+树是B树的改进版。<strong>B树跟B+树的不同点</strong>主要集中在这几个地方: </p>
<ol>
<li>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据。</li>
<li>B树中叶子节点并不需要链表来串联。</li>
<li>也就是说，B树只是一个每个节点的子节点个数不能小于m/2的m叉树。 </li>
</ol>
<h1 id="TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能"><a href="#TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能" class="headerlink" title="TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能"></a>TODO：49讲搜索：如何用A搜索算法实现游戏中的寻路功能</h1><h2 id="需要去完成的事情-1"><a href="#需要去完成的事情-1" class="headerlink" title="需要去完成的事情"></a>需要去完成的事情</h2><h1 id="讲索引：如何在海量数据中快速查找某个数据"><a href="#讲索引：如何在海量数据中快速查找某个数据" class="headerlink" title="讲索引：如何在海量数据中快速查找某个数据"></a>讲索引：如何在海量数据中快速查找某个数据</h1><blockquote>
<p>我们在前面讲解了，Mysql的索引底层是依赖B+树这种数据结构。类似 <strong>Redis</strong>这样的<strong>Key-Value</strong>数据库中的索引，又是怎么实现的呢?底层依赖的又是什么数据结构呢? </p>
</blockquote>
<h2 id="为什么需要索引？"><a href="#为什么需要索引？" class="headerlink" title="为什么需要索引？"></a>为什么需要索引？</h2><p>在软件开发中，业务纷繁复杂，功能千变万化，但是，万变不离其宗。 如果抛开这些业务和功能的外壳，其实它们的本 质都可以抽象为“<strong>对数据的存储和计算</strong>”。 对应到数据结构和算法中，那“存储”需要的就是数据结构，“计算”需要的就是算法。 </p>
<p>对于存储的需求，功能上无外乎增删改查。这其实并不复杂。但是，一旦存储的数据很多，那性能就成了这些系统要关注的重 点。“如何节省存储空间、如何提高数据增删改查的执行效率”，这样的问题就成了设计的重点。而这些系统的实现，都离不开一个 东⻄，那就是<strong>索引</strong>。不夸张地说，索引设计得好坏，直接决定了这些系统是否优秀。 </p>
<p>索引这个概念，非常好理解。你可以类比书籍的目录来理解。如果没有目录，我们想要查找某个知识点的时候，就要一⻚一⻚ 翻。通过目录，我们就可以快速定位相关知识点的⻚数，查找的速度也会有质的提高。 </p>
<h2 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h2><p>对于系统设计需求，我们一般可以分为功能性需求和非功能性需求两个方面分析。</p>
<h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><ol>
<li><strong>数据是格式化数据还是非格式化数据？</strong><ul>
<li>要构建索引的原始数据，类型有很多。我把它分为两类，一类是结构化数据，比 如，MySQL中的数据;另一类是非结构化数据，比如搜索引擎中网⻚。对于非结构化数据，我们一般需要做预处理，提取出 查询关键词，对关键词构建索引。 </li>
</ul>
</li>
<li><strong>数据是静态数据还是动态数据？</strong><ul>
<li>如果原始数据是一组静态数据，也就是说，不会有数据的增加、删除、更新操作，所以，我们 在构建索引的时候，只需要考虑查询效率就可以了。这样，索引的构建就相对简单些。不过，大部分情况下，我们都是对动态 数据构建索引，也就是说，我们不仅要考虑到索引的查询效率，在原始数据更新的同时，我们还需要动态地更新索引。支持动 态数据集合的索引，设计起来相对也要更加复杂些。 </li>
</ul>
</li>
<li><strong>索引存储在内存还是硬盘中？</strong><ul>
<li>如果索引存储在内存中，那查询的速度肯定要比存储在磁盘中的高。但是，如果原始数据量很大的 情况下，对应的索引可能也会很大。这个时候，因为内存有限，我们可能就不得不将索引存储在磁盘中了。实际上，还有第三 种情况，那就是一部分存储在内存，一部分存储在磁盘，这样就可以兼顾内存消耗和查询效率。 </li>
</ul>
</li>
<li><strong>单值查找还是区间查找？</strong><ul>
<li>所谓单值查找，也就是根据查询关键词等于某个值的数据。这种查询需求最常⻅。所谓区间查找，就 是查找关键词处于某个区间值的所有数据。你可以类比MySQL数据库的查询需求，自己想象一下。实际上，不同的应用场 景，查询的需求会多种多样。 </li>
</ul>
</li>
<li><strong>单关键词查找还是多关键词组合查找？</strong><ul>
<li>比如，搜索引擎中构建的索引，既要支持一个关键词的查找，比如“数据结构”，也要支 持组合关键词查找，比如“数据结构 AND 算法”。对于单关键词的查找，索引构建起来相对简单些。对于多关键词查询来说， 要分多种情况。像MySQL这种结构化数据的查询需求，我们可以实现针对多个关键词的组合，建立索引;对于像搜索引擎这 样的非结构数据的查询需求，我们可以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关 键词组合的查询结果。 </li>
</ul>
</li>
<li>实际上，不同的场景，不同的原始数据，对于索引的需求也会千差万别。我这里只列举了一些比较有共性的需求。 </li>
</ol>
<h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><ol>
<li><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大。</strong></li>
<li><strong>在考虑索引查询效率的同时，我们还要考虑索引的维护成本。</strong> </li>
</ol>
<h2 id="构建索引常用的数据结构有哪些"><a href="#构建索引常用的数据结构有哪些" class="headerlink" title="构建索引常用的数据结构有哪些"></a>构建索引常用的数据结构有哪些</h2><p>我刚刚从很宏观的⻆度，总结了在索引设计的过程中，需要考虑的一些共性因素。现在，我们就来看，对于不同需求的索引结 构，底层一般使用哪种数据结构。 </p>
<p>实际上，常用来构建索引的数据结构，就是我们之前讲过的几种支持动态数据集合的数据结构。比如，散列表、红黑树、跳 表、B+树。除此之外，位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引。 </p>
<ol>
<li><strong>散列表</strong>：crud的性能非常好，时间复杂度是O(1)。一些键值数据库，比如Redis、Memcache。存储在内存中。</li>
<li><strong>红黑树</strong>：近似平衡二叉查找树，crud的时间复杂度是O(logn)。在Ext文件系统中，内存索引。</li>
<li><strong>B+树</strong>：和红黑树比较的话，更加适合构建存储在磁盘中的索引。B+树是一个M叉树，所以，对相同个数的数据构建索引，B+树的 高度要低于红黑树。当借助索引查询数据的时候，读取B+树索引，需要的磁盘IO次数非常更少。 大部分关系型数据库的索引，都是使用B+树实现的。</li>
<li><strong>跳表</strong>：crud的时间复杂度为O(logn)。我们通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引 对内存的消耗及其查询效率。Redis中的有序集合，就是用跳表来构建的。 </li>
<li><strong>布隆过滤器</strong> ：对数据的判定有一定的判错率。但是我可以扬长避短。判定存在的数据，可能不存在，但是判定不存在数据，那就肯定不存在。<ul>
<li>布隆过滤器最大的特点：<strong>占用内存非常少。</strong></li>
<li>优化思路：在内存中构建一个布隆过滤器，当查询数据的时候，会先通过内存的布隆过滤器，如果布隆过滤器判断不存在，那不用到磁盘去读取数据了。</li>
</ul>
</li>
</ol>
<h1 id="讲并行算法：如何利用并行处理提高算法的执行效率"><a href="#讲并行算法：如何利用并行处理提高算法的执行效率" class="headerlink" title="讲并行算法：如何利用并行处理提高算法的执行效率"></a>讲并行算法：如何利用并行处理提高算法的执行效率</h1><blockquote>
<p>算法的目的就是为了提高代码执行的效率，<strong>当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢?</strong>我们今 天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。</p>
<p> <strong>如何借助并行计 算的处理思想对算法进行改造?</strong> </p>
</blockquote>
<h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>问题：假设我们要给大小为8GB的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。<strong>对于排序来说，最常用的就是 时间复杂度为O(nlogn)的三种排序算法，归并排序、快速排序、堆排序</strong>。<strong>从理论上讲，这个排序问题，已经很难再从算法层面 优化了</strong>。而利用并行的处理思想，我们可以很轻松地将这个给8GB数据排序问题的执行效率提高很多倍。具体的实现思路有下 面两种。 </p>
<ol>
<li><strong>第一种是对归并排序并行化处理</strong> ：我们可以将这8GB的数据划分成16个小的数据集合，每个集合包含500MB的数据。我们用 16个线程，并行地对这16个500MB的数据集合进行排序。这16个小集合分别排序完成之后，我们再将这16个有序集合合并。 </li>
<li><strong>第二种是对快速排序并行化处理</strong> ：我们通过扫描一遍数据，找到数据所处的范围区间。我们把这个区间从小到大划分成16个 小区间。我们将8GB的数据划分到对应的区间中。针对这16个小区间的数据，我们启动16个线程，并行地进行排序。等到16 个线程都执行结束之后，得到的数据就是有序数据了。 </li>
</ol>
<p>对比这两种处理思路，它<strong>们利用的都是分治的思想，对数据进行分片，然后并行处理</strong>。它们的<strong>区别</strong>在于，第一种处理思路是， 先随意地对数据分片，排序之后再合并。第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处 理了。这个跟归并和快排的区别如出一辙。 </p>
<p>如果要排序的数据规模不是8GB，而是1TB，那问题的重点就不是算法的执行效率了，而是数据的读取效率。因为1TB的数据肯定是存在硬盘中，无法一次性读取到内存中，这样在排序的过程中，就会有频繁地磁盘数据的读取和 写入。<strong>如何减少磁盘的IO操作</strong>，减少磁盘数据读取和写入的总量，就变成了优化的重点。 </p>
<h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p>散列表是一种非常适合快速查找的数据结构。 下面的解决方案就是一致性哈希算法。</p>
<p>问题描述：如果我们是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我 们就需要对散列表进行动态扩容。对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存。比如，我们给 一个2GB大小的散列表进行扩容，扩展到原来的1.5倍，也就是3GB大小。这个时候，实际存储在散列表中的数据只有不到 2GB，所以内存的利用率只有60%，有1GB的内存是空闲的。 </p>
<p>解决方案：实际上，我们可以将数据随机分割成k份(比如16份)，每份中的数据只有原来的1/k，然后我们针对这k个小数据集合分别构 建散列表。这样，散列表的维护成本就变低了。当某个小散列表的装载因子过大的时候，我们可以单独对这个散列表进行扩 容，而其他散列表不需要进行扩容。 </p>
<p>成果：还是刚才那个例子，假设现在有2GB的数据，我们放到16个散列表中，每个散列表中的数据大约是150MB。当某个散列表需 要扩容的时候，我们只需要额外增加150*0.5=75MB的内存(假设还是扩容到原来的1.5倍)。不管从扩容的执行效率还是内存 的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。 </p>
<p>当我们要查找某个数据的时候，我们只需要通过16个线程，并行地在这16个散列表中查找数据。这样的查找性能，比起一个 大散列表的做法，也并不会下降，反倒有可能提高。 </p>
<h2 id="并行字符串匹配"><a href="#并行字符串匹配" class="headerlink" title="并行字符串匹配"></a>并行字符串匹配</h2><p>我们前面学过，在文本中查找某个关键词这样一个功能，可以通过字符串匹配算法来实现。我们之前学过的字符串匹配算法有 KMP、BM、RK、BF等。当在一个不是很⻓的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得 非常高效。但是，如果我们处理的是超级大的文本，那处理的时间可能就会变得很⻓，那有没有办法加快匹配速度呢? </p>
<p>我们可以把大的文本，分割成k个小文本。假设k是16，我们就启动16个线程，并行地在这16个小文本中查找关键词，这样整 个查找的性能就提高了16倍。16倍效率的提升，从理论的⻆度来说并不多。但是，对于真实的软件开发来说，这显然是一个 非常可观的优化。 </p>
<h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>广度优先搜索算法，我们需要利用两个队列来完成扩展顶点的工作。 </p>
<p>假设这两个队列分别是队列A和队列B。多线程并行处理队列A中的顶点，并将扩展得到的顶点存储在队列B中。等队列A中的 顶点都扩展完成之后，队列A被清空，我们再并行地扩展队列B中的顶点，并将扩展出来的顶点存储在队列A。这样两个队列循 环使用，就可以实现并行广度优先搜索算法。 </p>
<h1 id="讲算法实战（一）：剖析Redis常用数据类型对应的数据结构"><a href="#讲算法实战（一）：剖析Redis常用数据类型对应的数据结构" class="headerlink" title="讲算法实战（一）：剖析Redis常用数据类型对应的数据结构"></a>讲算法实战（一）：剖析Redis常用数据类型对应的数据结构</h1><blockquote>
<p>在结束了我们的基础篇（数据结构）和高级篇（算法）之后，我们现在正式进入我们的实战篇。</p>
<p>看看开源项目、经典系统是如何使用数据结构和算法的。</p>
<p>问题：经典数据库<strong>Redis</strong>中的常用数据类型，底层都是用哪种数据结构实现的? </p>
</blockquote>
<h2 id="Redis数据库介绍"><a href="#Redis数据库介绍" class="headerlink" title="Redis数据库介绍"></a>Redis数据库介绍</h2><p>Redis是一种键值（Key-Value）数据库，也被称为非关系型数据库。具有下面的特点：</p>
<ul>
<li>由于Redis只包含键和值，只能通过”键”来查询”值”。正是因为这样简单的存储结构，让Redis的读写效率很高。</li>
<li>Redis是内存数据库，效率高。也可以将内存的的数据落盘到磁盘。</li>
<li>Redis的键的数据类型是字符串，但是值的数据类型有：字符串、列表、字典、集合、有序集合。</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>省略</p>
<h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表这种数据类型支持存储一组数据。有两种实现方法，<strong>一种是压缩列表，另外一种是双向循环列表</strong>。</p>
<p>当列表中存储的数据量比较小的时候，列表采用压缩列表的方式实现。具体满足下面两个条件</p>
<ul>
<li>列表中保存的单个数据小于64字节</li>
<li>列表中数据个数少于512个</li>
</ul>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>压缩列表不是基础数据结构，而是redis自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小/类型不同。</p>
<p><img alt="image-20191202090838034" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i3ubjqeij30j0067go5.jpg" class="lazyload"></p>
<p>如何理解”压缩”二字？</p>
<ul>
<li>压缩：直观的反应就是这种存储结构节省内存。压缩列表和数组存储的思路不同，数组要求每个元素的大小类型相同，那数组就会取最大元素的长度作为每个元素的长度，假设最长的是20字节，但是大多数元素才4字节。就浪费了很多存储空间。而压缩列表并不这样要求。</li>
<li>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内 存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</li>
</ul>
<p>当列表中存储的数据量比较大的时候，也就是刚才那两个条件不满足的时候，列表就要通过双向循环链表实现了。</p>
<p>参考C语言的列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是C语言代码，因为Redis是用C语言实现的。 </span></span><br><span class="line">typedef struct listnode &#123;</span><br><span class="line">	struct listNode *prev; </span><br><span class="line">	struct listNode *next; </span><br><span class="line">	<span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">typedef struct list &#123; </span><br><span class="line">	listNode *head; </span><br><span class="line">	listNode *tail; </span><br><span class="line">	unsigned <span class="keyword">long</span> len; </span><br><span class="line">	<span class="comment">// ....省略其他定义</span></span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>

<h3 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h3><p>字典类型用来存储一组数据对，每个数据对又包含键值两部分。字典类型也有两种实现方式。<strong>一种是压缩列表，另一种是散列表</strong>。</p>
<p>Redis使用压缩列表实现字典，需要满足以下两个条件：</p>
<ul>
<li>字典中保存的键和值的大小都要小于64字节。</li>
<li>字典中键值对的个数小于512个。</li>
</ul>
<p>如果不能满足上面两个条件的时候，Redis就使用散列表来实现字典类型。Redis使用MurmurHash2这种运行速度快、随机 性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis使用链表法来解决。除此之外，Redis还支持散列表的动态扩容、 缩容。</p>
<p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于1的时候，Redis会触 发扩容，将散列表扩大为原来大小的2倍左右。</p>
<p>当数据动态减少之后，为了节省内存，当装载因子小于0.1的时候，Redis就会触发缩容，缩小为字典中数据个数的大约2倍大 小。</p>
<p>前面我们提到过，扩容或者缩容要做大量的数据搬迁和哈希值重新计算，比较耗时，Redis使用的机制就是我们前面讲过的渐进式扩容缩容策略，将数据的搬移分批完成，避免大量数据一次性搬移导致服务停顿。</p>
<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。</p>
<p>Redis的集合使用有序数组存储的两个条件</p>
<ul>
<li>存储的数据都是整数。</li>
<li>存储的数据元素个数不超过512个。</li>
</ul>
<h3 id="有序集合（sortedSet）"><a href="#有序集合（sortedSet）" class="headerlink" title="有序集合（sortedSet）"></a>有序集合（sortedSet）</h3><p>有序集合是基于<strong>跳表</strong>的实现，它用来存储一组数据，并且每个数据都有附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p>
<p>当数据量比较小时，有序集合的实现方式还有压缩列表，需要满足下面两个条件</p>
<ul>
<li>所有数据的大小都小于64字节。</li>
<li>元素个数要小于128个。</li>
</ul>
<h2 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h2><p>尽管Redis经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的 时候，存储在Redis中的数据也不会丢失。在机器重新启动之后，Redis只需要再将存储在硬盘中的数据，重新读取到内存， 就可以继续工作了。</p>
<p>如何把内存的数据落盘到数据库。实际上，Redis遇到的这个问题并不特殊，很多场景中都会遇到。<strong>我们把它叫作数据结构的持久化问题，或者对象的持久化问 题</strong>。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。</p>
<p>把数据结构持久化到硬盘，主要有两种解决思路。</p>
<ol>
<li>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis采用的就是这种持久化思路。但是耗时。</li>
<li>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这样的数据结构来举例。我们可以将 散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的 时候，就可以避免重新计算哈希值。</li>
</ol>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>Redis常用数据类型底层依赖的数据结构，总结下这五大类：压缩列表（特殊数组）、有序数组、链表、散列表、跳表。</p>
<h1 id="TODO：讲算法实战-二-剖析搜索引擎背后的经典数据结构和算法"><a href="#TODO：讲算法实战-二-剖析搜索引擎背后的经典数据结构和算法" class="headerlink" title="TODO：讲算法实战(二):剖析搜索引擎背后的经典数据结构和算法"></a>TODO：讲算法实战(二):剖析搜索引擎背后的经典数据结构和算法</h1><h2 id="需要去完成的事情-2"><a href="#需要去完成的事情-2" class="headerlink" title="需要去完成的事情"></a>需要去完成的事情</h2><h1 id="讲算法实战-三-剖析高性能队列Disruptor背后的数据结构和算法"><a href="#讲算法实战-三-剖析高性能队列Disruptor背后的数据结构和算法" class="headerlink" title="讲算法实战(三):剖析高性能队列Disruptor背后的数据结构和算法"></a>讲算法实战(三):剖析高性能队列Disruptor背后的数据结构和算法</h1><h2 id="需要去完成的事情-3"><a href="#需要去完成的事情-3" class="headerlink" title="需要去完成的事情"></a>需要去完成的事情</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Noah Pan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/">http://yoursite.com/2019/11/20/2019-11-20-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AE%97%E6%B3%95%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Noah</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法    </a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t5fdhdrj30u014qdkm.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97t6e0istj30p011iq6s.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/23/2020-02-23-%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"><img class="prev_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx22jv93j318k0p03zl.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>剑指Offer（完整版）</span></div></a></div><div class="next-post pull_right"><a href="/2019/10/18/2019-10-17-%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"><img class="next_cover lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>《数据结构与算法》-数据结构篇</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/18/2019-10-17-《数据结构与算法》-数据结构篇/" title="《数据结构与算法》-数据结构篇"><img class="relatedPosts_cover lazyload"data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzx54tnmej318k0oydh8.jpg"><div class="relatedPosts_title">《数据结构与算法》-数据结构篇</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/006y8mN6gy1g96i6cigbdj31400p0e27.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Noah Pan</div><div class="footer_custom_text">Hi,to contact me <a href="#">Noah</a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>